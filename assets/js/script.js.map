{"version":3,"sources":["script.js","foundation.core.js","foundation.util.keyboard.js","foundation.util.box.js","foundation.util.nest.js","foundation.util.mediaQuery.js","foundation.util.triggers.js","foundation.util.motion.js","foundation.dropdownMenu.js","foundation.offcanvas.js","Chart.js","charts-init.js","foundation-init.js"],"names":["_classCallCheck","instance","Constructor","TypeError","_typeof","Symbol","iterator","obj","constructor","prototype","$","functionName","fn","undefined","Function","name","funcNameRegex","results","exec","toString","length","trim","parseValue","str","isNaN","parseFloat","hyphenate","replace","toLowerCase","FOUNDATION_VERSION","Foundation","version","_plugins","_uuids","rtl","attr","plugin","className","attrName","this","registerPlugin","pluginName","uuid","GetYoDigits","$element","data","trigger","push","unregisterPlugin","splice","indexOf","removeAttr","removeData","prop","reInit","plugins","isJQ","each","_init","type","_this","fns","object","plgs","forEach","p","foundation","string","Object","keys","err","console","error","namespace","Math","round","pow","random","slice","reflow","elem","i","$elem","find","addBack","$el","opts","warn","split","e","opt","map","el","er","getFnName","transitionend","end","transitions","transition","WebkitTransition","MozTransition","OTransition","document","createElement","t","style","setTimeout","triggerHandler","util","throttle","func","delay","timer","context","args","arguments","apply","method","$meta","$noJS","appendTo","head","removeClass","MediaQuery","Array","call","plugClass","ReferenceError","window","Date","now","getTime","vendors","requestAnimationFrame","vp","cancelAnimationFrame","test","navigator","userAgent","lastTime","callback","nextTime","max","clearTimeout","performance","start","bind","oThis","aArgs","fToBind","fNOP","fBound","concat","jQuery","getKeyCodes","kcs","k","kc","keyCodes","9","13","27","32","37","38","39","40","commands","Keyboard","parseKey","event","key","which","keyCode","String","fromCharCode","toUpperCase","shiftKey","ctrlKey","altKey","handleKey","component","functions","cmds","command","commandList","ltr","extend","returnValue","handled","unhandled","findFocusable","filter","is","register","componentName","trapFocus","$focusable","$firstFocusable","eq","$lastFocusable","on","target","preventDefault","focus","releaseFocus","off","ImNotTouchingYou","element","parent","lrOnly","tbOnly","top","bottom","left","right","eleDims","GetDimensions","parDims","offset","height","width","windowDims","allDirs","Error","rect","getBoundingClientRect","parRect","parentNode","winRect","body","winY","pageYOffset","winX","pageXOffset","parentDims","GetOffsets","anchor","position","vOffset","hOffset","isOverflow","$eleDims","$anchorDims","Box","Nest","Feather","menu","items","role","subMenuClass","subItemClass","hasSubClass","$item","$sub","children","addClass","aria-haspopup","aria-label","text","aria-expanded","data-submenu","aria-hidden","Burn","css","parseStyleToObject","styleObject","reduce","ret","param","parts","val","decodeURIComponent","hasOwnProperty","isArray","queries","current","namedQueries","self","extractedStyles","value","_getCurrentSize","_watcher","atLeast","size","query","get","matchMedia","matches","matched","newSize","currentSize","styleMedia","media","script","getElementsByTagName","info","id","insertBefore","getComputedStyle","currentStyle","matchMedium","styleSheet","cssText","textContent","checkListeners","eventsListener","resizeListener","scrollListener","closemeListener","yetiBoxes","plugNames","listeners","join","pluginId","not","debounce","$nodes","MutationObserver","nodes","querySelectorAll","listeningElementsMutation","mutationRecordsList","$target","attributeName","closest","elementObserver","observe","attributes","childList","characterData","subtree","attributeFilter","prefixes","triggers","stopPropagation","animation","Motion","animateOut","fadeOut","IHearYou","Move","duration","move","ts","prog","anim","animate","isIn","cb","finish","hide","reset","transitionDuration","initClass","activeClass","initClasses","activeClasses","show","offsetWidth","one","animateIn","_createClass","defineProperties","props","descriptor","enumerable","configurable","writable","defineProperty","protoProps","staticProps","DropdownMenu","options","defaults","ENTER","SPACE","ARROW_RIGHT","ARROW_UP","ARROW_DOWN","ARROW_LEFT","ESCAPE","subs","$menuItems","$tabs","verticalClass","hasClass","rightClass","alignment","parents","changed","_events","hasTouch","ontouchstart","parClass","handleClickFn","parentsUntil","hasSub","hasClicked","closeOnClick","clickOpen","forceFollow","stopImmediatePropagation","_hide","_show","add","closeOnClickInside","disableHover","hoverDelay","autoclose","closingTime","$prevElement","$nextElement","isTab","index","$elements","siblings","nextSibling","prevSibling","openSub","closeSub","close","open","_isVertical","down","up","next","previous","$body","$link","idx","$sibs","clear","oldClass","$parentLi","_addBodyHandler","$toClose","somethingToClose","data-is-click","OffCanvas","$lastTrigger","$triggers","contentOverlay","overlay","overlayPosition","setAttribute","$overlay","append","isRevealed","RegExp","revealClass","revealOn","match","_setMQChecker","transitionTime","open.zf.trigger","close.zf.trigger","toggle.zf.trigger","toggle","keydown.zf.offcanvas","_handleKeyboard","click.zf.offcanvas","reveal","$closer","scrollHeight","clientHeight","scrollTop","allowUp","allowDown","lastY","originalEvent","pageY","forceTo","scrollTo","contentScroll","_stopScrolling","_recordScrollable","_stopScrollPropagation","autoFocus","canvasFocus","_this2","f","exports","module","define","amd","g","global","Chart","n","r","s","o","u","a","require","code","l","1","2","getRgba","abbr","hex","rgba","per","keyword","rgb","parseInt","colorNames","scale","getHsla","hsl","alpha","h","getHwb","hwb","w","b","getRgb","getHsl","hsla","getAlpha","vals","hexString","hexDouble","rgbString","rgbaString","percentString","percentaString","hslString","hslaString","hwbString","reverseNames","num","min","6","3","convert","Color","values","hsv","cmyk","setValues","red","lightness","v","whiteness","c","cyan","JSON","stringify","setSpace","rgbArray","hslArray","hsvArray","hwbArray","cmykArray","rgbaArray","hslaArray","setChannel","green","blue","hue","saturation","saturationv","blackness","magenta","yellow","black","rgbNumber","luminosity","lum","chan","contrast","color2","lum1","lum2","level","contrastRatio","dark","yiq","light","negate","lighten","ratio","darken","saturate","desaturate","whiten","blacken","greyscale","clearer","opaquer","rotate","degrees","mix","mixinColor","weight","color1","w1","w2","toJSON","clone","result","source","spaces","maxes","getValues","space","charAt","chans","capped","sname","svalues","5","4","rgb2hsl","delta","rgb2hsv","rgb2hwb","rgb2cmyk","m","y","rgb2keyword","reverseKeywords","rgb2xyz","x","z","rgb2lab","xyz","rgb2lch","lab2lch","hsl2rgb","t1","t2","t3","hsl2hsv","sv","hsl2hwb","hsl2cmyk","hsl2keyword","hsv2rgb","hi","floor","q","hsv2hsl","sl","hsv2hwb","hsv2cmyk","hsv2keyword","hwb2rgb","wh","bl","hwb2hsl","hwb2hsv","hwb2cmyk","hwb2keyword","cmyk2rgb","cmyk2hsl","cmyk2hsv","cmyk2hwb","cmyk2keyword","xyz2rgb","xyz2lab","xyz2lch","lab2xyz","lab","y2","hr","atan2","PI","sqrt","lab2rgb","lch2lab","lch","cos","sin","lch2xyz","lch2rgb","keyword2rgb","cssKeywords","keyword2hsl","keyword2hsv","keyword2hwb","keyword2cmyk","keyword2lab","keyword2xyz","aliceblue","antiquewhite","aqua","aquamarine","azure","beige","bisque","blanchedalmond","blueviolet","brown","burlywood","cadetblue","chartreuse","chocolate","coral","cornflowerblue","cornsilk","crimson","darkblue","darkcyan","darkgoldenrod","darkgray","darkgreen","darkgrey","darkkhaki","darkmagenta","darkolivegreen","darkorange","darkorchid","darkred","darksalmon","darkseagreen","darkslateblue","darkslategray","darkslategrey","darkturquoise","darkviolet","deeppink","deepskyblue","dimgray","dimgrey","dodgerblue","firebrick","floralwhite","forestgreen","fuchsia","gainsboro","ghostwhite","gold","goldenrod","gray","greenyellow","grey","honeydew","hotpink","indianred","indigo","ivory","khaki","lavender","lavenderblush","lawngreen","lemonchiffon","lightblue","lightcoral","lightcyan","lightgoldenrodyellow","lightgray","lightgreen","lightgrey","lightpink","lightsalmon","lightseagreen","lightskyblue","lightslategray","lightslategrey","lightsteelblue","lightyellow","lime","limegreen","linen","maroon","mediumaquamarine","mediumblue","mediumorchid","mediumpurple","mediumseagreen","mediumslateblue","mediumspringgreen","mediumturquoise","mediumvioletred","midnightblue","mintcream","mistyrose","moccasin","navajowhite","navy","oldlace","olive","olivedrab","orange","orangered","orchid","palegoldenrod","palegreen","paleturquoise","palevioletred","papayawhip","peachpuff","peru","pink","plum","powderblue","purple","rebeccapurple","rosybrown","royalblue","saddlebrown","salmon","sandybrown","seagreen","seashell","sienna","silver","skyblue","slateblue","slategray","slategrey","snow","springgreen","steelblue","tan","teal","thistle","tomato","turquoise","violet","wheat","white","whitesmoke","yellowgreen","conversions","Converter","arg","pair","from","to","convs","routeSpace","fspace","7","10","11","12","14","15","16","17","18","19","20","21","22","23","24","25","26","28","29","30","31","33","34","35","36","42","43","44","45","46","47","48","8","Bar","config","Bubble","Doughnut","Line","PolarArea","Radar","defaultConfig","hover","mode","scales","xAxes","yAxes","tooltips","callbacks","title","label","tooltipItem","xLabel","yLabel","scatter","controllers","line","Scatter","helpers","bar","categoryPercentage","barPercentage","gridLines","offsetGridLines","DatasetController","dataElementType","elements","Rectangle","initialize","chart","datasetIndex","me","meta","getMeta","dataset","getDataset","stack","getStackCount","yScale","getScaleForId","yAxisID","stacks","datasets","dsMeta","getDatasetMeta","isDatasetVisible","stacked","update","rectangle","updateElement","xScale","xAxisID","scaleBase","getBasePixel","rectangleElementOptions","custom","_xScale","_yScale","_datasetIndex","_index","ruler","getRuler","_model","calculateBarX","calculateBarY","labels","datasetLabel","horizontal","base","calculateBarBase","calculateBarWidth","backgroundColor","getValueAtIndexOrDefault","borderSkipped","borderColor","borderWidth","pivot","getBaseValue","original","Number","currentDs","currentDsMeta","currentVal","getPixelForValue","stackCount","tickWidth","ticks","categoryWidth","categorySpacing","fullBarWidth","barWidth","barSpacing","barThickness","getStackIndex","j","stackIndex","leftTick","isCombo","sumPos","sumNeg","ds","stackedVal","draw","ease","len","easingDecimal","metaData","canvasHelpers","clipArea","ctx","chartArea","d","unclipArea","setHoverStyle","model","hoverBackgroundColor","getHoverColor","hoverBorderColor","hoverBorderWidth","removeHoverStyle","horizontalBar","tooltipItems","calculateBarHeight","originalBase","tickHeight","categoryHeight","fullBarHeight","barHeight","topTick","bubble","dataPoint","Point","points","point","pointElementOptions","dsIndex","getPixelForDecimal","NaN","radius","getRadius","hitRadius","skip","hoverRadius","dataVal","doughnut","animateRotate","animateScale","aspectRatio","legendCallback","legend","generateLabels","arc","arcOpts","fill","stroke","bw","fillStyle","strokeStyle","lineWidth","hidden","onClick","legendItem","ilen","cutoutPercentage","rotation","circumference","dataLabel","pie","Arc","linkScales","noop","getRingIndex","ringIndex","availableWidth","availableHeight","minSize","startAngle","endAngle","contains0","contains90","contains180","contains270","cutout","getMaxBorderWidth","outerRadius","innerRadius","radiusLength","getVisibleDatasetCount","offsetX","offsetY","total","calculateTotal","animationOpts","centerX","centerY","calculateCircumference","valueAtIndexOrDefault","abs","hoverWidth","_chart","lineEnabled","getValueOrDefault","showLine","showLines","spanGaps","datasetElementType","lineElementOptions","tension","lineTension","_scale","_children","borderCapStyle","borderDash","borderDashOffset","borderJoinStyle","steppedLine","stepped","cubicInterpolationMode","scaleTop","scaleBottom","scaleZero","updateBezierControlPoints","getPointBackgroundColor","pointBackgroundColor","getPointBorderColor","pointBorderColor","getPointBorderWidth","pointBorderWidth","pointOptions","includeOffset","pointRadius","pointHitRadius","calculatePointY","pointStyle","stackedRightValue","getRightValue","rightValue","capControlPoint","pt","controlPoints","area","splineCurveMonotone","splineCurve","previousItem","nextItem","controlPointPreviousX","controlPointPreviousY","controlPointNextX","controlPointNextY","capBezierPoints","pointHoverRadius","pointHoverBackgroundColor","pointHoverBorderColor","pointHoverBorderWidth","polarArea","lineArc","beginAtZero","count","countVisibleElements","xCenter","yCenter","visibleCount","datasetStartAngle","distance","getDistanceFromCenterForValue","resetRadius","radar","_loop","getBasePosition","pointPosition","getPointPositionForValue","easing","onProgress","onComplete","Animation","Element","currentStep","numSteps","render","onAnimationProgress","onAnimationComplete","animationService","frameDuration","animations","dropFrames","request","addAnimation","chartInstance","animationObject","lazy","animating","cancelAnimation","findIndex","animationWrapper","requestAnimFrame","startDigest","startTime","framesToDrop","endTime","drawPoint","edgeLength","xOffset","yOffset","drawImage","beginPath","closePath","moveTo","lineTo","SQRT2","fillRect","strokeRect","leftX","topY","sideSize","drawRoundedRectangle","save","clip","restore","initConfig","configMerge","updateConfig","newOptions","scaleOptions","tooltip","_options","platform","types","instances","Controller","item","acquireContext","canvas","uid","_bufferedRender","notify","retinaScale","bindEvents","responsive","resize","ensureScalesHaveIDs","buildScales","initToolTip","stop","silent","maintainAspectRatio","newWidth","getMaximumWidth","newHeight","getMaximumHeight","onResize","responsiveAnimationDuration","scalesOptions","xAxisOptions","yAxisOptions","dtype","isDefault","scaleType","scaleClass","scaleService","getScaleConstructor","addScalesToLayout","buildOrUpdateControllers","newControllers","controller","updateIndex","resetElements","animationDuration","_data","buildOrUpdateElements","updateLayout","updateDatasets","_bufferedRequest","layoutService","animationOptions","easingFunction","easingEffects","stepDecimal","easeDecimal","easingValue","boxes","box","drawDatasets","getElementAtEvent","Interaction","modes","single","getElementsAtEvent","intersect","getElementsAtXAxis","getElementsAtEventForMode","getDatasetAtEvent","_meta","generateLegend","destroy","unbindEvents","releaseContext","toBase64Image","toDataURL","Tooltip","_chartInstance","_listeners","listener","eventHandler","events","addEventListener","removeEventListener","updateHoverStyle","enabled","handleEvent","bufferedRequest","hoverOptions","lastActive","active","onHover","arrayEquals","listenArrayEvents","array","_chartjs","arrayEvents","res","unlistenArrayEvents","stub","addElements","scaleID","createMetaDataset","createMetaData","addElementAndReset","resyncElements","elementOpts","valueOrDefault","numMeta","numData","insertElements","onDataPush","onDataPop","pop","onDataShift","shift","onDataSplice","onDataUnshift","inherits","configuration","_view","_start","color","startVal","tooltipPosition","hasValue","isNumber","parseMaxStyle","styleValue","node","parentProperty","valueInPixels","isConstrainedValue","getConstraintDimension","domNode","maxStyle","percentageProperty","view","defaultView","constrainedNode","constrainedContainer","hasCNode","hasCContainer","infinity","POSITIVE_INFINITY","loopable","reverse","objClone","setFn","_base","extension","baseHasProperty","baseVal","scaleMerge","getScaleDefaults","valueObj","axisType","axisDefaults","defaultValue","where","collection","filterCallback","filtered","scope","findNextWhere","arrayToSearch","startIndex","currentItem","findPreviousWhere","extensions","ChartElement","Surrogate","__super__","isFinite","almostEquals","epsilon","almostWhole","rounded","NEGATIVE_INFINITY","sign","log10","log","LN10","toRadians","toDegrees","radians","getAngleFromPoint","centrePoint","anglePoint","distanceFromXCenter","distanceFromYCenter","radialDistanceFromCenter","angle","distanceBetweenPoints","pt1","pt2","aliasPixel","pixelWidth","firstPoint","middlePoint","afterPoint","d01","d12","s01","s12","fa","fb","EPSILON","pointBefore","pointCurrent","pointAfter","pointsWithTangents","deltaK","mK","pointsLen","slopeDeltaX","alphaK","betaK","tauK","squaredMagnitude","deltaX","loop","niceNum","range","niceFraction","exponent","fraction","linear","easeInQuad","easeOutQuad","easeInOutQuad","easeInCubic","easeOutCubic","easeInOutCubic","easeInQuart","easeOutQuart","easeInOutQuart","easeInQuint","easeOutQuint","easeInOutQuint","easeInSine","easeOutSine","easeInOutSine","easeInExpo","easeOutExpo","easeInOutExpo","easeInCirc","easeOutCirc","easeInOutCirc","easeInElastic","asin","easeOutElastic","easeInOutElastic","easeInBack","easeOutBack","easeInOutBack","easeInBounce","easeOutBounce","easeInOutBounce","webkitRequestAnimationFrame","mozRequestAnimationFrame","oRequestAnimationFrame","msRequestAnimationFrame","getRelativePosition","evt","mouseX","mouseY","currentTarget","srcElement","boundingRect","touches","clientX","clientY","paddingLeft","getStyle","paddingTop","paddingRight","paddingBottom","currentDevicePixelRatio","addEvent","eventType","attachEvent","removeEvent","handler","detachEvent","getConstraintWidth","getConstraintHeight","container","clientWidth","cw","ch","property","getPropertyValue","pixelRatio","devicePixelRatio","clearRect","fontString","pixelSize","fontStyle","fontFamily","longestText","font","arrayOfThings","cache","gc","garbageCollect","longest","thing","measureText","nestedThing","gcLen","textWidth","numberOfLabelLines","numberOfLines","quadraticCurveTo","CanvasGradient","defaultColor","a0","a1","v0","v1","callCallback","_tArg","colorValue","CanvasPattern","parseVisibleItems","jlen","getIntersectItems","inRange","getNearestItems","distanceMetric","minDistance","nearestItems","center","getCenterPoint","indexMode","x-axis","nearest","sort","sizeA","getArea","sizeB","intersectsItem","inXRange","inYRange","defaultFontColor","defaultFontFamily","defaultFontSize","defaultFontStyle","addBox","removeBox","getMinimumBoxSize","isHorizontal","fullWidth","chartWidth","maxChartAreaWidth","horizontalBoxHeight","maxChartAreaHeight","verticalBoxWidth","chartAreaHeight","minBoxSizes","fitBox","minBoxSize","minBox","scaleMargin","totalLeftBoxesWidth","maxHorizontalLeftPadding","totalRightBoxesWidth","maxHorizontalRightPadding","chartHeight","finalFitVerticalBox","totalTopBoxesHeight","totalBottomBoxesHeight","placeBox","leftPadding","rightPadding","layoutOptions","layout","padding","topPadding","bottomPadding","leftBoxes","rightBoxes","topBoxes","bottomBoxes","chartAreaBoxes","chartAreaWidth","maxVerticalTopPadding","maxVerticalBottomPadding","horizontalBox","getPadding","boxPadding","verticalBox","leftPaddingAddition","topPaddingAddition","newMaxChartAreaHeight","newMaxChartAreaWidth","getBoxWidth","labelOpts","fontSize","usePointStyle","boxWidth","createNewLegendAndAttach","legendOpts","Legend","display","ci","lineCap","lineDash","lineDashOffset","lineJoin","legendHitBoxes","doughnutMode","beforeUpdate","maxWidth","maxHeight","margins","beforeSetDimensions","setDimensions","afterSetDimensions","beforeBuildLabels","buildLabels","afterBuildLabels","beforeFit","fit","afterFit","afterUpdate","legendItems","globalDefault","itemOrDefault","labelFont","hitboxes","lineWidths","totalHeight","textAlign","textBaseline","vPadding","columnWidths","totalWidth","currentColWidth","currentColHeight","itemHeight","itemWidth","lineDefault","legendWidth","cursor","fontColor","drawLegendBox","isLineWidthZero","setLineDash","offSet","fillText","lh","hitBox","beforeInit","afterEvent","_cacheId","unregister","getAll","hook","params","descriptors","pluginService","PluginBase","computeTextSize","tick","parseFontOptions","globalDefaults","family","drawBorder","drawOnChartArea","drawTicks","tickMarkLength","zeroLineWidth","zeroLineColor","scaleLabel","labelString","minRotation","maxRotation","mirror","autoSkip","autoSkipPadding","labelOffset","Ticks","formatters","Scale","longestTextCache","beforeDataLimits","determineDataLimits","afterDataLimits","beforeBuildTicks","buildTicks","afterBuildTicks","beforeTickToLabelConversion","convertTicksToLabels","afterTickToLabelConversion","beforeCalculateTickRotation","calculateTickRotation","afterCalculateTickRotation","tickOpts","userCallback","tickFont","labelRotation","cosRotation","sinRotation","originalLabelWidth","labelWidth","getPixelForTick","angleRadians","scaleLabelOpts","gridLineOpts","scaleLabelFontSize","isFullWidth","largestTextWidth","tallestLabelHeightInLines","lineSpace","longestLabelWidth","labelHeight","firstTick","firstLabelWidth","lastTick","lastLabelWidth","handleMargins","rawValue","isValid","getLabelForIndex","getValueForPixel","innerWidth","pixel","finalVal","innerHeight","decimal","valueOffset","skipRatio","maxTicks","optionTicks","isRotated","useAutoskipper","maxTicksLimit","tickFontColor","tl","scaleLabelFontColor","scaleLabelFont","labelRotationRadians","longestRotatedLabel","itemsToDraw","xTickStart","xTickEnd","yTickStart","yTickEnd","isLastTick","shouldSkip","lineColor","zeroLineIndex","tx1","ty1","tx2","ty2","x1","y1","x2","labelX","labelY","xLineValue","labelXOffset","isLeft","tickPadding","yLineValue","glWidth","glColor","glBorderDash","glBorderDashOffset","itemToDraw","translate","scaleLabelX","scaleLabelY","constructors","registerScaleType","scaleConstructor","updateScaleDefaults","additions","generators","generationOptions","dataRange","spacing","stepSize","niceRange","niceMin","niceMax","ceil","numSpaces","logarithmic","exp","significand","tickVal","endExp","endSignificand","minNotZero","tickValue","logDelta","tickString","numDecimal","toFixed","remain","toExponential","createNewTitleBlockAndAttach","titleOpts","Title","titleBlock","pos","titleX","titleY","titleFont","mergeOpacity","colorString","opacity","pushOrConcat","toPush","createTooltipItem","getBaseModel","tooltipOpts","xPadding","yPadding","xAlign","yAlign","bodyFontColor","_bodyFontFamily","bodyFontFamily","_bodyFontStyle","bodyFontStyle","_bodyAlign","bodyAlign","bodyFontSize","bodySpacing","titleFontColor","_titleFontFamily","titleFontFamily","_titleFontStyle","titleFontStyle","titleFontSize","_titleAlign","titleAlign","titleSpacing","titleMarginBottom","footerFontColor","_footerFontFamily","footerFontFamily","_footerFontStyle","footerFontStyle","footerFontSize","_footerAlign","footerAlign","footerSpacing","footerMarginTop","caretSize","cornerRadius","legendColorBackground","multiKeyBackground","displayColors","getTooltipSize","combinedBodyLength","bodyItem","before","lines","after","beforeBody","afterBody","titleLineCount","footerLineCount","footer","widthPadding","maxLineWidth","determineAlignment","lf","rf","olf","orf","yf","midX","midY","getBackgroundPoint","vm","caretPadding","paddingAndSize","radiusAndPadding","beforeTitle","labelCount","afterTitle","beforeLabel","labelColor","activeElement","afterLabel","beforeFooter","afterFooter","getTitle","getBeforeBody","getBody","bodyItems","getAfterBody","getFooter","existingModel","_active","backgroundPoint","tooltipSize","caretX","caretY","labelColors","positioners","_eventPosition","itemSort","dataPoints","drawCaret","tooltipPoint","x3","y3","ptX","ptY","drawTitle","drawBody","textColor","xLinePadding","fillLineOfText","drawColorBoxes","drawFooter","drawBackground","_lastActive","average","eventPosition","nearestElement","tp","globalOpts","inLabelRange","chartX","chartY","pointRelativePosition","betweenAngles","withinRadius","halfAngle","halfRadius","centreAngle","rangeFromCentre","sA","eA","lineToPoint","previousPoint","pointVM","bezierCurveTo","fillPoint","lastDrawnIndex","currentVM","globalOptionLineElements","xRange","yRange","errMargin","isVertical","getBarBounds","halfWidth","halfHeight","cornerAt","corners","startCorner","signX","signY","barSize","halfStroke","borderLeft","borderRight","borderTop","borderBottom","borders","corner","bounds","41","readUsedSize","initCanvas","renderHeight","getAttribute","renderWidth","initial","displayWidth","displayHeight","createEvent","native","fromNativeEvent","eventTypeMap","createResizer","iframe","tabIndex","contentWindow","addResizeListener","ticking","resizer","firstChild","removeResizeListener","removeChild","touchstart","touchmove","touchend","pointerenter","pointerdown","pointermove","pointerup","pointerleave","pointerout","getElementById","HTMLCanvasElement","getContext","CanvasRenderingContext2D","removeAttribute","proxies","proxy","implementation","DatasetScale","getLabels","xLabels","yLabels","minIndex","maxIndex","offsetAmt","valueWidth","widthOffset","valueHeight","heightOffset","horz","valueDimension","LinearScale","LinearScaleBase","IDMatches","hasStacks","valuesPerStack","positiveValues","negativeValues","relativePoints","valuesForType","minVal","maxVal","handleTickRangeOptions","getTickLimit","tickFontSize","handleDirectionalChanges","innerDimension","ticksAsNumbers","minSign","maxSign","suggestedMin","suggestedMax","numericGeneratorOptions","fixedStepSize","LogarithmicScale","tickValues","newVal","getValueCount","getPointLabelFontOptions","pointLabelOptions","pointLabels","measureLabelSize","determineLimits","fitWithPointLabels","textSize","plFont","largestPossibleRadius","furthestLimits","furthestAngles","_pointLabelSizes","valueCount","getPointPosition","getIndexAngle","hLimits","vLimits","setReductions","drawingArea","setCenterPoint","getTextAlignForAngle","adjustPointPositionForLabelHeight","drawPointLabels","angleLineOpts","angleLines","pointLabelOpts","outerDistance","outerPosition","pointLabelPosition","pointLabelFontColor","drawRadiusLine","numberOrZero","showLabelBackdrop","backdropColor","backdropPaddingY","backdropPaddingX","LinearRadialScale","radiusReductionLeft","radiusReductionRight","radiusReductionTop","radiusReductionBottom","leftMovement","rightMovement","topMovement","bottomMovement","maxRight","maxLeft","maxTop","maxBottom","angleMultiplier","startAngleRadians","scalingFactor","distanceFromCenter","thisAngle","tickFontStyle","tickFontFamily","tickLabelFont","yCenterOffset","yHeight","moment","time","units","steps","maxStep","parser","format","unit","displayFormat","isoWeekday","minUnit","displayFormats","millisecond","second","minute","hour","day","week","month","quarter","year","TimeScale","getLabelMoment","labelMoments","getLabelDiff","labelDiffs","buildLabelDiffs","getMomentStartOf","startOf","tickUnit","scaleLabelMoments","labelMoment","parseTime","momentsForDataset","datasetVisible","scaleLabelDiffs","diff","diffsForDataset","unitScale","scaleSizeInUnits","unitStepSize","tempFirstLabel","tickFormatFunction","tickLabelWidth","labelCapacity","unitDefinitionIndex","unitDefinition","leadingUnitBuffer","trailingUnitBuffer","roundedStart","roundedEnd","newTick","tooltipFormat","formattedTick","tickMoments","asSeconds","getMonth","ready","$chart","chartData","colors","percentage","allData","tooltipLabel","tooltipData"],"mappings":"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","file":"script.js","sourcesContent":["'use strict';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n!function ($) {\n\n  \"use strict\";\n\n  var FOUNDATION_VERSION = '6.3.1';\n\n  // Global Foundation object\n  // This is attached to the window, or used as a module for AMD/Browserify\n  var Foundation = {\n    version: FOUNDATION_VERSION,\n\n    /**\n     * Stores initialized plugins.\n     */\n    _plugins: {},\n\n    /**\n     * Stores generated unique ids for plugin instances\n     */\n    _uuids: [],\n\n    /**\n     * Returns a boolean for RTL support\n     */\n    rtl: function rtl() {\n      return $('html').attr('dir') === 'rtl';\n    },\n    /**\n     * Defines a Foundation plugin, adding it to the `Foundation` namespace and the list of plugins to initialize when reflowing.\n     * @param {Object} plugin - The constructor of the plugin.\n     */\n    plugin: function plugin(_plugin, name) {\n      // Object key to use when adding to global Foundation object\n      // Examples: Foundation.Reveal, Foundation.OffCanvas\n      var className = name || functionName(_plugin);\n      // Object key to use when storing the plugin, also used to create the identifying data attribute for the plugin\n      // Examples: data-reveal, data-off-canvas\n      var attrName = hyphenate(className);\n\n      // Add to the Foundation object and the plugins list (for reflowing)\n      this._plugins[attrName] = this[className] = _plugin;\n    },\n    /**\n     * @function\n     * Populates the _uuids array with pointers to each individual plugin instance.\n     * Adds the `zfPlugin` data-attribute to programmatically created plugins to allow use of $(selector).foundation(method) calls.\n     * Also fires the initialization event for each plugin, consolidating repetitive code.\n     * @param {Object} plugin - an instance of a plugin, usually `this` in context.\n     * @param {String} name - the name of the plugin, passed as a camelCased string.\n     * @fires Plugin#init\n     */\n    registerPlugin: function registerPlugin(plugin, name) {\n      var pluginName = name ? hyphenate(name) : functionName(plugin.constructor).toLowerCase();\n      plugin.uuid = this.GetYoDigits(6, pluginName);\n\n      if (!plugin.$element.attr('data-' + pluginName)) {\n        plugin.$element.attr('data-' + pluginName, plugin.uuid);\n      }\n      if (!plugin.$element.data('zfPlugin')) {\n        plugin.$element.data('zfPlugin', plugin);\n      }\n      /**\n       * Fires when the plugin has initialized.\n       * @event Plugin#init\n       */\n      plugin.$element.trigger('init.zf.' + pluginName);\n\n      this._uuids.push(plugin.uuid);\n\n      return;\n    },\n    /**\n     * @function\n     * Removes the plugins uuid from the _uuids array.\n     * Removes the zfPlugin data attribute, as well as the data-plugin-name attribute.\n     * Also fires the destroyed event for the plugin, consolidating repetitive code.\n     * @param {Object} plugin - an instance of a plugin, usually `this` in context.\n     * @fires Plugin#destroyed\n     */\n    unregisterPlugin: function unregisterPlugin(plugin) {\n      var pluginName = hyphenate(functionName(plugin.$element.data('zfPlugin').constructor));\n\n      this._uuids.splice(this._uuids.indexOf(plugin.uuid), 1);\n      plugin.$element.removeAttr('data-' + pluginName).removeData('zfPlugin')\n      /**\n       * Fires when the plugin has been destroyed.\n       * @event Plugin#destroyed\n       */\n      .trigger('destroyed.zf.' + pluginName);\n      for (var prop in plugin) {\n        plugin[prop] = null; //clean up script to prep for garbage collection.\n      }\n      return;\n    },\n\n    /**\n     * @function\n     * Causes one or more active plugins to re-initialize, resetting event listeners, recalculating positions, etc.\n     * @param {String} plugins - optional string of an individual plugin key, attained by calling `$(element).data('pluginName')`, or string of a plugin class i.e. `'dropdown'`\n     * @default If no argument is passed, reflow all currently active plugins.\n     */\n    reInit: function reInit(plugins) {\n      var isJQ = plugins instanceof $;\n      try {\n        if (isJQ) {\n          plugins.each(function () {\n            $(this).data('zfPlugin')._init();\n          });\n        } else {\n          var type = typeof plugins === 'undefined' ? 'undefined' : _typeof(plugins),\n              _this = this,\n              fns = {\n            'object': function object(plgs) {\n              plgs.forEach(function (p) {\n                p = hyphenate(p);\n                $('[data-' + p + ']').foundation('_init');\n              });\n            },\n            'string': function string() {\n              plugins = hyphenate(plugins);\n              $('[data-' + plugins + ']').foundation('_init');\n            },\n            'undefined': function undefined() {\n              this['object'](Object.keys(_this._plugins));\n            }\n          };\n          fns[type](plugins);\n        }\n      } catch (err) {\n        console.error(err);\n      } finally {\n        return plugins;\n      }\n    },\n\n    /**\n     * returns a random base-36 uid with namespacing\n     * @function\n     * @param {Number} length - number of random base-36 digits desired. Increase for more random strings.\n     * @param {String} namespace - name of plugin to be incorporated in uid, optional.\n     * @default {String} '' - if no plugin name is provided, nothing is appended to the uid.\n     * @returns {String} - unique id\n     */\n    GetYoDigits: function GetYoDigits(length, namespace) {\n      length = length || 6;\n      return Math.round(Math.pow(36, length + 1) - Math.random() * Math.pow(36, length)).toString(36).slice(1) + (namespace ? '-' + namespace : '');\n    },\n    /**\n     * Initialize plugins on any elements within `elem` (and `elem` itself) that aren't already initialized.\n     * @param {Object} elem - jQuery object containing the element to check inside. Also checks the element itself, unless it's the `document` object.\n     * @param {String|Array} plugins - A list of plugins to initialize. Leave this out to initialize everything.\n     */\n    reflow: function reflow(elem, plugins) {\n\n      // If plugins is undefined, just grab everything\n      if (typeof plugins === 'undefined') {\n        plugins = Object.keys(this._plugins);\n      }\n      // If plugins is a string, convert it to an array with one item\n      else if (typeof plugins === 'string') {\n          plugins = [plugins];\n        }\n\n      var _this = this;\n\n      // Iterate through each plugin\n      $.each(plugins, function (i, name) {\n        // Get the current plugin\n        var plugin = _this._plugins[name];\n\n        // Localize the search to all elements inside elem, as well as elem itself, unless elem === document\n        var $elem = $(elem).find('[data-' + name + ']').addBack('[data-' + name + ']');\n\n        // For each plugin found, initialize it\n        $elem.each(function () {\n          var $el = $(this),\n              opts = {};\n          // Don't double-dip on plugins\n          if ($el.data('zfPlugin')) {\n            console.warn(\"Tried to initialize \" + name + \" on an element that already has a Foundation plugin.\");\n            return;\n          }\n\n          if ($el.attr('data-options')) {\n            var thing = $el.attr('data-options').split(';').forEach(function (e, i) {\n              var opt = e.split(':').map(function (el) {\n                return el.trim();\n              });\n              if (opt[0]) opts[opt[0]] = parseValue(opt[1]);\n            });\n          }\n          try {\n            $el.data('zfPlugin', new plugin($(this), opts));\n          } catch (er) {\n            console.error(er);\n          } finally {\n            return;\n          }\n        });\n      });\n    },\n    getFnName: functionName,\n    transitionend: function transitionend($elem) {\n      var transitions = {\n        'transition': 'transitionend',\n        'WebkitTransition': 'webkitTransitionEnd',\n        'MozTransition': 'transitionend',\n        'OTransition': 'otransitionend'\n      };\n      var elem = document.createElement('div'),\n          end;\n\n      for (var t in transitions) {\n        if (typeof elem.style[t] !== 'undefined') {\n          end = transitions[t];\n        }\n      }\n      if (end) {\n        return end;\n      } else {\n        end = setTimeout(function () {\n          $elem.triggerHandler('transitionend', [$elem]);\n        }, 1);\n        return 'transitionend';\n      }\n    }\n  };\n\n  Foundation.util = {\n    /**\n     * Function for applying a debounce effect to a function call.\n     * @function\n     * @param {Function} func - Function to be called at end of timeout.\n     * @param {Number} delay - Time in ms to delay the call of `func`.\n     * @returns function\n     */\n    throttle: function throttle(func, delay) {\n      var timer = null;\n\n      return function () {\n        var context = this,\n            args = arguments;\n\n        if (timer === null) {\n          timer = setTimeout(function () {\n            func.apply(context, args);\n            timer = null;\n          }, delay);\n        }\n      };\n    }\n  };\n\n  // TODO: consider not making this a jQuery function\n  // TODO: need way to reflow vs. re-initialize\n  /**\n   * The Foundation jQuery method.\n   * @param {String|Array} method - An action to perform on the current jQuery object.\n   */\n  var foundation = function foundation(method) {\n    var type = typeof method === 'undefined' ? 'undefined' : _typeof(method),\n        $meta = $('meta.foundation-mq'),\n        $noJS = $('.no-js');\n\n    if (!$meta.length) {\n      $('<meta class=\"foundation-mq\">').appendTo(document.head);\n    }\n    if ($noJS.length) {\n      $noJS.removeClass('no-js');\n    }\n\n    if (type === 'undefined') {\n      //needs to initialize the Foundation object, or an individual plugin.\n      Foundation.MediaQuery._init();\n      Foundation.reflow(this);\n    } else if (type === 'string') {\n      //an individual method to invoke on a plugin or group of plugins\n      var args = Array.prototype.slice.call(arguments, 1); //collect all the arguments, if necessary\n      var plugClass = this.data('zfPlugin'); //determine the class of plugin\n\n      if (plugClass !== undefined && plugClass[method] !== undefined) {\n        //make sure both the class and method exist\n        if (this.length === 1) {\n          //if there's only one, call it directly.\n          plugClass[method].apply(plugClass, args);\n        } else {\n          this.each(function (i, el) {\n            //otherwise loop through the jQuery collection and invoke the method on each\n            plugClass[method].apply($(el).data('zfPlugin'), args);\n          });\n        }\n      } else {\n        //error for no class or no method\n        throw new ReferenceError(\"We're sorry, '\" + method + \"' is not an available method for \" + (plugClass ? functionName(plugClass) : 'this element') + '.');\n      }\n    } else {\n      //error for invalid argument type\n      throw new TypeError('We\\'re sorry, ' + type + ' is not a valid parameter. You must use a string representing the method you wish to invoke.');\n    }\n    return this;\n  };\n\n  window.Foundation = Foundation;\n  $.fn.foundation = foundation;\n\n  // Polyfill for requestAnimationFrame\n  (function () {\n    if (!Date.now || !window.Date.now) window.Date.now = Date.now = function () {\n      return new Date().getTime();\n    };\n\n    var vendors = ['webkit', 'moz'];\n    for (var i = 0; i < vendors.length && !window.requestAnimationFrame; ++i) {\n      var vp = vendors[i];\n      window.requestAnimationFrame = window[vp + 'RequestAnimationFrame'];\n      window.cancelAnimationFrame = window[vp + 'CancelAnimationFrame'] || window[vp + 'CancelRequestAnimationFrame'];\n    }\n    if (/iP(ad|hone|od).*OS 6/.test(window.navigator.userAgent) || !window.requestAnimationFrame || !window.cancelAnimationFrame) {\n      var lastTime = 0;\n      window.requestAnimationFrame = function (callback) {\n        var now = Date.now();\n        var nextTime = Math.max(lastTime + 16, now);\n        return setTimeout(function () {\n          callback(lastTime = nextTime);\n        }, nextTime - now);\n      };\n      window.cancelAnimationFrame = clearTimeout;\n    }\n    /**\n     * Polyfill for performance.now, required by rAF\n     */\n    if (!window.performance || !window.performance.now) {\n      window.performance = {\n        start: Date.now(),\n        now: function now() {\n          return Date.now() - this.start;\n        }\n      };\n    }\n  })();\n  if (!Function.prototype.bind) {\n    Function.prototype.bind = function (oThis) {\n      if (typeof this !== 'function') {\n        // closest thing possible to the ECMAScript 5\n        // internal IsCallable function\n        throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');\n      }\n\n      var aArgs = Array.prototype.slice.call(arguments, 1),\n          fToBind = this,\n          fNOP = function fNOP() {},\n          fBound = function fBound() {\n        return fToBind.apply(this instanceof fNOP ? this : oThis, aArgs.concat(Array.prototype.slice.call(arguments)));\n      };\n\n      if (this.prototype) {\n        // native functions don't have a prototype\n        fNOP.prototype = this.prototype;\n      }\n      fBound.prototype = new fNOP();\n\n      return fBound;\n    };\n  }\n  // Polyfill to get the name of a function in IE9\n  function functionName(fn) {\n    if (Function.prototype.name === undefined) {\n      var funcNameRegex = /function\\s([^(]{1,})\\(/;\n      var results = funcNameRegex.exec(fn.toString());\n      return results && results.length > 1 ? results[1].trim() : \"\";\n    } else if (fn.prototype === undefined) {\n      return fn.constructor.name;\n    } else {\n      return fn.prototype.constructor.name;\n    }\n  }\n  function parseValue(str) {\n    if ('true' === str) return true;else if ('false' === str) return false;else if (!isNaN(str * 1)) return parseFloat(str);\n    return str;\n  }\n  // Convert PascalCase to kebab-case\n  // Thank you: http://stackoverflow.com/a/8955580\n  function hyphenate(str) {\n    return str.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();\n  }\n}(jQuery);\n/*******************************************\n *                                         *\n * This util was created by Marius Olbertz *\n * Please thank Marius on GitHub /owlbertz *\n * or the web http://www.mariusolbertz.de/ *\n *                                         *\n ******************************************/\n\n'use strict';\n\n!function ($) {\n\n  var keyCodes = {\n    9: 'TAB',\n    13: 'ENTER',\n    27: 'ESCAPE',\n    32: 'SPACE',\n    37: 'ARROW_LEFT',\n    38: 'ARROW_UP',\n    39: 'ARROW_RIGHT',\n    40: 'ARROW_DOWN'\n  };\n\n  var commands = {};\n\n  var Keyboard = {\n    keys: getKeyCodes(keyCodes),\n\n    /**\n     * Parses the (keyboard) event and returns a String that represents its key\n     * Can be used like Foundation.parseKey(event) === Foundation.keys.SPACE\n     * @param {Event} event - the event generated by the event handler\n     * @return String key - String that represents the key pressed\n     */\n    parseKey: function parseKey(event) {\n      var key = keyCodes[event.which || event.keyCode] || String.fromCharCode(event.which).toUpperCase();\n\n      // Remove un-printable characters, e.g. for `fromCharCode` calls for CTRL only events\n      key = key.replace(/\\W+/, '');\n\n      if (event.shiftKey) key = 'SHIFT_' + key;\n      if (event.ctrlKey) key = 'CTRL_' + key;\n      if (event.altKey) key = 'ALT_' + key;\n\n      // Remove trailing underscore, in case only modifiers were used (e.g. only `CTRL_ALT`)\n      key = key.replace(/_$/, '');\n\n      return key;\n    },\n\n\n    /**\n     * Handles the given (keyboard) event\n     * @param {Event} event - the event generated by the event handler\n     * @param {String} component - Foundation component's name, e.g. Slider or Reveal\n     * @param {Objects} functions - collection of functions that are to be executed\n     */\n    handleKey: function handleKey(event, component, functions) {\n      var commandList = commands[component],\n          keyCode = this.parseKey(event),\n          cmds,\n          command,\n          fn;\n\n      if (!commandList) return console.warn('Component not defined!');\n\n      if (typeof commandList.ltr === 'undefined') {\n        // this component does not differentiate between ltr and rtl\n        cmds = commandList; // use plain list\n      } else {\n        // merge ltr and rtl: if document is rtl, rtl overwrites ltr and vice versa\n        if (Foundation.rtl()) cmds = $.extend({}, commandList.ltr, commandList.rtl);else cmds = $.extend({}, commandList.rtl, commandList.ltr);\n      }\n      command = cmds[keyCode];\n\n      fn = functions[command];\n      if (fn && typeof fn === 'function') {\n        // execute function  if exists\n        var returnValue = fn.apply();\n        if (functions.handled || typeof functions.handled === 'function') {\n          // execute function when event was handled\n          functions.handled(returnValue);\n        }\n      } else {\n        if (functions.unhandled || typeof functions.unhandled === 'function') {\n          // execute function when event was not handled\n          functions.unhandled();\n        }\n      }\n    },\n\n\n    /**\n     * Finds all focusable elements within the given `$element`\n     * @param {jQuery} $element - jQuery object to search within\n     * @return {jQuery} $focusable - all focusable elements within `$element`\n     */\n    findFocusable: function findFocusable($element) {\n      if (!$element) {\n        return false;\n      }\n      return $element.find('a[href], area[href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), button:not([disabled]), iframe, object, embed, *[tabindex], *[contenteditable]').filter(function () {\n        if (!$(this).is(':visible') || $(this).attr('tabindex') < 0) {\n          return false;\n        } //only have visible elements and those that have a tabindex greater or equal 0\n        return true;\n      });\n    },\n\n\n    /**\n     * Returns the component name name\n     * @param {Object} component - Foundation component, e.g. Slider or Reveal\n     * @return String componentName\n     */\n\n    register: function register(componentName, cmds) {\n      commands[componentName] = cmds;\n    },\n\n\n    /**\n     * Traps the focus in the given element.\n     * @param  {jQuery} $element  jQuery object to trap the foucs into.\n     */\n    trapFocus: function trapFocus($element) {\n      var $focusable = Foundation.Keyboard.findFocusable($element),\n          $firstFocusable = $focusable.eq(0),\n          $lastFocusable = $focusable.eq(-1);\n\n      $element.on('keydown.zf.trapfocus', function (event) {\n        if (event.target === $lastFocusable[0] && Foundation.Keyboard.parseKey(event) === 'TAB') {\n          event.preventDefault();\n          $firstFocusable.focus();\n        } else if (event.target === $firstFocusable[0] && Foundation.Keyboard.parseKey(event) === 'SHIFT_TAB') {\n          event.preventDefault();\n          $lastFocusable.focus();\n        }\n      });\n    },\n\n    /**\n     * Releases the trapped focus from the given element.\n     * @param  {jQuery} $element  jQuery object to release the focus for.\n     */\n    releaseFocus: function releaseFocus($element) {\n      $element.off('keydown.zf.trapfocus');\n    }\n  };\n\n  /*\n   * Constants for easier comparing.\n   * Can be used like Foundation.parseKey(event) === Foundation.keys.SPACE\n   */\n  function getKeyCodes(kcs) {\n    var k = {};\n    for (var kc in kcs) {\n      k[kcs[kc]] = kcs[kc];\n    }return k;\n  }\n\n  Foundation.Keyboard = Keyboard;\n}(jQuery);\n'use strict';\n\n!function ($) {\n\n  Foundation.Box = {\n    ImNotTouchingYou: ImNotTouchingYou,\n    GetDimensions: GetDimensions,\n    GetOffsets: GetOffsets\n  };\n\n  /**\n   * Compares the dimensions of an element to a container and determines collision events with container.\n   * @function\n   * @param {jQuery} element - jQuery object to test for collisions.\n   * @param {jQuery} parent - jQuery object to use as bounding container.\n   * @param {Boolean} lrOnly - set to true to check left and right values only.\n   * @param {Boolean} tbOnly - set to true to check top and bottom values only.\n   * @default if no parent object passed, detects collisions with `window`.\n   * @returns {Boolean} - true if collision free, false if a collision in any direction.\n   */\n  function ImNotTouchingYou(element, parent, lrOnly, tbOnly) {\n    var eleDims = GetDimensions(element),\n        top,\n        bottom,\n        left,\n        right;\n\n    if (parent) {\n      var parDims = GetDimensions(parent);\n\n      bottom = eleDims.offset.top + eleDims.height <= parDims.height + parDims.offset.top;\n      top = eleDims.offset.top >= parDims.offset.top;\n      left = eleDims.offset.left >= parDims.offset.left;\n      right = eleDims.offset.left + eleDims.width <= parDims.width + parDims.offset.left;\n    } else {\n      bottom = eleDims.offset.top + eleDims.height <= eleDims.windowDims.height + eleDims.windowDims.offset.top;\n      top = eleDims.offset.top >= eleDims.windowDims.offset.top;\n      left = eleDims.offset.left >= eleDims.windowDims.offset.left;\n      right = eleDims.offset.left + eleDims.width <= eleDims.windowDims.width;\n    }\n\n    var allDirs = [bottom, top, left, right];\n\n    if (lrOnly) {\n      return left === right === true;\n    }\n\n    if (tbOnly) {\n      return top === bottom === true;\n    }\n\n    return allDirs.indexOf(false) === -1;\n  };\n\n  /**\n   * Uses native methods to return an object of dimension values.\n   * @function\n   * @param {jQuery || HTML} element - jQuery object or DOM element for which to get the dimensions. Can be any element other that document or window.\n   * @returns {Object} - nested object of integer pixel values\n   * TODO - if element is window, return only those values.\n   */\n  function GetDimensions(elem, test) {\n    elem = elem.length ? elem[0] : elem;\n\n    if (elem === window || elem === document) {\n      throw new Error(\"I'm sorry, Dave. I'm afraid I can't do that.\");\n    }\n\n    var rect = elem.getBoundingClientRect(),\n        parRect = elem.parentNode.getBoundingClientRect(),\n        winRect = document.body.getBoundingClientRect(),\n        winY = window.pageYOffset,\n        winX = window.pageXOffset;\n\n    return {\n      width: rect.width,\n      height: rect.height,\n      offset: {\n        top: rect.top + winY,\n        left: rect.left + winX\n      },\n      parentDims: {\n        width: parRect.width,\n        height: parRect.height,\n        offset: {\n          top: parRect.top + winY,\n          left: parRect.left + winX\n        }\n      },\n      windowDims: {\n        width: winRect.width,\n        height: winRect.height,\n        offset: {\n          top: winY,\n          left: winX\n        }\n      }\n    };\n  }\n\n  /**\n   * Returns an object of top and left integer pixel values for dynamically rendered elements,\n   * such as: Tooltip, Reveal, and Dropdown\n   * @function\n   * @param {jQuery} element - jQuery object for the element being positioned.\n   * @param {jQuery} anchor - jQuery object for the element's anchor point.\n   * @param {String} position - a string relating to the desired position of the element, relative to it's anchor\n   * @param {Number} vOffset - integer pixel value of desired vertical separation between anchor and element.\n   * @param {Number} hOffset - integer pixel value of desired horizontal separation between anchor and element.\n   * @param {Boolean} isOverflow - if a collision event is detected, sets to true to default the element to full width - any desired offset.\n   * TODO alter/rewrite to work with `em` values as well/instead of pixels\n   */\n  function GetOffsets(element, anchor, position, vOffset, hOffset, isOverflow) {\n    var $eleDims = GetDimensions(element),\n        $anchorDims = anchor ? GetDimensions(anchor) : null;\n\n    switch (position) {\n      case 'top':\n        return {\n          left: Foundation.rtl() ? $anchorDims.offset.left - $eleDims.width + $anchorDims.width : $anchorDims.offset.left,\n          top: $anchorDims.offset.top - ($eleDims.height + vOffset)\n        };\n        break;\n      case 'left':\n        return {\n          left: $anchorDims.offset.left - ($eleDims.width + hOffset),\n          top: $anchorDims.offset.top\n        };\n        break;\n      case 'right':\n        return {\n          left: $anchorDims.offset.left + $anchorDims.width + hOffset,\n          top: $anchorDims.offset.top\n        };\n        break;\n      case 'center top':\n        return {\n          left: $anchorDims.offset.left + $anchorDims.width / 2 - $eleDims.width / 2,\n          top: $anchorDims.offset.top - ($eleDims.height + vOffset)\n        };\n        break;\n      case 'center bottom':\n        return {\n          left: isOverflow ? hOffset : $anchorDims.offset.left + $anchorDims.width / 2 - $eleDims.width / 2,\n          top: $anchorDims.offset.top + $anchorDims.height + vOffset\n        };\n        break;\n      case 'center left':\n        return {\n          left: $anchorDims.offset.left - ($eleDims.width + hOffset),\n          top: $anchorDims.offset.top + $anchorDims.height / 2 - $eleDims.height / 2\n        };\n        break;\n      case 'center right':\n        return {\n          left: $anchorDims.offset.left + $anchorDims.width + hOffset + 1,\n          top: $anchorDims.offset.top + $anchorDims.height / 2 - $eleDims.height / 2\n        };\n        break;\n      case 'center':\n        return {\n          left: $eleDims.windowDims.offset.left + $eleDims.windowDims.width / 2 - $eleDims.width / 2,\n          top: $eleDims.windowDims.offset.top + $eleDims.windowDims.height / 2 - $eleDims.height / 2\n        };\n        break;\n      case 'reveal':\n        return {\n          left: ($eleDims.windowDims.width - $eleDims.width) / 2,\n          top: $eleDims.windowDims.offset.top + vOffset\n        };\n      case 'reveal full':\n        return {\n          left: $eleDims.windowDims.offset.left,\n          top: $eleDims.windowDims.offset.top\n        };\n        break;\n      case 'left bottom':\n        return {\n          left: $anchorDims.offset.left,\n          top: $anchorDims.offset.top + $anchorDims.height + vOffset\n        };\n        break;\n      case 'right bottom':\n        return {\n          left: $anchorDims.offset.left + $anchorDims.width + hOffset - $eleDims.width,\n          top: $anchorDims.offset.top + $anchorDims.height + vOffset\n        };\n        break;\n      default:\n        return {\n          left: Foundation.rtl() ? $anchorDims.offset.left - $eleDims.width + $anchorDims.width : $anchorDims.offset.left + hOffset,\n          top: $anchorDims.offset.top + $anchorDims.height + vOffset\n        };\n    }\n  }\n}(jQuery);\n'use strict';\n\n!function ($) {\n\n  var Nest = {\n    Feather: function Feather(menu) {\n      var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'zf';\n\n      menu.attr('role', 'menubar');\n\n      var items = menu.find('li').attr({ 'role': 'menuitem' }),\n          subMenuClass = 'is-' + type + '-submenu',\n          subItemClass = subMenuClass + '-item',\n          hasSubClass = 'is-' + type + '-submenu-parent';\n\n      items.each(function () {\n        var $item = $(this),\n            $sub = $item.children('ul');\n\n        if ($sub.length) {\n          $item.addClass(hasSubClass).attr({\n            'aria-haspopup': true,\n            'aria-label': $item.children('a:first').text()\n          });\n          // Note:  Drilldowns behave differently in how they hide, and so need\n          // additional attributes.  We should look if this possibly over-generalized\n          // utility (Nest) is appropriate when we rework menus in 6.4\n          if (type === 'drilldown') {\n            $item.attr({ 'aria-expanded': false });\n          }\n\n          $sub.addClass('submenu ' + subMenuClass).attr({\n            'data-submenu': '',\n            'role': 'menu'\n          });\n          if (type === 'drilldown') {\n            $sub.attr({ 'aria-hidden': true });\n          }\n        }\n\n        if ($item.parent('[data-submenu]').length) {\n          $item.addClass('is-submenu-item ' + subItemClass);\n        }\n      });\n\n      return;\n    },\n    Burn: function Burn(menu, type) {\n      var //items = menu.find('li'),\n      subMenuClass = 'is-' + type + '-submenu',\n          subItemClass = subMenuClass + '-item',\n          hasSubClass = 'is-' + type + '-submenu-parent';\n\n      menu.find('>li, .menu, .menu > li').removeClass(subMenuClass + ' ' + subItemClass + ' ' + hasSubClass + ' is-submenu-item submenu is-active').removeAttr('data-submenu').css('display', '');\n\n      // console.log(      menu.find('.' + subMenuClass + ', .' + subItemClass + ', .has-submenu, .is-submenu-item, .submenu, [data-submenu]')\n      //           .removeClass(subMenuClass + ' ' + subItemClass + ' has-submenu is-submenu-item submenu')\n      //           .removeAttr('data-submenu'));\n      // items.each(function(){\n      //   var $item = $(this),\n      //       $sub = $item.children('ul');\n      //   if($item.parent('[data-submenu]').length){\n      //     $item.removeClass('is-submenu-item ' + subItemClass);\n      //   }\n      //   if($sub.length){\n      //     $item.removeClass('has-submenu');\n      //     $sub.removeClass('submenu ' + subMenuClass).removeAttr('data-submenu');\n      //   }\n      // });\n    }\n  };\n\n  Foundation.Nest = Nest;\n}(jQuery);\n'use strict';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n!function ($) {\n\n  // Default set of media queries\n  var defaultQueries = {\n    'default': 'only screen',\n    landscape: 'only screen and (orientation: landscape)',\n    portrait: 'only screen and (orientation: portrait)',\n    retina: 'only screen and (-webkit-min-device-pixel-ratio: 2),' + 'only screen and (min--moz-device-pixel-ratio: 2),' + 'only screen and (-o-min-device-pixel-ratio: 2/1),' + 'only screen and (min-device-pixel-ratio: 2),' + 'only screen and (min-resolution: 192dpi),' + 'only screen and (min-resolution: 2dppx)'\n  };\n\n  var MediaQuery = {\n    queries: [],\n\n    current: '',\n\n    /**\n     * Initializes the media query helper, by extracting the breakpoint list from the CSS and activating the breakpoint watcher.\n     * @function\n     * @private\n     */\n    _init: function _init() {\n      var self = this;\n      var extractedStyles = $('.foundation-mq').css('font-family');\n      var namedQueries;\n\n      namedQueries = parseStyleToObject(extractedStyles);\n\n      for (var key in namedQueries) {\n        if (namedQueries.hasOwnProperty(key)) {\n          self.queries.push({\n            name: key,\n            value: 'only screen and (min-width: ' + namedQueries[key] + ')'\n          });\n        }\n      }\n\n      this.current = this._getCurrentSize();\n\n      this._watcher();\n    },\n\n\n    /**\n     * Checks if the screen is at least as wide as a breakpoint.\n     * @function\n     * @param {String} size - Name of the breakpoint to check.\n     * @returns {Boolean} `true` if the breakpoint matches, `false` if it's smaller.\n     */\n    atLeast: function atLeast(size) {\n      var query = this.get(size);\n\n      if (query) {\n        return window.matchMedia(query).matches;\n      }\n\n      return false;\n    },\n\n\n    /**\n     * Checks if the screen matches to a breakpoint.\n     * @function\n     * @param {String} size - Name of the breakpoint to check, either 'small only' or 'small'. Omitting 'only' falls back to using atLeast() method.\n     * @returns {Boolean} `true` if the breakpoint matches, `false` if it does not.\n     */\n    is: function is(size) {\n      size = size.trim().split(' ');\n      if (size.length > 1 && size[1] === 'only') {\n        if (size[0] === this._getCurrentSize()) return true;\n      } else {\n        return this.atLeast(size[0]);\n      }\n      return false;\n    },\n\n\n    /**\n     * Gets the media query of a breakpoint.\n     * @function\n     * @param {String} size - Name of the breakpoint to get.\n     * @returns {String|null} - The media query of the breakpoint, or `null` if the breakpoint doesn't exist.\n     */\n    get: function get(size) {\n      for (var i in this.queries) {\n        if (this.queries.hasOwnProperty(i)) {\n          var query = this.queries[i];\n          if (size === query.name) return query.value;\n        }\n      }\n\n      return null;\n    },\n\n\n    /**\n     * Gets the current breakpoint name by testing every breakpoint and returning the last one to match (the biggest one).\n     * @function\n     * @private\n     * @returns {String} Name of the current breakpoint.\n     */\n    _getCurrentSize: function _getCurrentSize() {\n      var matched;\n\n      for (var i = 0; i < this.queries.length; i++) {\n        var query = this.queries[i];\n\n        if (window.matchMedia(query.value).matches) {\n          matched = query;\n        }\n      }\n\n      if ((typeof matched === 'undefined' ? 'undefined' : _typeof(matched)) === 'object') {\n        return matched.name;\n      } else {\n        return matched;\n      }\n    },\n\n\n    /**\n     * Activates the breakpoint watcher, which fires an event on the window whenever the breakpoint changes.\n     * @function\n     * @private\n     */\n    _watcher: function _watcher() {\n      var _this = this;\n\n      $(window).on('resize.zf.mediaquery', function () {\n        var newSize = _this._getCurrentSize(),\n            currentSize = _this.current;\n\n        if (newSize !== currentSize) {\n          // Change the current media query\n          _this.current = newSize;\n\n          // Broadcast the media query change on the window\n          $(window).trigger('changed.zf.mediaquery', [newSize, currentSize]);\n        }\n      });\n    }\n  };\n\n  Foundation.MediaQuery = MediaQuery;\n\n  // matchMedia() polyfill - Test a CSS media type/query in JS.\n  // Authors & copyright (c) 2012: Scott Jehl, Paul Irish, Nicholas Zakas, David Knight. Dual MIT/BSD license\n  window.matchMedia || (window.matchMedia = function () {\n    'use strict';\n\n    // For browsers that support matchMedium api such as IE 9 and webkit\n\n    var styleMedia = window.styleMedia || window.media;\n\n    // For those that don't support matchMedium\n    if (!styleMedia) {\n      var style = document.createElement('style'),\n          script = document.getElementsByTagName('script')[0],\n          info = null;\n\n      style.type = 'text/css';\n      style.id = 'matchmediajs-test';\n\n      script && script.parentNode && script.parentNode.insertBefore(style, script);\n\n      // 'style.currentStyle' is used by IE <= 8 and 'window.getComputedStyle' for all other browsers\n      info = 'getComputedStyle' in window && window.getComputedStyle(style, null) || style.currentStyle;\n\n      styleMedia = {\n        matchMedium: function matchMedium(media) {\n          var text = '@media ' + media + '{ #matchmediajs-test { width: 1px; } }';\n\n          // 'style.styleSheet' is used by IE <= 8 and 'style.textContent' for all other browsers\n          if (style.styleSheet) {\n            style.styleSheet.cssText = text;\n          } else {\n            style.textContent = text;\n          }\n\n          // Test if media query is true or false\n          return info.width === '1px';\n        }\n      };\n    }\n\n    return function (media) {\n      return {\n        matches: styleMedia.matchMedium(media || 'all'),\n        media: media || 'all'\n      };\n    };\n  }());\n\n  // Thank you: https://github.com/sindresorhus/query-string\n  function parseStyleToObject(str) {\n    var styleObject = {};\n\n    if (typeof str !== 'string') {\n      return styleObject;\n    }\n\n    str = str.trim().slice(1, -1); // browsers re-quote string style values\n\n    if (!str) {\n      return styleObject;\n    }\n\n    styleObject = str.split('&').reduce(function (ret, param) {\n      var parts = param.replace(/\\+/g, ' ').split('=');\n      var key = parts[0];\n      var val = parts[1];\n      key = decodeURIComponent(key);\n\n      // missing `=` should be `null`:\n      // http://w3.org/TR/2012/WD-url-20120524/#collect-url-parameters\n      val = val === undefined ? null : decodeURIComponent(val);\n\n      if (!ret.hasOwnProperty(key)) {\n        ret[key] = val;\n      } else if (Array.isArray(ret[key])) {\n        ret[key].push(val);\n      } else {\n        ret[key] = [ret[key], val];\n      }\n      return ret;\n    }, {});\n\n    return styleObject;\n  }\n\n  Foundation.MediaQuery = MediaQuery;\n}(jQuery);\n'use strict';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n!function ($) {\n\n  var MutationObserver = function () {\n    var prefixes = ['WebKit', 'Moz', 'O', 'Ms', ''];\n    for (var i = 0; i < prefixes.length; i++) {\n      if (prefixes[i] + 'MutationObserver' in window) {\n        return window[prefixes[i] + 'MutationObserver'];\n      }\n    }\n    return false;\n  }();\n\n  var triggers = function triggers(el, type) {\n    el.data(type).split(' ').forEach(function (id) {\n      $('#' + id)[type === 'close' ? 'trigger' : 'triggerHandler'](type + '.zf.trigger', [el]);\n    });\n  };\n  // Elements with [data-open] will reveal a plugin that supports it when clicked.\n  $(document).on('click.zf.trigger', '[data-open]', function () {\n    triggers($(this), 'open');\n  });\n\n  // Elements with [data-close] will close a plugin that supports it when clicked.\n  // If used without a value on [data-close], the event will bubble, allowing it to close a parent component.\n  $(document).on('click.zf.trigger', '[data-close]', function () {\n    var id = $(this).data('close');\n    if (id) {\n      triggers($(this), 'close');\n    } else {\n      $(this).trigger('close.zf.trigger');\n    }\n  });\n\n  // Elements with [data-toggle] will toggle a plugin that supports it when clicked.\n  $(document).on('click.zf.trigger', '[data-toggle]', function () {\n    var id = $(this).data('toggle');\n    if (id) {\n      triggers($(this), 'toggle');\n    } else {\n      $(this).trigger('toggle.zf.trigger');\n    }\n  });\n\n  // Elements with [data-closable] will respond to close.zf.trigger events.\n  $(document).on('close.zf.trigger', '[data-closable]', function (e) {\n    e.stopPropagation();\n    var animation = $(this).data('closable');\n\n    if (animation !== '') {\n      Foundation.Motion.animateOut($(this), animation, function () {\n        $(this).trigger('closed.zf');\n      });\n    } else {\n      $(this).fadeOut().trigger('closed.zf');\n    }\n  });\n\n  $(document).on('focus.zf.trigger blur.zf.trigger', '[data-toggle-focus]', function () {\n    var id = $(this).data('toggle-focus');\n    $('#' + id).triggerHandler('toggle.zf.trigger', [$(this)]);\n  });\n\n  /**\n  * Fires once after all other scripts have loaded\n  * @function\n  * @private\n  */\n  $(window).on('load', function () {\n    checkListeners();\n  });\n\n  function checkListeners() {\n    eventsListener();\n    resizeListener();\n    scrollListener();\n    closemeListener();\n  }\n\n  //******** only fires this function once on load, if there's something to watch ********\n  function closemeListener(pluginName) {\n    var yetiBoxes = $('[data-yeti-box]'),\n        plugNames = ['dropdown', 'tooltip', 'reveal'];\n\n    if (pluginName) {\n      if (typeof pluginName === 'string') {\n        plugNames.push(pluginName);\n      } else if ((typeof pluginName === 'undefined' ? 'undefined' : _typeof(pluginName)) === 'object' && typeof pluginName[0] === 'string') {\n        plugNames.concat(pluginName);\n      } else {\n        console.error('Plugin names must be strings');\n      }\n    }\n    if (yetiBoxes.length) {\n      var listeners = plugNames.map(function (name) {\n        return 'closeme.zf.' + name;\n      }).join(' ');\n\n      $(window).off(listeners).on(listeners, function (e, pluginId) {\n        var plugin = e.namespace.split('.')[0];\n        var plugins = $('[data-' + plugin + ']').not('[data-yeti-box=\"' + pluginId + '\"]');\n\n        plugins.each(function () {\n          var _this = $(this);\n\n          _this.triggerHandler('close.zf.trigger', [_this]);\n        });\n      });\n    }\n  }\n\n  function resizeListener(debounce) {\n    var timer = void 0,\n        $nodes = $('[data-resize]');\n    if ($nodes.length) {\n      $(window).off('resize.zf.trigger').on('resize.zf.trigger', function (e) {\n        if (timer) {\n          clearTimeout(timer);\n        }\n\n        timer = setTimeout(function () {\n\n          if (!MutationObserver) {\n            //fallback for IE 9\n            $nodes.each(function () {\n              $(this).triggerHandler('resizeme.zf.trigger');\n            });\n          }\n          //trigger all listening elements and signal a resize event\n          $nodes.attr('data-events', \"resize\");\n        }, debounce || 10); //default time to emit resize event\n      });\n    }\n  }\n\n  function scrollListener(debounce) {\n    var timer = void 0,\n        $nodes = $('[data-scroll]');\n    if ($nodes.length) {\n      $(window).off('scroll.zf.trigger').on('scroll.zf.trigger', function (e) {\n        if (timer) {\n          clearTimeout(timer);\n        }\n\n        timer = setTimeout(function () {\n\n          if (!MutationObserver) {\n            //fallback for IE 9\n            $nodes.each(function () {\n              $(this).triggerHandler('scrollme.zf.trigger');\n            });\n          }\n          //trigger all listening elements and signal a scroll event\n          $nodes.attr('data-events', \"scroll\");\n        }, debounce || 10); //default time to emit scroll event\n      });\n    }\n  }\n\n  function eventsListener() {\n    if (!MutationObserver) {\n      return false;\n    }\n    var nodes = document.querySelectorAll('[data-resize], [data-scroll], [data-mutate]');\n\n    //element callback\n    var listeningElementsMutation = function listeningElementsMutation(mutationRecordsList) {\n      var $target = $(mutationRecordsList[0].target);\n\n      //trigger the event handler for the element depending on type\n      switch (mutationRecordsList[0].type) {\n\n        case \"attributes\":\n          if ($target.attr(\"data-events\") === \"scroll\" && mutationRecordsList[0].attributeName === \"data-events\") {\n            $target.triggerHandler('scrollme.zf.trigger', [$target, window.pageYOffset]);\n          }\n          if ($target.attr(\"data-events\") === \"resize\" && mutationRecordsList[0].attributeName === \"data-events\") {\n            $target.triggerHandler('resizeme.zf.trigger', [$target]);\n          }\n          if (mutationRecordsList[0].attributeName === \"style\") {\n            $target.closest(\"[data-mutate]\").attr(\"data-events\", \"mutate\");\n            $target.closest(\"[data-mutate]\").triggerHandler('mutateme.zf.trigger', [$target.closest(\"[data-mutate]\")]);\n          }\n          break;\n\n        case \"childList\":\n          $target.closest(\"[data-mutate]\").attr(\"data-events\", \"mutate\");\n          $target.closest(\"[data-mutate]\").triggerHandler('mutateme.zf.trigger', [$target.closest(\"[data-mutate]\")]);\n          break;\n\n        default:\n          return false;\n        //nothing\n      }\n    };\n\n    if (nodes.length) {\n      //for each element that needs to listen for resizing, scrolling, or mutation add a single observer\n      for (var i = 0; i <= nodes.length - 1; i++) {\n        var elementObserver = new MutationObserver(listeningElementsMutation);\n        elementObserver.observe(nodes[i], { attributes: true, childList: true, characterData: false, subtree: true, attributeFilter: [\"data-events\", \"style\"] });\n      }\n    }\n  }\n\n  // ------------------------------------\n\n  // [PH]\n  // Foundation.CheckWatchers = checkWatchers;\n  Foundation.IHearYou = checkListeners;\n  // Foundation.ISeeYou = scrollListener;\n  // Foundation.IFeelYou = closemeListener;\n}(jQuery);\n'use strict';\n\n!function ($) {\n\n  /**\n   * Motion module.\n   * @module foundation.motion\n   */\n\n  var initClasses = ['mui-enter', 'mui-leave'];\n  var activeClasses = ['mui-enter-active', 'mui-leave-active'];\n\n  var Motion = {\n    animateIn: function animateIn(element, animation, cb) {\n      animate(true, element, animation, cb);\n    },\n\n    animateOut: function animateOut(element, animation, cb) {\n      animate(false, element, animation, cb);\n    }\n  };\n\n  function Move(duration, elem, fn) {\n    var anim,\n        prog,\n        start = null;\n    // console.log('called');\n\n    if (duration === 0) {\n      fn.apply(elem);\n      elem.trigger('finished.zf.animate', [elem]).triggerHandler('finished.zf.animate', [elem]);\n      return;\n    }\n\n    function move(ts) {\n      if (!start) start = ts;\n      // console.log(start, ts);\n      prog = ts - start;\n      fn.apply(elem);\n\n      if (prog < duration) {\n        anim = window.requestAnimationFrame(move, elem);\n      } else {\n        window.cancelAnimationFrame(anim);\n        elem.trigger('finished.zf.animate', [elem]).triggerHandler('finished.zf.animate', [elem]);\n      }\n    }\n    anim = window.requestAnimationFrame(move);\n  }\n\n  /**\n   * Animates an element in or out using a CSS transition class.\n   * @function\n   * @private\n   * @param {Boolean} isIn - Defines if the animation is in or out.\n   * @param {Object} element - jQuery or HTML object to animate.\n   * @param {String} animation - CSS class to use.\n   * @param {Function} cb - Callback to run when animation is finished.\n   */\n  function animate(isIn, element, animation, cb) {\n    element = $(element).eq(0);\n\n    if (!element.length) return;\n\n    var initClass = isIn ? initClasses[0] : initClasses[1];\n    var activeClass = isIn ? activeClasses[0] : activeClasses[1];\n\n    // Set up the animation\n    reset();\n\n    element.addClass(animation).css('transition', 'none');\n\n    requestAnimationFrame(function () {\n      element.addClass(initClass);\n      if (isIn) element.show();\n    });\n\n    // Start the animation\n    requestAnimationFrame(function () {\n      element[0].offsetWidth;\n      element.css('transition', '').addClass(activeClass);\n    });\n\n    // Clean up the animation when it finishes\n    element.one(Foundation.transitionend(element), finish);\n\n    // Hides the element (for out animations), resets the element, and runs a callback\n    function finish() {\n      if (!isIn) element.hide();\n      reset();\n      if (cb) cb.apply(element);\n    }\n\n    // Resets transitions and removes motion-specific classes\n    function reset() {\n      element[0].style.transitionDuration = 0;\n      element.removeClass(initClass + ' ' + activeClass + ' ' + animation);\n    }\n  }\n\n  Foundation.Move = Move;\n  Foundation.Motion = Motion;\n}(jQuery);\n'use strict';\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n!function ($) {\n\n  /**\n   * DropdownMenu module.\n   * @module foundation.dropdown-menu\n   * @requires foundation.util.keyboard\n   * @requires foundation.util.box\n   * @requires foundation.util.nest\n   */\n\n  var DropdownMenu = function () {\n    /**\n     * Creates a new instance of DropdownMenu.\n     * @class\n     * @fires DropdownMenu#init\n     * @param {jQuery} element - jQuery object to make into a dropdown menu.\n     * @param {Object} options - Overrides to the default plugin settings.\n     */\n    function DropdownMenu(element, options) {\n      _classCallCheck(this, DropdownMenu);\n\n      this.$element = element;\n      this.options = $.extend({}, DropdownMenu.defaults, this.$element.data(), options);\n\n      Foundation.Nest.Feather(this.$element, 'dropdown');\n      this._init();\n\n      Foundation.registerPlugin(this, 'DropdownMenu');\n      Foundation.Keyboard.register('DropdownMenu', {\n        'ENTER': 'open',\n        'SPACE': 'open',\n        'ARROW_RIGHT': 'next',\n        'ARROW_UP': 'up',\n        'ARROW_DOWN': 'down',\n        'ARROW_LEFT': 'previous',\n        'ESCAPE': 'close'\n      });\n    }\n\n    /**\n     * Initializes the plugin, and calls _prepareMenu\n     * @private\n     * @function\n     */\n\n\n    _createClass(DropdownMenu, [{\n      key: '_init',\n      value: function _init() {\n        var subs = this.$element.find('li.is-dropdown-submenu-parent');\n        this.$element.children('.is-dropdown-submenu-parent').children('.is-dropdown-submenu').addClass('first-sub');\n\n        this.$menuItems = this.$element.find('[role=\"menuitem\"]');\n        this.$tabs = this.$element.children('[role=\"menuitem\"]');\n        this.$tabs.find('ul.is-dropdown-submenu').addClass(this.options.verticalClass);\n\n        if (this.$element.hasClass(this.options.rightClass) || this.options.alignment === 'right' || Foundation.rtl() || this.$element.parents('.top-bar-right').is('*')) {\n          this.options.alignment = 'right';\n          subs.addClass('opens-left');\n        } else {\n          subs.addClass('opens-right');\n        }\n        this.changed = false;\n        this._events();\n      }\n    }, {\n      key: '_isVertical',\n      value: function _isVertical() {\n        return this.$tabs.css('display') === 'block';\n      }\n\n      /**\n       * Adds event listeners to elements within the menu\n       * @private\n       * @function\n       */\n\n    }, {\n      key: '_events',\n      value: function _events() {\n        var _this = this,\n            hasTouch = 'ontouchstart' in window || typeof window.ontouchstart !== 'undefined',\n            parClass = 'is-dropdown-submenu-parent';\n\n        // used for onClick and in the keyboard handlers\n        var handleClickFn = function handleClickFn(e) {\n          var $elem = $(e.target).parentsUntil('ul', '.' + parClass),\n              hasSub = $elem.hasClass(parClass),\n              hasClicked = $elem.attr('data-is-click') === 'true',\n              $sub = $elem.children('.is-dropdown-submenu');\n\n          if (hasSub) {\n            if (hasClicked) {\n              if (!_this.options.closeOnClick || !_this.options.clickOpen && !hasTouch || _this.options.forceFollow && hasTouch) {\n                return;\n              } else {\n                e.stopImmediatePropagation();\n                e.preventDefault();\n                _this._hide($elem);\n              }\n            } else {\n              e.preventDefault();\n              e.stopImmediatePropagation();\n              _this._show($sub);\n              $elem.add($elem.parentsUntil(_this.$element, '.' + parClass)).attr('data-is-click', true);\n            }\n          }\n        };\n\n        if (this.options.clickOpen || hasTouch) {\n          this.$menuItems.on('click.zf.dropdownmenu touchstart.zf.dropdownmenu', handleClickFn);\n        }\n\n        // Handle Leaf element Clicks\n        if (_this.options.closeOnClickInside) {\n          this.$menuItems.on('click.zf.dropdownmenu', function (e) {\n            var $elem = $(this),\n                hasSub = $elem.hasClass(parClass);\n            if (!hasSub) {\n              _this._hide();\n            }\n          });\n        }\n\n        if (!this.options.disableHover) {\n          this.$menuItems.on('mouseenter.zf.dropdownmenu', function (e) {\n            var $elem = $(this),\n                hasSub = $elem.hasClass(parClass);\n\n            if (hasSub) {\n              clearTimeout($elem.data('_delay'));\n              $elem.data('_delay', setTimeout(function () {\n                _this._show($elem.children('.is-dropdown-submenu'));\n              }, _this.options.hoverDelay));\n            }\n          }).on('mouseleave.zf.dropdownmenu', function (e) {\n            var $elem = $(this),\n                hasSub = $elem.hasClass(parClass);\n            if (hasSub && _this.options.autoclose) {\n              if ($elem.attr('data-is-click') === 'true' && _this.options.clickOpen) {\n                return false;\n              }\n\n              clearTimeout($elem.data('_delay'));\n              $elem.data('_delay', setTimeout(function () {\n                _this._hide($elem);\n              }, _this.options.closingTime));\n            }\n          });\n        }\n        this.$menuItems.on('keydown.zf.dropdownmenu', function (e) {\n          var $element = $(e.target).parentsUntil('ul', '[role=\"menuitem\"]'),\n              isTab = _this.$tabs.index($element) > -1,\n              $elements = isTab ? _this.$tabs : $element.siblings('li').add($element),\n              $prevElement,\n              $nextElement;\n\n          $elements.each(function (i) {\n            if ($(this).is($element)) {\n              $prevElement = $elements.eq(i - 1);\n              $nextElement = $elements.eq(i + 1);\n              return;\n            }\n          });\n\n          var nextSibling = function nextSibling() {\n            if (!$element.is(':last-child')) {\n              $nextElement.children('a:first').focus();\n              e.preventDefault();\n            }\n          },\n              prevSibling = function prevSibling() {\n            $prevElement.children('a:first').focus();\n            e.preventDefault();\n          },\n              openSub = function openSub() {\n            var $sub = $element.children('ul.is-dropdown-submenu');\n            if ($sub.length) {\n              _this._show($sub);\n              $element.find('li > a:first').focus();\n              e.preventDefault();\n            } else {\n              return;\n            }\n          },\n              closeSub = function closeSub() {\n            //if ($element.is(':first-child')) {\n            var close = $element.parent('ul').parent('li');\n            close.children('a:first').focus();\n            _this._hide(close);\n            e.preventDefault();\n            //}\n          };\n          var functions = {\n            open: openSub,\n            close: function close() {\n              _this._hide(_this.$element);\n              _this.$menuItems.find('a:first').focus(); // focus to first element\n              e.preventDefault();\n            },\n            handled: function handled() {\n              e.stopImmediatePropagation();\n            }\n          };\n\n          if (isTab) {\n            if (_this._isVertical()) {\n              // vertical menu\n              if (Foundation.rtl()) {\n                // right aligned\n                $.extend(functions, {\n                  down: nextSibling,\n                  up: prevSibling,\n                  next: closeSub,\n                  previous: openSub\n                });\n              } else {\n                // left aligned\n                $.extend(functions, {\n                  down: nextSibling,\n                  up: prevSibling,\n                  next: openSub,\n                  previous: closeSub\n                });\n              }\n            } else {\n              // horizontal menu\n              if (Foundation.rtl()) {\n                // right aligned\n                $.extend(functions, {\n                  next: prevSibling,\n                  previous: nextSibling,\n                  down: openSub,\n                  up: closeSub\n                });\n              } else {\n                // left aligned\n                $.extend(functions, {\n                  next: nextSibling,\n                  previous: prevSibling,\n                  down: openSub,\n                  up: closeSub\n                });\n              }\n            }\n          } else {\n            // not tabs -> one sub\n            if (Foundation.rtl()) {\n              // right aligned\n              $.extend(functions, {\n                next: closeSub,\n                previous: openSub,\n                down: nextSibling,\n                up: prevSibling\n              });\n            } else {\n              // left aligned\n              $.extend(functions, {\n                next: openSub,\n                previous: closeSub,\n                down: nextSibling,\n                up: prevSibling\n              });\n            }\n          }\n          Foundation.Keyboard.handleKey(e, 'DropdownMenu', functions);\n        });\n      }\n\n      /**\n       * Adds an event handler to the body to close any dropdowns on a click.\n       * @function\n       * @private\n       */\n\n    }, {\n      key: '_addBodyHandler',\n      value: function _addBodyHandler() {\n        var $body = $(document.body),\n            _this = this;\n        $body.off('mouseup.zf.dropdownmenu touchend.zf.dropdownmenu').on('mouseup.zf.dropdownmenu touchend.zf.dropdownmenu', function (e) {\n          var $link = _this.$element.find(e.target);\n          if ($link.length) {\n            return;\n          }\n\n          _this._hide();\n          $body.off('mouseup.zf.dropdownmenu touchend.zf.dropdownmenu');\n        });\n      }\n\n      /**\n       * Opens a dropdown pane, and checks for collisions first.\n       * @param {jQuery} $sub - ul element that is a submenu to show\n       * @function\n       * @private\n       * @fires DropdownMenu#show\n       */\n\n    }, {\n      key: '_show',\n      value: function _show($sub) {\n        var idx = this.$tabs.index(this.$tabs.filter(function (i, el) {\n          return $(el).find($sub).length > 0;\n        }));\n        var $sibs = $sub.parent('li.is-dropdown-submenu-parent').siblings('li.is-dropdown-submenu-parent');\n        this._hide($sibs, idx);\n        $sub.css('visibility', 'hidden').addClass('js-dropdown-active').parent('li.is-dropdown-submenu-parent').addClass('is-active');\n        var clear = Foundation.Box.ImNotTouchingYou($sub, null, true);\n        if (!clear) {\n          var oldClass = this.options.alignment === 'left' ? '-right' : '-left',\n              $parentLi = $sub.parent('.is-dropdown-submenu-parent');\n          $parentLi.removeClass('opens' + oldClass).addClass('opens-' + this.options.alignment);\n          clear = Foundation.Box.ImNotTouchingYou($sub, null, true);\n          if (!clear) {\n            $parentLi.removeClass('opens-' + this.options.alignment).addClass('opens-inner');\n          }\n          this.changed = true;\n        }\n        $sub.css('visibility', '');\n        if (this.options.closeOnClick) {\n          this._addBodyHandler();\n        }\n        /**\n         * Fires when the new dropdown pane is visible.\n         * @event DropdownMenu#show\n         */\n        this.$element.trigger('show.zf.dropdownmenu', [$sub]);\n      }\n\n      /**\n       * Hides a single, currently open dropdown pane, if passed a parameter, otherwise, hides everything.\n       * @function\n       * @param {jQuery} $elem - element with a submenu to hide\n       * @param {Number} idx - index of the $tabs collection to hide\n       * @private\n       */\n\n    }, {\n      key: '_hide',\n      value: function _hide($elem, idx) {\n        var $toClose;\n        if ($elem && $elem.length) {\n          $toClose = $elem;\n        } else if (idx !== undefined) {\n          $toClose = this.$tabs.not(function (i, el) {\n            return i === idx;\n          });\n        } else {\n          $toClose = this.$element;\n        }\n        var somethingToClose = $toClose.hasClass('is-active') || $toClose.find('.is-active').length > 0;\n\n        if (somethingToClose) {\n          $toClose.find('li.is-active').add($toClose).attr({\n            'data-is-click': false\n          }).removeClass('is-active');\n\n          $toClose.find('ul.js-dropdown-active').removeClass('js-dropdown-active');\n\n          if (this.changed || $toClose.find('opens-inner').length) {\n            var oldClass = this.options.alignment === 'left' ? 'right' : 'left';\n            $toClose.find('li.is-dropdown-submenu-parent').add($toClose).removeClass('opens-inner opens-' + this.options.alignment).addClass('opens-' + oldClass);\n            this.changed = false;\n          }\n          /**\n           * Fires when the open menus are closed.\n           * @event DropdownMenu#hide\n           */\n          this.$element.trigger('hide.zf.dropdownmenu', [$toClose]);\n        }\n      }\n\n      /**\n       * Destroys the plugin.\n       * @function\n       */\n\n    }, {\n      key: 'destroy',\n      value: function destroy() {\n        this.$menuItems.off('.zf.dropdownmenu').removeAttr('data-is-click').removeClass('is-right-arrow is-left-arrow is-down-arrow opens-right opens-left opens-inner');\n        $(document.body).off('.zf.dropdownmenu');\n        Foundation.Nest.Burn(this.$element, 'dropdown');\n        Foundation.unregisterPlugin(this);\n      }\n    }]);\n\n    return DropdownMenu;\n  }();\n\n  /**\n   * Default settings for plugin\n   */\n\n\n  DropdownMenu.defaults = {\n    /**\n     * Disallows hover events from opening submenus\n     * @option\n     * @type {boolean}\n     * @default false\n     */\n    disableHover: false,\n    /**\n     * Allow a submenu to automatically close on a mouseleave event, if not clicked open.\n     * @option\n     * @type {boolean}\n     * @default true\n     */\n    autoclose: true,\n    /**\n     * Amount of time to delay opening a submenu on hover event.\n     * @option\n     * @type {number}\n     * @default 50\n     */\n    hoverDelay: 50,\n    /**\n     * Allow a submenu to open/remain open on parent click event. Allows cursor to move away from menu.\n     * @option\n     * @type {boolean}\n     * @default false\n     */\n    clickOpen: false,\n    /**\n     * Amount of time to delay closing a submenu on a mouseleave event.\n     * @option\n     * @type {number}\n     * @default 500\n     */\n\n    closingTime: 500,\n    /**\n     * Position of the menu relative to what direction the submenus should open. Handled by JS. Can be `'left'` or `'right'`.\n     * @option\n     * @type {string}\n     * @default 'left'\n     */\n    alignment: 'left',\n    /**\n     * Allow clicks on the body to close any open submenus.\n     * @option\n     * @type {boolean}\n     * @default true\n     */\n    closeOnClick: true,\n    /**\n     * Allow clicks on leaf anchor links to close any open submenus.\n     * @option\n     * @type {boolean}\n     * @default true\n     */\n    closeOnClickInside: true,\n    /**\n     * Class applied to vertical oriented menus, Foundation default is `vertical`. Update this if using your own class.\n     * @option\n     * @type {string}\n     * @default 'vertical'\n     */\n    verticalClass: 'vertical',\n    /**\n     * Class applied to right-side oriented menus, Foundation default is `align-right`. Update this if using your own class.\n     * @option\n     * @type {string}\n     * @default 'align-right'\n     */\n    rightClass: 'align-right',\n    /**\n     * Boolean to force overide the clicking of links to perform default action, on second touch event for mobile.\n     * @option\n     * @type {boolean}\n     * @default true\n     */\n    forceFollow: true\n  };\n\n  // Window exports\n  Foundation.plugin(DropdownMenu, 'DropdownMenu');\n}(jQuery);\n'use strict';\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n!function ($) {\n\n  /**\n   * OffCanvas module.\n   * @module foundation.offcanvas\n   * @requires foundation.util.keyboard\n   * @requires foundation.util.mediaQuery\n   * @requires foundation.util.triggers\n   * @requires foundation.util.motion\n   */\n\n  var OffCanvas = function () {\n    /**\n     * Creates a new instance of an off-canvas wrapper.\n     * @class\n     * @fires OffCanvas#init\n     * @param {Object} element - jQuery object to initialize.\n     * @param {Object} options - Overrides to the default plugin settings.\n     */\n    function OffCanvas(element, options) {\n      _classCallCheck(this, OffCanvas);\n\n      this.$element = element;\n      this.options = $.extend({}, OffCanvas.defaults, this.$element.data(), options);\n      this.$lastTrigger = $();\n      this.$triggers = $();\n\n      this._init();\n      this._events();\n\n      Foundation.registerPlugin(this, 'OffCanvas');\n      Foundation.Keyboard.register('OffCanvas', {\n        'ESCAPE': 'close'\n      });\n    }\n\n    /**\n     * Initializes the off-canvas wrapper by adding the exit overlay (if needed).\n     * @function\n     * @private\n     */\n\n\n    _createClass(OffCanvas, [{\n      key: '_init',\n      value: function _init() {\n        var id = this.$element.attr('id');\n\n        this.$element.attr('aria-hidden', 'true');\n\n        this.$element.addClass('is-transition-' + this.options.transition);\n\n        // Find triggers that affect this element and add aria-expanded to them\n        this.$triggers = $(document).find('[data-open=\"' + id + '\"], [data-close=\"' + id + '\"], [data-toggle=\"' + id + '\"]').attr('aria-expanded', 'false').attr('aria-controls', id);\n\n        // Add an overlay over the content if necessary\n        if (this.options.contentOverlay === true) {\n          var overlay = document.createElement('div');\n          var overlayPosition = $(this.$element).css(\"position\") === 'fixed' ? 'is-overlay-fixed' : 'is-overlay-absolute';\n          overlay.setAttribute('class', 'js-off-canvas-overlay ' + overlayPosition);\n          this.$overlay = $(overlay);\n          if (overlayPosition === 'is-overlay-fixed') {\n            $('body').append(this.$overlay);\n          } else {\n            this.$element.siblings('[data-off-canvas-content]').append(this.$overlay);\n          }\n        }\n\n        this.options.isRevealed = this.options.isRevealed || new RegExp(this.options.revealClass, 'g').test(this.$element[0].className);\n\n        if (this.options.isRevealed === true) {\n          this.options.revealOn = this.options.revealOn || this.$element[0].className.match(/(reveal-for-medium|reveal-for-large)/g)[0].split('-')[2];\n          this._setMQChecker();\n        }\n        if (!this.options.transitionTime === true) {\n          this.options.transitionTime = parseFloat(window.getComputedStyle($('[data-off-canvas]')[0]).transitionDuration) * 1000;\n        }\n      }\n\n      /**\n       * Adds event handlers to the off-canvas wrapper and the exit overlay.\n       * @function\n       * @private\n       */\n\n    }, {\n      key: '_events',\n      value: function _events() {\n        this.$element.off('.zf.trigger .zf.offcanvas').on({\n          'open.zf.trigger': this.open.bind(this),\n          'close.zf.trigger': this.close.bind(this),\n          'toggle.zf.trigger': this.toggle.bind(this),\n          'keydown.zf.offcanvas': this._handleKeyboard.bind(this)\n        });\n\n        if (this.options.closeOnClick === true) {\n          var $target = this.options.contentOverlay ? this.$overlay : $('[data-off-canvas-content]');\n          $target.on({ 'click.zf.offcanvas': this.close.bind(this) });\n        }\n      }\n\n      /**\n       * Applies event listener for elements that will reveal at certain breakpoints.\n       * @private\n       */\n\n    }, {\n      key: '_setMQChecker',\n      value: function _setMQChecker() {\n        var _this = this;\n\n        $(window).on('changed.zf.mediaquery', function () {\n          if (Foundation.MediaQuery.atLeast(_this.options.revealOn)) {\n            _this.reveal(true);\n          } else {\n            _this.reveal(false);\n          }\n        }).one('load.zf.offcanvas', function () {\n          if (Foundation.MediaQuery.atLeast(_this.options.revealOn)) {\n            _this.reveal(true);\n          }\n        });\n      }\n\n      /**\n       * Handles the revealing/hiding the off-canvas at breakpoints, not the same as open.\n       * @param {Boolean} isRevealed - true if element should be revealed.\n       * @function\n       */\n\n    }, {\n      key: 'reveal',\n      value: function reveal(isRevealed) {\n        var $closer = this.$element.find('[data-close]');\n        if (isRevealed) {\n          this.close();\n          this.isRevealed = true;\n          this.$element.attr('aria-hidden', 'false');\n          this.$element.off('open.zf.trigger toggle.zf.trigger');\n          if ($closer.length) {\n            $closer.hide();\n          }\n        } else {\n          this.isRevealed = false;\n          this.$element.attr('aria-hidden', 'true');\n          this.$element.off('open.zf.trigger toggle.zf.trigger').on({\n            'open.zf.trigger': this.open.bind(this),\n            'toggle.zf.trigger': this.toggle.bind(this)\n          });\n          if ($closer.length) {\n            $closer.show();\n          }\n        }\n      }\n\n      /**\n       * Stops scrolling of the body when offcanvas is open on mobile Safari and other troublesome browsers.\n       * @private\n       */\n\n    }, {\n      key: '_stopScrolling',\n      value: function _stopScrolling(event) {\n        return false;\n      }\n\n      // Taken and adapted from http://stackoverflow.com/questions/16889447/prevent-full-page-scrolling-ios\n      // Only really works for y, not sure how to extend to x or if we need to.\n\n    }, {\n      key: '_recordScrollable',\n      value: function _recordScrollable(event) {\n        var elem = this; // called from event handler context with this as elem\n\n        // If the element is scrollable (content overflows), then...\n        if (elem.scrollHeight !== elem.clientHeight) {\n          // If we're at the top, scroll down one pixel to allow scrolling up\n          if (elem.scrollTop === 0) {\n            elem.scrollTop = 1;\n          }\n          // If we're at the bottom, scroll up one pixel to allow scrolling down\n          if (elem.scrollTop === elem.scrollHeight - elem.clientHeight) {\n            elem.scrollTop = elem.scrollHeight - elem.clientHeight - 1;\n          }\n        }\n        elem.allowUp = elem.scrollTop > 0;\n        elem.allowDown = elem.scrollTop < elem.scrollHeight - elem.clientHeight;\n        elem.lastY = event.originalEvent.pageY;\n      }\n    }, {\n      key: '_stopScrollPropagation',\n      value: function _stopScrollPropagation(event) {\n        var elem = this; // called from event handler context with this as elem\n        var up = event.pageY < elem.lastY;\n        var down = !up;\n        elem.lastY = event.pageY;\n\n        if (up && elem.allowUp || down && elem.allowDown) {\n          event.stopPropagation();\n        } else {\n          event.preventDefault();\n        }\n      }\n\n      /**\n       * Opens the off-canvas menu.\n       * @function\n       * @param {Object} event - Event object passed from listener.\n       * @param {jQuery} trigger - element that triggered the off-canvas to open.\n       * @fires OffCanvas#opened\n       */\n\n    }, {\n      key: 'open',\n      value: function open(event, trigger) {\n        if (this.$element.hasClass('is-open') || this.isRevealed) {\n          return;\n        }\n        var _this = this;\n\n        if (trigger) {\n          this.$lastTrigger = trigger;\n        }\n\n        if (this.options.forceTo === 'top') {\n          window.scrollTo(0, 0);\n        } else if (this.options.forceTo === 'bottom') {\n          window.scrollTo(0, document.body.scrollHeight);\n        }\n\n        /**\n         * Fires when the off-canvas menu opens.\n         * @event OffCanvas#opened\n         */\n        _this.$element.addClass('is-open');\n\n        this.$triggers.attr('aria-expanded', 'true');\n        this.$element.attr('aria-hidden', 'false').trigger('opened.zf.offcanvas');\n\n        // If `contentScroll` is set to false, add class and disable scrolling on touch devices.\n        if (this.options.contentScroll === false) {\n          $('body').addClass('is-off-canvas-open').on('touchmove', this._stopScrolling);\n          this.$element.on('touchstart', this._recordScrollable);\n          this.$element.on('touchmove', this._stopScrollPropagation);\n        }\n\n        if (this.options.contentOverlay === true) {\n          this.$overlay.addClass('is-visible');\n        }\n\n        if (this.options.closeOnClick === true && this.options.contentOverlay === true) {\n          this.$overlay.addClass('is-closable');\n        }\n\n        if (this.options.autoFocus === true) {\n          this.$element.one(Foundation.transitionend(this.$element), function () {\n            var canvasFocus = _this.$element.find('[data-autofocus]');\n            if (canvasFocus.length) {\n              canvasFocus.eq(0).focus();\n            } else {\n              _this.$element.find('a, button').eq(0).focus();\n            }\n          });\n        }\n\n        if (this.options.trapFocus === true) {\n          this.$element.siblings('[data-off-canvas-content]').attr('tabindex', '-1');\n          Foundation.Keyboard.trapFocus(this.$element);\n        }\n      }\n\n      /**\n       * Closes the off-canvas menu.\n       * @function\n       * @param {Function} cb - optional cb to fire after closure.\n       * @fires OffCanvas#closed\n       */\n\n    }, {\n      key: 'close',\n      value: function close(cb) {\n        if (!this.$element.hasClass('is-open') || this.isRevealed) {\n          return;\n        }\n\n        var _this = this;\n\n        _this.$element.removeClass('is-open');\n\n        this.$element.attr('aria-hidden', 'true')\n        /**\n         * Fires when the off-canvas menu opens.\n         * @event OffCanvas#closed\n         */\n        .trigger('closed.zf.offcanvas');\n\n        // If `contentScroll` is set to false, remove class and re-enable scrolling on touch devices.\n        if (this.options.contentScroll === false) {\n          $('body').removeClass('is-off-canvas-open').off('touchmove', this._stopScrolling);\n          this.$element.off('touchstart', this._recordScrollable);\n          this.$element.off('touchmove', this._stopScrollPropagation);\n        }\n\n        if (this.options.contentOverlay === true) {\n          this.$overlay.removeClass('is-visible');\n        }\n\n        if (this.options.closeOnClick === true && this.options.contentOverlay === true) {\n          this.$overlay.removeClass('is-closable');\n        }\n\n        this.$triggers.attr('aria-expanded', 'false');\n\n        if (this.options.trapFocus === true) {\n          this.$element.siblings('[data-off-canvas-content]').removeAttr('tabindex');\n          Foundation.Keyboard.releaseFocus(this.$element);\n        }\n      }\n\n      /**\n       * Toggles the off-canvas menu open or closed.\n       * @function\n       * @param {Object} event - Event object passed from listener.\n       * @param {jQuery} trigger - element that triggered the off-canvas to open.\n       */\n\n    }, {\n      key: 'toggle',\n      value: function toggle(event, trigger) {\n        if (this.$element.hasClass('is-open')) {\n          this.close(event, trigger);\n        } else {\n          this.open(event, trigger);\n        }\n      }\n\n      /**\n       * Handles keyboard input when detected. When the escape key is pressed, the off-canvas menu closes, and focus is restored to the element that opened the menu.\n       * @function\n       * @private\n       */\n\n    }, {\n      key: '_handleKeyboard',\n      value: function _handleKeyboard(e) {\n        var _this2 = this;\n\n        Foundation.Keyboard.handleKey(e, 'OffCanvas', {\n          close: function close() {\n            _this2.close();\n            _this2.$lastTrigger.focus();\n            return true;\n          },\n          handled: function handled() {\n            e.stopPropagation();\n            e.preventDefault();\n          }\n        });\n      }\n\n      /**\n       * Destroys the offcanvas plugin.\n       * @function\n       */\n\n    }, {\n      key: 'destroy',\n      value: function destroy() {\n        this.close();\n        this.$element.off('.zf.trigger .zf.offcanvas');\n        this.$overlay.off('.zf.offcanvas');\n\n        Foundation.unregisterPlugin(this);\n      }\n    }]);\n\n    return OffCanvas;\n  }();\n\n  OffCanvas.defaults = {\n    /**\n     * Allow the user to click outside of the menu to close it.\n     * @option\n     * @type {boolean}\n     * @default true\n     */\n    closeOnClick: true,\n\n    /**\n     * Adds an overlay on top of `[data-off-canvas-content]`.\n     * @option\n     * @type {boolean}\n     * @default true\n     */\n    contentOverlay: true,\n\n    /**\n     * Enable/disable scrolling of the main content when an off canvas panel is open.\n     * @option\n     * @type {boolean}\n     * @default true\n     */\n    contentScroll: true,\n\n    /**\n     * Amount of time in ms the open and close transition requires. If none selected, pulls from body style.\n     * @option\n     * @type {number}\n     * @default 0\n     */\n    transitionTime: 0,\n\n    /**\n     * Type of transition for the offcanvas menu. Options are 'push', 'detached' or 'slide'.\n     * @option\n     * @type {string}\n     * @default push\n     */\n    transition: 'push',\n\n    /**\n     * Force the page to scroll to top or bottom on open.\n     * @option\n     * @type {?string}\n     * @default null\n     */\n    forceTo: null,\n\n    /**\n     * Allow the offcanvas to remain open for certain breakpoints.\n     * @option\n     * @type {boolean}\n     * @default false\n     */\n    isRevealed: false,\n\n    /**\n     * Breakpoint at which to reveal. JS will use a RegExp to target standard classes, if changing classnames, pass your class with the `revealClass` option.\n     * @option\n     * @type {?string}\n     * @default null\n     */\n    revealOn: null,\n\n    /**\n     * Force focus to the offcanvas on open. If true, will focus the opening trigger on close.\n     * @option\n     * @type {boolean}\n     * @default true\n     */\n    autoFocus: true,\n\n    /**\n     * Class used to force an offcanvas to remain open. Foundation defaults for this are `reveal-for-large` & `reveal-for-medium`.\n     * @option\n     * @type {string}\n     * @default reveal-for-\n     * @todo improve the regex testing for this.\n     */\n    revealClass: 'reveal-for-',\n\n    /**\n     * Triggers optional focus trapping when opening an offcanvas. Sets tabindex of [data-off-canvas-content] to -1 for accessibility purposes.\n     * @option\n     * @type {boolean}\n     * @default false\n     */\n    trapFocus: false\n  };\n\n  // Window exports\n  Foundation.plugin(OffCanvas, 'OffCanvas');\n}(jQuery);\n\"use strict\";\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/*!\n * Chart.js\n * http://chartjs.org/\n * Version: 2.5.0\n *\n * Copyright 2017 Nick Downie\n * Released under the MIT license\n * https://github.com/chartjs/Chart.js/blob/master/LICENSE.md\n */\n(function (f) {\n\tif ((typeof exports === \"undefined\" ? \"undefined\" : _typeof(exports)) === \"object\" && typeof module !== \"undefined\") {\n\t\tmodule.exports = f();\n\t} else if (typeof define === \"function\" && define.amd) {\n\t\tdefine([], f);\n\t} else {\n\t\tvar g;if (typeof window !== \"undefined\") {\n\t\t\tg = window;\n\t\t} else if (typeof global !== \"undefined\") {\n\t\t\tg = global;\n\t\t} else if (typeof self !== \"undefined\") {\n\t\t\tg = self;\n\t\t} else {\n\t\t\tg = this;\n\t\t}g.Chart = f();\n\t}\n})(function () {\n\tvar define, module, exports;return function e(t, n, r) {\n\t\tfunction s(o, u) {\n\t\t\tif (!n[o]) {\n\t\t\t\tif (!t[o]) {\n\t\t\t\t\tvar a = typeof require == \"function\" && require;if (!u && a) return a(o, !0);if (i) return i(o, !0);var f = new Error(\"Cannot find module '\" + o + \"'\");throw f.code = \"MODULE_NOT_FOUND\", f;\n\t\t\t\t}var l = n[o] = { exports: {} };t[o][0].call(l.exports, function (e) {\n\t\t\t\t\tvar n = t[o][1][e];return s(n ? n : e);\n\t\t\t\t}, l, l.exports, e, t, n, r);\n\t\t\t}return n[o].exports;\n\t\t}var i = typeof require == \"function\" && require;for (var o = 0; o < r.length; o++) {\n\t\t\ts(r[o]);\n\t\t}return s;\n\t}({ 1: [function (require, module, exports) {}, {}], 2: [function (require, module, exports) {\n\t\t\t/* MIT license */\n\t\t\tvar colorNames = require(6);\n\n\t\t\tmodule.exports = {\n\t\t\t\tgetRgba: getRgba,\n\t\t\t\tgetHsla: getHsla,\n\t\t\t\tgetRgb: getRgb,\n\t\t\t\tgetHsl: getHsl,\n\t\t\t\tgetHwb: getHwb,\n\t\t\t\tgetAlpha: getAlpha,\n\n\t\t\t\thexString: hexString,\n\t\t\t\trgbString: rgbString,\n\t\t\t\trgbaString: rgbaString,\n\t\t\t\tpercentString: percentString,\n\t\t\t\tpercentaString: percentaString,\n\t\t\t\thslString: hslString,\n\t\t\t\thslaString: hslaString,\n\t\t\t\thwbString: hwbString,\n\t\t\t\tkeyword: keyword\n\t\t\t};\n\n\t\t\tfunction getRgba(string) {\n\t\t\t\tif (!string) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tvar abbr = /^#([a-fA-F0-9]{3})$/,\n\t\t\t\t    hex = /^#([a-fA-F0-9]{6})$/,\n\t\t\t\t    rgba = /^rgba?\\(\\s*([+-]?\\d+)\\s*,\\s*([+-]?\\d+)\\s*,\\s*([+-]?\\d+)\\s*(?:,\\s*([+-]?[\\d\\.]+)\\s*)?\\)$/,\n\t\t\t\t    per = /^rgba?\\(\\s*([+-]?[\\d\\.]+)\\%\\s*,\\s*([+-]?[\\d\\.]+)\\%\\s*,\\s*([+-]?[\\d\\.]+)\\%\\s*(?:,\\s*([+-]?[\\d\\.]+)\\s*)?\\)$/,\n\t\t\t\t    keyword = /(\\w+)/;\n\n\t\t\t\tvar rgb = [0, 0, 0],\n\t\t\t\t    a = 1,\n\t\t\t\t    match = string.match(abbr);\n\t\t\t\tif (match) {\n\t\t\t\t\tmatch = match[1];\n\t\t\t\t\tfor (var i = 0; i < rgb.length; i++) {\n\t\t\t\t\t\trgb[i] = parseInt(match[i] + match[i], 16);\n\t\t\t\t\t}\n\t\t\t\t} else if (match = string.match(hex)) {\n\t\t\t\t\tmatch = match[1];\n\t\t\t\t\tfor (var i = 0; i < rgb.length; i++) {\n\t\t\t\t\t\trgb[i] = parseInt(match.slice(i * 2, i * 2 + 2), 16);\n\t\t\t\t\t}\n\t\t\t\t} else if (match = string.match(rgba)) {\n\t\t\t\t\tfor (var i = 0; i < rgb.length; i++) {\n\t\t\t\t\t\trgb[i] = parseInt(match[i + 1]);\n\t\t\t\t\t}\n\t\t\t\t\ta = parseFloat(match[4]);\n\t\t\t\t} else if (match = string.match(per)) {\n\t\t\t\t\tfor (var i = 0; i < rgb.length; i++) {\n\t\t\t\t\t\trgb[i] = Math.round(parseFloat(match[i + 1]) * 2.55);\n\t\t\t\t\t}\n\t\t\t\t\ta = parseFloat(match[4]);\n\t\t\t\t} else if (match = string.match(keyword)) {\n\t\t\t\t\tif (match[1] == \"transparent\") {\n\t\t\t\t\t\treturn [0, 0, 0, 0];\n\t\t\t\t\t}\n\t\t\t\t\trgb = colorNames[match[1]];\n\t\t\t\t\tif (!rgb) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor (var i = 0; i < rgb.length; i++) {\n\t\t\t\t\trgb[i] = scale(rgb[i], 0, 255);\n\t\t\t\t}\n\t\t\t\tif (!a && a != 0) {\n\t\t\t\t\ta = 1;\n\t\t\t\t} else {\n\t\t\t\t\ta = scale(a, 0, 1);\n\t\t\t\t}\n\t\t\t\trgb[3] = a;\n\t\t\t\treturn rgb;\n\t\t\t}\n\n\t\t\tfunction getHsla(string) {\n\t\t\t\tif (!string) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tvar hsl = /^hsla?\\(\\s*([+-]?\\d+)(?:deg)?\\s*,\\s*([+-]?[\\d\\.]+)%\\s*,\\s*([+-]?[\\d\\.]+)%\\s*(?:,\\s*([+-]?[\\d\\.]+)\\s*)?\\)/;\n\t\t\t\tvar match = string.match(hsl);\n\t\t\t\tif (match) {\n\t\t\t\t\tvar alpha = parseFloat(match[4]);\n\t\t\t\t\tvar h = scale(parseInt(match[1]), 0, 360),\n\t\t\t\t\t    s = scale(parseFloat(match[2]), 0, 100),\n\t\t\t\t\t    l = scale(parseFloat(match[3]), 0, 100),\n\t\t\t\t\t    a = scale(isNaN(alpha) ? 1 : alpha, 0, 1);\n\t\t\t\t\treturn [h, s, l, a];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction getHwb(string) {\n\t\t\t\tif (!string) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tvar hwb = /^hwb\\(\\s*([+-]?\\d+)(?:deg)?\\s*,\\s*([+-]?[\\d\\.]+)%\\s*,\\s*([+-]?[\\d\\.]+)%\\s*(?:,\\s*([+-]?[\\d\\.]+)\\s*)?\\)/;\n\t\t\t\tvar match = string.match(hwb);\n\t\t\t\tif (match) {\n\t\t\t\t\tvar alpha = parseFloat(match[4]);\n\t\t\t\t\tvar h = scale(parseInt(match[1]), 0, 360),\n\t\t\t\t\t    w = scale(parseFloat(match[2]), 0, 100),\n\t\t\t\t\t    b = scale(parseFloat(match[3]), 0, 100),\n\t\t\t\t\t    a = scale(isNaN(alpha) ? 1 : alpha, 0, 1);\n\t\t\t\t\treturn [h, w, b, a];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction getRgb(string) {\n\t\t\t\tvar rgba = getRgba(string);\n\t\t\t\treturn rgba && rgba.slice(0, 3);\n\t\t\t}\n\n\t\t\tfunction getHsl(string) {\n\t\t\t\tvar hsla = getHsla(string);\n\t\t\t\treturn hsla && hsla.slice(0, 3);\n\t\t\t}\n\n\t\t\tfunction getAlpha(string) {\n\t\t\t\tvar vals = getRgba(string);\n\t\t\t\tif (vals) {\n\t\t\t\t\treturn vals[3];\n\t\t\t\t} else if (vals = getHsla(string)) {\n\t\t\t\t\treturn vals[3];\n\t\t\t\t} else if (vals = getHwb(string)) {\n\t\t\t\t\treturn vals[3];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// generators\n\t\t\tfunction hexString(rgb) {\n\t\t\t\treturn \"#\" + hexDouble(rgb[0]) + hexDouble(rgb[1]) + hexDouble(rgb[2]);\n\t\t\t}\n\n\t\t\tfunction rgbString(rgba, alpha) {\n\t\t\t\tif (alpha < 1 || rgba[3] && rgba[3] < 1) {\n\t\t\t\t\treturn rgbaString(rgba, alpha);\n\t\t\t\t}\n\t\t\t\treturn \"rgb(\" + rgba[0] + \", \" + rgba[1] + \", \" + rgba[2] + \")\";\n\t\t\t}\n\n\t\t\tfunction rgbaString(rgba, alpha) {\n\t\t\t\tif (alpha === undefined) {\n\t\t\t\t\talpha = rgba[3] !== undefined ? rgba[3] : 1;\n\t\t\t\t}\n\t\t\t\treturn \"rgba(\" + rgba[0] + \", \" + rgba[1] + \", \" + rgba[2] + \", \" + alpha + \")\";\n\t\t\t}\n\n\t\t\tfunction percentString(rgba, alpha) {\n\t\t\t\tif (alpha < 1 || rgba[3] && rgba[3] < 1) {\n\t\t\t\t\treturn percentaString(rgba, alpha);\n\t\t\t\t}\n\t\t\t\tvar r = Math.round(rgba[0] / 255 * 100),\n\t\t\t\t    g = Math.round(rgba[1] / 255 * 100),\n\t\t\t\t    b = Math.round(rgba[2] / 255 * 100);\n\n\t\t\t\treturn \"rgb(\" + r + \"%, \" + g + \"%, \" + b + \"%)\";\n\t\t\t}\n\n\t\t\tfunction percentaString(rgba, alpha) {\n\t\t\t\tvar r = Math.round(rgba[0] / 255 * 100),\n\t\t\t\t    g = Math.round(rgba[1] / 255 * 100),\n\t\t\t\t    b = Math.round(rgba[2] / 255 * 100);\n\t\t\t\treturn \"rgba(\" + r + \"%, \" + g + \"%, \" + b + \"%, \" + (alpha || rgba[3] || 1) + \")\";\n\t\t\t}\n\n\t\t\tfunction hslString(hsla, alpha) {\n\t\t\t\tif (alpha < 1 || hsla[3] && hsla[3] < 1) {\n\t\t\t\t\treturn hslaString(hsla, alpha);\n\t\t\t\t}\n\t\t\t\treturn \"hsl(\" + hsla[0] + \", \" + hsla[1] + \"%, \" + hsla[2] + \"%)\";\n\t\t\t}\n\n\t\t\tfunction hslaString(hsla, alpha) {\n\t\t\t\tif (alpha === undefined) {\n\t\t\t\t\talpha = hsla[3] !== undefined ? hsla[3] : 1;\n\t\t\t\t}\n\t\t\t\treturn \"hsla(\" + hsla[0] + \", \" + hsla[1] + \"%, \" + hsla[2] + \"%, \" + alpha + \")\";\n\t\t\t}\n\n\t\t\t// hwb is a bit different than rgb(a) & hsl(a) since there is no alpha specific syntax\n\t\t\t// (hwb have alpha optional & 1 is default value)\n\t\t\tfunction hwbString(hwb, alpha) {\n\t\t\t\tif (alpha === undefined) {\n\t\t\t\t\talpha = hwb[3] !== undefined ? hwb[3] : 1;\n\t\t\t\t}\n\t\t\t\treturn \"hwb(\" + hwb[0] + \", \" + hwb[1] + \"%, \" + hwb[2] + \"%\" + (alpha !== undefined && alpha !== 1 ? \", \" + alpha : \"\") + \")\";\n\t\t\t}\n\n\t\t\tfunction keyword(rgb) {\n\t\t\t\treturn reverseNames[rgb.slice(0, 3)];\n\t\t\t}\n\n\t\t\t// helpers\n\t\t\tfunction scale(num, min, max) {\n\t\t\t\treturn Math.min(Math.max(min, num), max);\n\t\t\t}\n\n\t\t\tfunction hexDouble(num) {\n\t\t\t\tvar str = num.toString(16).toUpperCase();\n\t\t\t\treturn str.length < 2 ? \"0\" + str : str;\n\t\t\t}\n\n\t\t\t//create a list of reverse color names\n\t\t\tvar reverseNames = {};\n\t\t\tfor (var name in colorNames) {\n\t\t\t\treverseNames[colorNames[name]] = name;\n\t\t\t}\n\t\t}, { \"6\": 6 }], 3: [function (require, module, exports) {\n\t\t\t/* MIT license */\n\t\t\tvar convert = require(5);\n\t\t\tvar string = require(2);\n\n\t\t\tvar Color = function Color(obj) {\n\t\t\t\tif (obj instanceof Color) {\n\t\t\t\t\treturn obj;\n\t\t\t\t}\n\t\t\t\tif (!(this instanceof Color)) {\n\t\t\t\t\treturn new Color(obj);\n\t\t\t\t}\n\n\t\t\t\tthis.values = {\n\t\t\t\t\trgb: [0, 0, 0],\n\t\t\t\t\thsl: [0, 0, 0],\n\t\t\t\t\thsv: [0, 0, 0],\n\t\t\t\t\thwb: [0, 0, 0],\n\t\t\t\t\tcmyk: [0, 0, 0, 0],\n\t\t\t\t\talpha: 1\n\t\t\t\t};\n\n\t\t\t\t// parse Color() argument\n\t\t\t\tvar vals;\n\t\t\t\tif (typeof obj === 'string') {\n\t\t\t\t\tvals = string.getRgba(obj);\n\t\t\t\t\tif (vals) {\n\t\t\t\t\t\tthis.setValues('rgb', vals);\n\t\t\t\t\t} else if (vals = string.getHsla(obj)) {\n\t\t\t\t\t\tthis.setValues('hsl', vals);\n\t\t\t\t\t} else if (vals = string.getHwb(obj)) {\n\t\t\t\t\t\tthis.setValues('hwb', vals);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new Error('Unable to parse color from string \"' + obj + '\"');\n\t\t\t\t\t}\n\t\t\t\t} else if ((typeof obj === \"undefined\" ? \"undefined\" : _typeof(obj)) === 'object') {\n\t\t\t\t\tvals = obj;\n\t\t\t\t\tif (vals.r !== undefined || vals.red !== undefined) {\n\t\t\t\t\t\tthis.setValues('rgb', vals);\n\t\t\t\t\t} else if (vals.l !== undefined || vals.lightness !== undefined) {\n\t\t\t\t\t\tthis.setValues('hsl', vals);\n\t\t\t\t\t} else if (vals.v !== undefined || vals.value !== undefined) {\n\t\t\t\t\t\tthis.setValues('hsv', vals);\n\t\t\t\t\t} else if (vals.w !== undefined || vals.whiteness !== undefined) {\n\t\t\t\t\t\tthis.setValues('hwb', vals);\n\t\t\t\t\t} else if (vals.c !== undefined || vals.cyan !== undefined) {\n\t\t\t\t\t\tthis.setValues('cmyk', vals);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new Error('Unable to parse color from object ' + JSON.stringify(obj));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tColor.prototype = {\n\t\t\t\trgb: function rgb() {\n\t\t\t\t\treturn this.setSpace('rgb', arguments);\n\t\t\t\t},\n\t\t\t\thsl: function hsl() {\n\t\t\t\t\treturn this.setSpace('hsl', arguments);\n\t\t\t\t},\n\t\t\t\thsv: function hsv() {\n\t\t\t\t\treturn this.setSpace('hsv', arguments);\n\t\t\t\t},\n\t\t\t\thwb: function hwb() {\n\t\t\t\t\treturn this.setSpace('hwb', arguments);\n\t\t\t\t},\n\t\t\t\tcmyk: function cmyk() {\n\t\t\t\t\treturn this.setSpace('cmyk', arguments);\n\t\t\t\t},\n\n\t\t\t\trgbArray: function rgbArray() {\n\t\t\t\t\treturn this.values.rgb;\n\t\t\t\t},\n\t\t\t\thslArray: function hslArray() {\n\t\t\t\t\treturn this.values.hsl;\n\t\t\t\t},\n\t\t\t\thsvArray: function hsvArray() {\n\t\t\t\t\treturn this.values.hsv;\n\t\t\t\t},\n\t\t\t\thwbArray: function hwbArray() {\n\t\t\t\t\tvar values = this.values;\n\t\t\t\t\tif (values.alpha !== 1) {\n\t\t\t\t\t\treturn values.hwb.concat([values.alpha]);\n\t\t\t\t\t}\n\t\t\t\t\treturn values.hwb;\n\t\t\t\t},\n\t\t\t\tcmykArray: function cmykArray() {\n\t\t\t\t\treturn this.values.cmyk;\n\t\t\t\t},\n\t\t\t\trgbaArray: function rgbaArray() {\n\t\t\t\t\tvar values = this.values;\n\t\t\t\t\treturn values.rgb.concat([values.alpha]);\n\t\t\t\t},\n\t\t\t\thslaArray: function hslaArray() {\n\t\t\t\t\tvar values = this.values;\n\t\t\t\t\treturn values.hsl.concat([values.alpha]);\n\t\t\t\t},\n\t\t\t\talpha: function alpha(val) {\n\t\t\t\t\tif (val === undefined) {\n\t\t\t\t\t\treturn this.values.alpha;\n\t\t\t\t\t}\n\t\t\t\t\tthis.setValues('alpha', val);\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\tred: function red(val) {\n\t\t\t\t\treturn this.setChannel('rgb', 0, val);\n\t\t\t\t},\n\t\t\t\tgreen: function green(val) {\n\t\t\t\t\treturn this.setChannel('rgb', 1, val);\n\t\t\t\t},\n\t\t\t\tblue: function blue(val) {\n\t\t\t\t\treturn this.setChannel('rgb', 2, val);\n\t\t\t\t},\n\t\t\t\thue: function hue(val) {\n\t\t\t\t\tif (val) {\n\t\t\t\t\t\tval %= 360;\n\t\t\t\t\t\tval = val < 0 ? 360 + val : val;\n\t\t\t\t\t}\n\t\t\t\t\treturn this.setChannel('hsl', 0, val);\n\t\t\t\t},\n\t\t\t\tsaturation: function saturation(val) {\n\t\t\t\t\treturn this.setChannel('hsl', 1, val);\n\t\t\t\t},\n\t\t\t\tlightness: function lightness(val) {\n\t\t\t\t\treturn this.setChannel('hsl', 2, val);\n\t\t\t\t},\n\t\t\t\tsaturationv: function saturationv(val) {\n\t\t\t\t\treturn this.setChannel('hsv', 1, val);\n\t\t\t\t},\n\t\t\t\twhiteness: function whiteness(val) {\n\t\t\t\t\treturn this.setChannel('hwb', 1, val);\n\t\t\t\t},\n\t\t\t\tblackness: function blackness(val) {\n\t\t\t\t\treturn this.setChannel('hwb', 2, val);\n\t\t\t\t},\n\t\t\t\tvalue: function value(val) {\n\t\t\t\t\treturn this.setChannel('hsv', 2, val);\n\t\t\t\t},\n\t\t\t\tcyan: function cyan(val) {\n\t\t\t\t\treturn this.setChannel('cmyk', 0, val);\n\t\t\t\t},\n\t\t\t\tmagenta: function magenta(val) {\n\t\t\t\t\treturn this.setChannel('cmyk', 1, val);\n\t\t\t\t},\n\t\t\t\tyellow: function yellow(val) {\n\t\t\t\t\treturn this.setChannel('cmyk', 2, val);\n\t\t\t\t},\n\t\t\t\tblack: function black(val) {\n\t\t\t\t\treturn this.setChannel('cmyk', 3, val);\n\t\t\t\t},\n\n\t\t\t\thexString: function hexString() {\n\t\t\t\t\treturn string.hexString(this.values.rgb);\n\t\t\t\t},\n\t\t\t\trgbString: function rgbString() {\n\t\t\t\t\treturn string.rgbString(this.values.rgb, this.values.alpha);\n\t\t\t\t},\n\t\t\t\trgbaString: function rgbaString() {\n\t\t\t\t\treturn string.rgbaString(this.values.rgb, this.values.alpha);\n\t\t\t\t},\n\t\t\t\tpercentString: function percentString() {\n\t\t\t\t\treturn string.percentString(this.values.rgb, this.values.alpha);\n\t\t\t\t},\n\t\t\t\thslString: function hslString() {\n\t\t\t\t\treturn string.hslString(this.values.hsl, this.values.alpha);\n\t\t\t\t},\n\t\t\t\thslaString: function hslaString() {\n\t\t\t\t\treturn string.hslaString(this.values.hsl, this.values.alpha);\n\t\t\t\t},\n\t\t\t\thwbString: function hwbString() {\n\t\t\t\t\treturn string.hwbString(this.values.hwb, this.values.alpha);\n\t\t\t\t},\n\t\t\t\tkeyword: function keyword() {\n\t\t\t\t\treturn string.keyword(this.values.rgb, this.values.alpha);\n\t\t\t\t},\n\n\t\t\t\trgbNumber: function rgbNumber() {\n\t\t\t\t\tvar rgb = this.values.rgb;\n\t\t\t\t\treturn rgb[0] << 16 | rgb[1] << 8 | rgb[2];\n\t\t\t\t},\n\n\t\t\t\tluminosity: function luminosity() {\n\t\t\t\t\t// http://www.w3.org/TR/WCAG20/#relativeluminancedef\n\t\t\t\t\tvar rgb = this.values.rgb;\n\t\t\t\t\tvar lum = [];\n\t\t\t\t\tfor (var i = 0; i < rgb.length; i++) {\n\t\t\t\t\t\tvar chan = rgb[i] / 255;\n\t\t\t\t\t\tlum[i] = chan <= 0.03928 ? chan / 12.92 : Math.pow((chan + 0.055) / 1.055, 2.4);\n\t\t\t\t\t}\n\t\t\t\t\treturn 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];\n\t\t\t\t},\n\n\t\t\t\tcontrast: function contrast(color2) {\n\t\t\t\t\t// http://www.w3.org/TR/WCAG20/#contrast-ratiodef\n\t\t\t\t\tvar lum1 = this.luminosity();\n\t\t\t\t\tvar lum2 = color2.luminosity();\n\t\t\t\t\tif (lum1 > lum2) {\n\t\t\t\t\t\treturn (lum1 + 0.05) / (lum2 + 0.05);\n\t\t\t\t\t}\n\t\t\t\t\treturn (lum2 + 0.05) / (lum1 + 0.05);\n\t\t\t\t},\n\n\t\t\t\tlevel: function level(color2) {\n\t\t\t\t\tvar contrastRatio = this.contrast(color2);\n\t\t\t\t\tif (contrastRatio >= 7.1) {\n\t\t\t\t\t\treturn 'AAA';\n\t\t\t\t\t}\n\n\t\t\t\t\treturn contrastRatio >= 4.5 ? 'AA' : '';\n\t\t\t\t},\n\n\t\t\t\tdark: function dark() {\n\t\t\t\t\t// YIQ equation from http://24ways.org/2010/calculating-color-contrast\n\t\t\t\t\tvar rgb = this.values.rgb;\n\t\t\t\t\tvar yiq = (rgb[0] * 299 + rgb[1] * 587 + rgb[2] * 114) / 1000;\n\t\t\t\t\treturn yiq < 128;\n\t\t\t\t},\n\n\t\t\t\tlight: function light() {\n\t\t\t\t\treturn !this.dark();\n\t\t\t\t},\n\n\t\t\t\tnegate: function negate() {\n\t\t\t\t\tvar rgb = [];\n\t\t\t\t\tfor (var i = 0; i < 3; i++) {\n\t\t\t\t\t\trgb[i] = 255 - this.values.rgb[i];\n\t\t\t\t\t}\n\t\t\t\t\tthis.setValues('rgb', rgb);\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\tlighten: function lighten(ratio) {\n\t\t\t\t\tvar hsl = this.values.hsl;\n\t\t\t\t\thsl[2] += hsl[2] * ratio;\n\t\t\t\t\tthis.setValues('hsl', hsl);\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\tdarken: function darken(ratio) {\n\t\t\t\t\tvar hsl = this.values.hsl;\n\t\t\t\t\thsl[2] -= hsl[2] * ratio;\n\t\t\t\t\tthis.setValues('hsl', hsl);\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\tsaturate: function saturate(ratio) {\n\t\t\t\t\tvar hsl = this.values.hsl;\n\t\t\t\t\thsl[1] += hsl[1] * ratio;\n\t\t\t\t\tthis.setValues('hsl', hsl);\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\tdesaturate: function desaturate(ratio) {\n\t\t\t\t\tvar hsl = this.values.hsl;\n\t\t\t\t\thsl[1] -= hsl[1] * ratio;\n\t\t\t\t\tthis.setValues('hsl', hsl);\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\twhiten: function whiten(ratio) {\n\t\t\t\t\tvar hwb = this.values.hwb;\n\t\t\t\t\thwb[1] += hwb[1] * ratio;\n\t\t\t\t\tthis.setValues('hwb', hwb);\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\tblacken: function blacken(ratio) {\n\t\t\t\t\tvar hwb = this.values.hwb;\n\t\t\t\t\thwb[2] += hwb[2] * ratio;\n\t\t\t\t\tthis.setValues('hwb', hwb);\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\tgreyscale: function greyscale() {\n\t\t\t\t\tvar rgb = this.values.rgb;\n\t\t\t\t\t// http://en.wikipedia.org/wiki/Grayscale#Converting_color_to_grayscale\n\t\t\t\t\tvar val = rgb[0] * 0.3 + rgb[1] * 0.59 + rgb[2] * 0.11;\n\t\t\t\t\tthis.setValues('rgb', [val, val, val]);\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\tclearer: function clearer(ratio) {\n\t\t\t\t\tvar alpha = this.values.alpha;\n\t\t\t\t\tthis.setValues('alpha', alpha - alpha * ratio);\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\topaquer: function opaquer(ratio) {\n\t\t\t\t\tvar alpha = this.values.alpha;\n\t\t\t\t\tthis.setValues('alpha', alpha + alpha * ratio);\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\trotate: function rotate(degrees) {\n\t\t\t\t\tvar hsl = this.values.hsl;\n\t\t\t\t\tvar hue = (hsl[0] + degrees) % 360;\n\t\t\t\t\thsl[0] = hue < 0 ? 360 + hue : hue;\n\t\t\t\t\tthis.setValues('hsl', hsl);\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t/**\r\n     * Ported from sass implementation in C\r\n     * https://github.com/sass/libsass/blob/0e6b4a2850092356aa3ece07c6b249f0221caced/functions.cpp#L209\r\n     */\n\t\t\t\tmix: function mix(mixinColor, weight) {\n\t\t\t\t\tvar color1 = this;\n\t\t\t\t\tvar color2 = mixinColor;\n\t\t\t\t\tvar p = weight === undefined ? 0.5 : weight;\n\n\t\t\t\t\tvar w = 2 * p - 1;\n\t\t\t\t\tvar a = color1.alpha() - color2.alpha();\n\n\t\t\t\t\tvar w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2.0;\n\t\t\t\t\tvar w2 = 1 - w1;\n\n\t\t\t\t\treturn this.rgb(w1 * color1.red() + w2 * color2.red(), w1 * color1.green() + w2 * color2.green(), w1 * color1.blue() + w2 * color2.blue()).alpha(color1.alpha() * p + color2.alpha() * (1 - p));\n\t\t\t\t},\n\n\t\t\t\ttoJSON: function toJSON() {\n\t\t\t\t\treturn this.rgb();\n\t\t\t\t},\n\n\t\t\t\tclone: function clone() {\n\t\t\t\t\t// NOTE(SB): using node-clone creates a dependency to Buffer when using browserify,\n\t\t\t\t\t// making the final build way to big to embed in Chart.js. So let's do it manually,\n\t\t\t\t\t// assuming that values to clone are 1 dimension arrays containing only numbers,\n\t\t\t\t\t// except 'alpha' which is a number.\n\t\t\t\t\tvar result = new Color();\n\t\t\t\t\tvar source = this.values;\n\t\t\t\t\tvar target = result.values;\n\t\t\t\t\tvar value, type;\n\n\t\t\t\t\tfor (var prop in source) {\n\t\t\t\t\t\tif (source.hasOwnProperty(prop)) {\n\t\t\t\t\t\t\tvalue = source[prop];\n\t\t\t\t\t\t\ttype = {}.toString.call(value);\n\t\t\t\t\t\t\tif (type === '[object Array]') {\n\t\t\t\t\t\t\t\ttarget[prop] = value.slice(0);\n\t\t\t\t\t\t\t} else if (type === '[object Number]') {\n\t\t\t\t\t\t\t\ttarget[prop] = value;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tconsole.error('unexpected color value:', value);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tColor.prototype.spaces = {\n\t\t\t\trgb: ['red', 'green', 'blue'],\n\t\t\t\thsl: ['hue', 'saturation', 'lightness'],\n\t\t\t\thsv: ['hue', 'saturation', 'value'],\n\t\t\t\thwb: ['hue', 'whiteness', 'blackness'],\n\t\t\t\tcmyk: ['cyan', 'magenta', 'yellow', 'black']\n\t\t\t};\n\n\t\t\tColor.prototype.maxes = {\n\t\t\t\trgb: [255, 255, 255],\n\t\t\t\thsl: [360, 100, 100],\n\t\t\t\thsv: [360, 100, 100],\n\t\t\t\thwb: [360, 100, 100],\n\t\t\t\tcmyk: [100, 100, 100, 100]\n\t\t\t};\n\n\t\t\tColor.prototype.getValues = function (space) {\n\t\t\t\tvar values = this.values;\n\t\t\t\tvar vals = {};\n\n\t\t\t\tfor (var i = 0; i < space.length; i++) {\n\t\t\t\t\tvals[space.charAt(i)] = values[space][i];\n\t\t\t\t}\n\n\t\t\t\tif (values.alpha !== 1) {\n\t\t\t\t\tvals.a = values.alpha;\n\t\t\t\t}\n\n\t\t\t\t// {r: 255, g: 255, b: 255, a: 0.4}\n\t\t\t\treturn vals;\n\t\t\t};\n\n\t\t\tColor.prototype.setValues = function (space, vals) {\n\t\t\t\tvar values = this.values;\n\t\t\t\tvar spaces = this.spaces;\n\t\t\t\tvar maxes = this.maxes;\n\t\t\t\tvar alpha = 1;\n\t\t\t\tvar i;\n\n\t\t\t\tif (space === 'alpha') {\n\t\t\t\t\talpha = vals;\n\t\t\t\t} else if (vals.length) {\n\t\t\t\t\t// [10, 10, 10]\n\t\t\t\t\tvalues[space] = vals.slice(0, space.length);\n\t\t\t\t\talpha = vals[space.length];\n\t\t\t\t} else if (vals[space.charAt(0)] !== undefined) {\n\t\t\t\t\t// {r: 10, g: 10, b: 10}\n\t\t\t\t\tfor (i = 0; i < space.length; i++) {\n\t\t\t\t\t\tvalues[space][i] = vals[space.charAt(i)];\n\t\t\t\t\t}\n\n\t\t\t\t\talpha = vals.a;\n\t\t\t\t} else if (vals[spaces[space][0]] !== undefined) {\n\t\t\t\t\t// {red: 10, green: 10, blue: 10}\n\t\t\t\t\tvar chans = spaces[space];\n\n\t\t\t\t\tfor (i = 0; i < space.length; i++) {\n\t\t\t\t\t\tvalues[space][i] = vals[chans[i]];\n\t\t\t\t\t}\n\n\t\t\t\t\talpha = vals.alpha;\n\t\t\t\t}\n\n\t\t\t\tvalues.alpha = Math.max(0, Math.min(1, alpha === undefined ? values.alpha : alpha));\n\n\t\t\t\tif (space === 'alpha') {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tvar capped;\n\n\t\t\t\t// cap values of the space prior converting all values\n\t\t\t\tfor (i = 0; i < space.length; i++) {\n\t\t\t\t\tcapped = Math.max(0, Math.min(maxes[space][i], values[space][i]));\n\t\t\t\t\tvalues[space][i] = Math.round(capped);\n\t\t\t\t}\n\n\t\t\t\t// convert to all the other color spaces\n\t\t\t\tfor (var sname in spaces) {\n\t\t\t\t\tif (sname !== space) {\n\t\t\t\t\t\tvalues[sname] = convert[space][sname](values[space]);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\t\t\t};\n\n\t\t\tColor.prototype.setSpace = function (space, args) {\n\t\t\t\tvar vals = args[0];\n\n\t\t\t\tif (vals === undefined) {\n\t\t\t\t\t// color.rgb()\n\t\t\t\t\treturn this.getValues(space);\n\t\t\t\t}\n\n\t\t\t\t// color.rgb(10, 10, 10)\n\t\t\t\tif (typeof vals === 'number') {\n\t\t\t\t\tvals = Array.prototype.slice.call(args);\n\t\t\t\t}\n\n\t\t\t\tthis.setValues(space, vals);\n\t\t\t\treturn this;\n\t\t\t};\n\n\t\t\tColor.prototype.setChannel = function (space, index, val) {\n\t\t\t\tvar svalues = this.values[space];\n\t\t\t\tif (val === undefined) {\n\t\t\t\t\t// color.red()\n\t\t\t\t\treturn svalues[index];\n\t\t\t\t} else if (val === svalues[index]) {\n\t\t\t\t\t// color.red(color.red())\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\n\t\t\t\t// color.red(100)\n\t\t\t\tsvalues[index] = val;\n\t\t\t\tthis.setValues(space, svalues);\n\n\t\t\t\treturn this;\n\t\t\t};\n\n\t\t\tif (typeof window !== 'undefined') {\n\t\t\t\twindow.Color = Color;\n\t\t\t}\n\n\t\t\tmodule.exports = Color;\n\t\t}, { \"2\": 2, \"5\": 5 }], 4: [function (require, module, exports) {\n\t\t\t/* MIT license */\n\n\t\t\tmodule.exports = {\n\t\t\t\trgb2hsl: rgb2hsl,\n\t\t\t\trgb2hsv: rgb2hsv,\n\t\t\t\trgb2hwb: rgb2hwb,\n\t\t\t\trgb2cmyk: rgb2cmyk,\n\t\t\t\trgb2keyword: rgb2keyword,\n\t\t\t\trgb2xyz: rgb2xyz,\n\t\t\t\trgb2lab: rgb2lab,\n\t\t\t\trgb2lch: rgb2lch,\n\n\t\t\t\thsl2rgb: hsl2rgb,\n\t\t\t\thsl2hsv: hsl2hsv,\n\t\t\t\thsl2hwb: hsl2hwb,\n\t\t\t\thsl2cmyk: hsl2cmyk,\n\t\t\t\thsl2keyword: hsl2keyword,\n\n\t\t\t\thsv2rgb: hsv2rgb,\n\t\t\t\thsv2hsl: hsv2hsl,\n\t\t\t\thsv2hwb: hsv2hwb,\n\t\t\t\thsv2cmyk: hsv2cmyk,\n\t\t\t\thsv2keyword: hsv2keyword,\n\n\t\t\t\thwb2rgb: hwb2rgb,\n\t\t\t\thwb2hsl: hwb2hsl,\n\t\t\t\thwb2hsv: hwb2hsv,\n\t\t\t\thwb2cmyk: hwb2cmyk,\n\t\t\t\thwb2keyword: hwb2keyword,\n\n\t\t\t\tcmyk2rgb: cmyk2rgb,\n\t\t\t\tcmyk2hsl: cmyk2hsl,\n\t\t\t\tcmyk2hsv: cmyk2hsv,\n\t\t\t\tcmyk2hwb: cmyk2hwb,\n\t\t\t\tcmyk2keyword: cmyk2keyword,\n\n\t\t\t\tkeyword2rgb: keyword2rgb,\n\t\t\t\tkeyword2hsl: keyword2hsl,\n\t\t\t\tkeyword2hsv: keyword2hsv,\n\t\t\t\tkeyword2hwb: keyword2hwb,\n\t\t\t\tkeyword2cmyk: keyword2cmyk,\n\t\t\t\tkeyword2lab: keyword2lab,\n\t\t\t\tkeyword2xyz: keyword2xyz,\n\n\t\t\t\txyz2rgb: xyz2rgb,\n\t\t\t\txyz2lab: xyz2lab,\n\t\t\t\txyz2lch: xyz2lch,\n\n\t\t\t\tlab2xyz: lab2xyz,\n\t\t\t\tlab2rgb: lab2rgb,\n\t\t\t\tlab2lch: lab2lch,\n\n\t\t\t\tlch2lab: lch2lab,\n\t\t\t\tlch2xyz: lch2xyz,\n\t\t\t\tlch2rgb: lch2rgb\n\t\t\t};\n\n\t\t\tfunction rgb2hsl(rgb) {\n\t\t\t\tvar r = rgb[0] / 255,\n\t\t\t\t    g = rgb[1] / 255,\n\t\t\t\t    b = rgb[2] / 255,\n\t\t\t\t    min = Math.min(r, g, b),\n\t\t\t\t    max = Math.max(r, g, b),\n\t\t\t\t    delta = max - min,\n\t\t\t\t    h,\n\t\t\t\t    s,\n\t\t\t\t    l;\n\n\t\t\t\tif (max == min) h = 0;else if (r == max) h = (g - b) / delta;else if (g == max) h = 2 + (b - r) / delta;else if (b == max) h = 4 + (r - g) / delta;\n\n\t\t\t\th = Math.min(h * 60, 360);\n\n\t\t\t\tif (h < 0) h += 360;\n\n\t\t\t\tl = (min + max) / 2;\n\n\t\t\t\tif (max == min) s = 0;else if (l <= 0.5) s = delta / (max + min);else s = delta / (2 - max - min);\n\n\t\t\t\treturn [h, s * 100, l * 100];\n\t\t\t}\n\n\t\t\tfunction rgb2hsv(rgb) {\n\t\t\t\tvar r = rgb[0],\n\t\t\t\t    g = rgb[1],\n\t\t\t\t    b = rgb[2],\n\t\t\t\t    min = Math.min(r, g, b),\n\t\t\t\t    max = Math.max(r, g, b),\n\t\t\t\t    delta = max - min,\n\t\t\t\t    h,\n\t\t\t\t    s,\n\t\t\t\t    v;\n\n\t\t\t\tif (max == 0) s = 0;else s = delta / max * 1000 / 10;\n\n\t\t\t\tif (max == min) h = 0;else if (r == max) h = (g - b) / delta;else if (g == max) h = 2 + (b - r) / delta;else if (b == max) h = 4 + (r - g) / delta;\n\n\t\t\t\th = Math.min(h * 60, 360);\n\n\t\t\t\tif (h < 0) h += 360;\n\n\t\t\t\tv = max / 255 * 1000 / 10;\n\n\t\t\t\treturn [h, s, v];\n\t\t\t}\n\n\t\t\tfunction rgb2hwb(rgb) {\n\t\t\t\tvar r = rgb[0],\n\t\t\t\t    g = rgb[1],\n\t\t\t\t    b = rgb[2],\n\t\t\t\t    h = rgb2hsl(rgb)[0],\n\t\t\t\t    w = 1 / 255 * Math.min(r, Math.min(g, b)),\n\t\t\t\t    b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));\n\n\t\t\t\treturn [h, w * 100, b * 100];\n\t\t\t}\n\n\t\t\tfunction rgb2cmyk(rgb) {\n\t\t\t\tvar r = rgb[0] / 255,\n\t\t\t\t    g = rgb[1] / 255,\n\t\t\t\t    b = rgb[2] / 255,\n\t\t\t\t    c,\n\t\t\t\t    m,\n\t\t\t\t    y,\n\t\t\t\t    k;\n\n\t\t\t\tk = Math.min(1 - r, 1 - g, 1 - b);\n\t\t\t\tc = (1 - r - k) / (1 - k) || 0;\n\t\t\t\tm = (1 - g - k) / (1 - k) || 0;\n\t\t\t\ty = (1 - b - k) / (1 - k) || 0;\n\t\t\t\treturn [c * 100, m * 100, y * 100, k * 100];\n\t\t\t}\n\n\t\t\tfunction rgb2keyword(rgb) {\n\t\t\t\treturn reverseKeywords[JSON.stringify(rgb)];\n\t\t\t}\n\n\t\t\tfunction rgb2xyz(rgb) {\n\t\t\t\tvar r = rgb[0] / 255,\n\t\t\t\t    g = rgb[1] / 255,\n\t\t\t\t    b = rgb[2] / 255;\n\n\t\t\t\t// assume sRGB\n\t\t\t\tr = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;\n\t\t\t\tg = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;\n\t\t\t\tb = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;\n\n\t\t\t\tvar x = r * 0.4124 + g * 0.3576 + b * 0.1805;\n\t\t\t\tvar y = r * 0.2126 + g * 0.7152 + b * 0.0722;\n\t\t\t\tvar z = r * 0.0193 + g * 0.1192 + b * 0.9505;\n\n\t\t\t\treturn [x * 100, y * 100, z * 100];\n\t\t\t}\n\n\t\t\tfunction rgb2lab(rgb) {\n\t\t\t\tvar xyz = rgb2xyz(rgb),\n\t\t\t\t    x = xyz[0],\n\t\t\t\t    y = xyz[1],\n\t\t\t\t    z = xyz[2],\n\t\t\t\t    l,\n\t\t\t\t    a,\n\t\t\t\t    b;\n\n\t\t\t\tx /= 95.047;\n\t\t\t\ty /= 100;\n\t\t\t\tz /= 108.883;\n\n\t\t\t\tx = x > 0.008856 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;\n\t\t\t\ty = y > 0.008856 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;\n\t\t\t\tz = z > 0.008856 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;\n\n\t\t\t\tl = 116 * y - 16;\n\t\t\t\ta = 500 * (x - y);\n\t\t\t\tb = 200 * (y - z);\n\n\t\t\t\treturn [l, a, b];\n\t\t\t}\n\n\t\t\tfunction rgb2lch(args) {\n\t\t\t\treturn lab2lch(rgb2lab(args));\n\t\t\t}\n\n\t\t\tfunction hsl2rgb(hsl) {\n\t\t\t\tvar h = hsl[0] / 360,\n\t\t\t\t    s = hsl[1] / 100,\n\t\t\t\t    l = hsl[2] / 100,\n\t\t\t\t    t1,\n\t\t\t\t    t2,\n\t\t\t\t    t3,\n\t\t\t\t    rgb,\n\t\t\t\t    val;\n\n\t\t\t\tif (s == 0) {\n\t\t\t\t\tval = l * 255;\n\t\t\t\t\treturn [val, val, val];\n\t\t\t\t}\n\n\t\t\t\tif (l < 0.5) t2 = l * (1 + s);else t2 = l + s - l * s;\n\t\t\t\tt1 = 2 * l - t2;\n\n\t\t\t\trgb = [0, 0, 0];\n\t\t\t\tfor (var i = 0; i < 3; i++) {\n\t\t\t\t\tt3 = h + 1 / 3 * -(i - 1);\n\t\t\t\t\tt3 < 0 && t3++;\n\t\t\t\t\tt3 > 1 && t3--;\n\n\t\t\t\t\tif (6 * t3 < 1) val = t1 + (t2 - t1) * 6 * t3;else if (2 * t3 < 1) val = t2;else if (3 * t3 < 2) val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;else val = t1;\n\n\t\t\t\t\trgb[i] = val * 255;\n\t\t\t\t}\n\n\t\t\t\treturn rgb;\n\t\t\t}\n\n\t\t\tfunction hsl2hsv(hsl) {\n\t\t\t\tvar h = hsl[0],\n\t\t\t\t    s = hsl[1] / 100,\n\t\t\t\t    l = hsl[2] / 100,\n\t\t\t\t    sv,\n\t\t\t\t    v;\n\n\t\t\t\tif (l === 0) {\n\t\t\t\t\t// no need to do calc on black\n\t\t\t\t\t// also avoids divide by 0 error\n\t\t\t\t\treturn [0, 0, 0];\n\t\t\t\t}\n\n\t\t\t\tl *= 2;\n\t\t\t\ts *= l <= 1 ? l : 2 - l;\n\t\t\t\tv = (l + s) / 2;\n\t\t\t\tsv = 2 * s / (l + s);\n\t\t\t\treturn [h, sv * 100, v * 100];\n\t\t\t}\n\n\t\t\tfunction hsl2hwb(args) {\n\t\t\t\treturn rgb2hwb(hsl2rgb(args));\n\t\t\t}\n\n\t\t\tfunction hsl2cmyk(args) {\n\t\t\t\treturn rgb2cmyk(hsl2rgb(args));\n\t\t\t}\n\n\t\t\tfunction hsl2keyword(args) {\n\t\t\t\treturn rgb2keyword(hsl2rgb(args));\n\t\t\t}\n\n\t\t\tfunction hsv2rgb(hsv) {\n\t\t\t\tvar h = hsv[0] / 60,\n\t\t\t\t    s = hsv[1] / 100,\n\t\t\t\t    v = hsv[2] / 100,\n\t\t\t\t    hi = Math.floor(h) % 6;\n\n\t\t\t\tvar f = h - Math.floor(h),\n\t\t\t\t    p = 255 * v * (1 - s),\n\t\t\t\t    q = 255 * v * (1 - s * f),\n\t\t\t\t    t = 255 * v * (1 - s * (1 - f)),\n\t\t\t\t    v = 255 * v;\n\n\t\t\t\tswitch (hi) {\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\treturn [v, t, p];\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\treturn [q, v, p];\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\treturn [p, v, t];\n\t\t\t\t\tcase 3:\n\t\t\t\t\t\treturn [p, q, v];\n\t\t\t\t\tcase 4:\n\t\t\t\t\t\treturn [t, p, v];\n\t\t\t\t\tcase 5:\n\t\t\t\t\t\treturn [v, p, q];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction hsv2hsl(hsv) {\n\t\t\t\tvar h = hsv[0],\n\t\t\t\t    s = hsv[1] / 100,\n\t\t\t\t    v = hsv[2] / 100,\n\t\t\t\t    sl,\n\t\t\t\t    l;\n\n\t\t\t\tl = (2 - s) * v;\n\t\t\t\tsl = s * v;\n\t\t\t\tsl /= l <= 1 ? l : 2 - l;\n\t\t\t\tsl = sl || 0;\n\t\t\t\tl /= 2;\n\t\t\t\treturn [h, sl * 100, l * 100];\n\t\t\t}\n\n\t\t\tfunction hsv2hwb(args) {\n\t\t\t\treturn rgb2hwb(hsv2rgb(args));\n\t\t\t}\n\n\t\t\tfunction hsv2cmyk(args) {\n\t\t\t\treturn rgb2cmyk(hsv2rgb(args));\n\t\t\t}\n\n\t\t\tfunction hsv2keyword(args) {\n\t\t\t\treturn rgb2keyword(hsv2rgb(args));\n\t\t\t}\n\n\t\t\t// http://dev.w3.org/csswg/css-color/#hwb-to-rgb\n\t\t\tfunction hwb2rgb(hwb) {\n\t\t\t\tvar h = hwb[0] / 360,\n\t\t\t\t    wh = hwb[1] / 100,\n\t\t\t\t    bl = hwb[2] / 100,\n\t\t\t\t    ratio = wh + bl,\n\t\t\t\t    i,\n\t\t\t\t    v,\n\t\t\t\t    f,\n\t\t\t\t    n;\n\n\t\t\t\t// wh + bl cant be > 1\n\t\t\t\tif (ratio > 1) {\n\t\t\t\t\twh /= ratio;\n\t\t\t\t\tbl /= ratio;\n\t\t\t\t}\n\n\t\t\t\ti = Math.floor(6 * h);\n\t\t\t\tv = 1 - bl;\n\t\t\t\tf = 6 * h - i;\n\t\t\t\tif ((i & 0x01) != 0) {\n\t\t\t\t\tf = 1 - f;\n\t\t\t\t}\n\t\t\t\tn = wh + f * (v - wh); // linear interpolation\n\n\t\t\t\tswitch (i) {\n\t\t\t\t\tdefault:\n\t\t\t\t\tcase 6:\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\tr = v;g = n;b = wh;break;\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tr = n;g = v;b = wh;break;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tr = wh;g = v;b = n;break;\n\t\t\t\t\tcase 3:\n\t\t\t\t\t\tr = wh;g = n;b = v;break;\n\t\t\t\t\tcase 4:\n\t\t\t\t\t\tr = n;g = wh;b = v;break;\n\t\t\t\t\tcase 5:\n\t\t\t\t\t\tr = v;g = wh;b = n;break;\n\t\t\t\t}\n\n\t\t\t\treturn [r * 255, g * 255, b * 255];\n\t\t\t}\n\n\t\t\tfunction hwb2hsl(args) {\n\t\t\t\treturn rgb2hsl(hwb2rgb(args));\n\t\t\t}\n\n\t\t\tfunction hwb2hsv(args) {\n\t\t\t\treturn rgb2hsv(hwb2rgb(args));\n\t\t\t}\n\n\t\t\tfunction hwb2cmyk(args) {\n\t\t\t\treturn rgb2cmyk(hwb2rgb(args));\n\t\t\t}\n\n\t\t\tfunction hwb2keyword(args) {\n\t\t\t\treturn rgb2keyword(hwb2rgb(args));\n\t\t\t}\n\n\t\t\tfunction cmyk2rgb(cmyk) {\n\t\t\t\tvar c = cmyk[0] / 100,\n\t\t\t\t    m = cmyk[1] / 100,\n\t\t\t\t    y = cmyk[2] / 100,\n\t\t\t\t    k = cmyk[3] / 100,\n\t\t\t\t    r,\n\t\t\t\t    g,\n\t\t\t\t    b;\n\n\t\t\t\tr = 1 - Math.min(1, c * (1 - k) + k);\n\t\t\t\tg = 1 - Math.min(1, m * (1 - k) + k);\n\t\t\t\tb = 1 - Math.min(1, y * (1 - k) + k);\n\t\t\t\treturn [r * 255, g * 255, b * 255];\n\t\t\t}\n\n\t\t\tfunction cmyk2hsl(args) {\n\t\t\t\treturn rgb2hsl(cmyk2rgb(args));\n\t\t\t}\n\n\t\t\tfunction cmyk2hsv(args) {\n\t\t\t\treturn rgb2hsv(cmyk2rgb(args));\n\t\t\t}\n\n\t\t\tfunction cmyk2hwb(args) {\n\t\t\t\treturn rgb2hwb(cmyk2rgb(args));\n\t\t\t}\n\n\t\t\tfunction cmyk2keyword(args) {\n\t\t\t\treturn rgb2keyword(cmyk2rgb(args));\n\t\t\t}\n\n\t\t\tfunction xyz2rgb(xyz) {\n\t\t\t\tvar x = xyz[0] / 100,\n\t\t\t\t    y = xyz[1] / 100,\n\t\t\t\t    z = xyz[2] / 100,\n\t\t\t\t    r,\n\t\t\t\t    g,\n\t\t\t\t    b;\n\n\t\t\t\tr = x * 3.2406 + y * -1.5372 + z * -0.4986;\n\t\t\t\tg = x * -0.9689 + y * 1.8758 + z * 0.0415;\n\t\t\t\tb = x * 0.0557 + y * -0.2040 + z * 1.0570;\n\n\t\t\t\t// assume sRGB\n\t\t\t\tr = r > 0.0031308 ? 1.055 * Math.pow(r, 1.0 / 2.4) - 0.055 : r = r * 12.92;\n\n\t\t\t\tg = g > 0.0031308 ? 1.055 * Math.pow(g, 1.0 / 2.4) - 0.055 : g = g * 12.92;\n\n\t\t\t\tb = b > 0.0031308 ? 1.055 * Math.pow(b, 1.0 / 2.4) - 0.055 : b = b * 12.92;\n\n\t\t\t\tr = Math.min(Math.max(0, r), 1);\n\t\t\t\tg = Math.min(Math.max(0, g), 1);\n\t\t\t\tb = Math.min(Math.max(0, b), 1);\n\n\t\t\t\treturn [r * 255, g * 255, b * 255];\n\t\t\t}\n\n\t\t\tfunction xyz2lab(xyz) {\n\t\t\t\tvar x = xyz[0],\n\t\t\t\t    y = xyz[1],\n\t\t\t\t    z = xyz[2],\n\t\t\t\t    l,\n\t\t\t\t    a,\n\t\t\t\t    b;\n\n\t\t\t\tx /= 95.047;\n\t\t\t\ty /= 100;\n\t\t\t\tz /= 108.883;\n\n\t\t\t\tx = x > 0.008856 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;\n\t\t\t\ty = y > 0.008856 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;\n\t\t\t\tz = z > 0.008856 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;\n\n\t\t\t\tl = 116 * y - 16;\n\t\t\t\ta = 500 * (x - y);\n\t\t\t\tb = 200 * (y - z);\n\n\t\t\t\treturn [l, a, b];\n\t\t\t}\n\n\t\t\tfunction xyz2lch(args) {\n\t\t\t\treturn lab2lch(xyz2lab(args));\n\t\t\t}\n\n\t\t\tfunction lab2xyz(lab) {\n\t\t\t\tvar l = lab[0],\n\t\t\t\t    a = lab[1],\n\t\t\t\t    b = lab[2],\n\t\t\t\t    x,\n\t\t\t\t    y,\n\t\t\t\t    z,\n\t\t\t\t    y2;\n\n\t\t\t\tif (l <= 8) {\n\t\t\t\t\ty = l * 100 / 903.3;\n\t\t\t\t\ty2 = 7.787 * (y / 100) + 16 / 116;\n\t\t\t\t} else {\n\t\t\t\t\ty = 100 * Math.pow((l + 16) / 116, 3);\n\t\t\t\t\ty2 = Math.pow(y / 100, 1 / 3);\n\t\t\t\t}\n\n\t\t\t\tx = x / 95.047 <= 0.008856 ? x = 95.047 * (a / 500 + y2 - 16 / 116) / 7.787 : 95.047 * Math.pow(a / 500 + y2, 3);\n\n\t\t\t\tz = z / 108.883 <= 0.008859 ? z = 108.883 * (y2 - b / 200 - 16 / 116) / 7.787 : 108.883 * Math.pow(y2 - b / 200, 3);\n\n\t\t\t\treturn [x, y, z];\n\t\t\t}\n\n\t\t\tfunction lab2lch(lab) {\n\t\t\t\tvar l = lab[0],\n\t\t\t\t    a = lab[1],\n\t\t\t\t    b = lab[2],\n\t\t\t\t    hr,\n\t\t\t\t    h,\n\t\t\t\t    c;\n\n\t\t\t\thr = Math.atan2(b, a);\n\t\t\t\th = hr * 360 / 2 / Math.PI;\n\t\t\t\tif (h < 0) {\n\t\t\t\t\th += 360;\n\t\t\t\t}\n\t\t\t\tc = Math.sqrt(a * a + b * b);\n\t\t\t\treturn [l, c, h];\n\t\t\t}\n\n\t\t\tfunction lab2rgb(args) {\n\t\t\t\treturn xyz2rgb(lab2xyz(args));\n\t\t\t}\n\n\t\t\tfunction lch2lab(lch) {\n\t\t\t\tvar l = lch[0],\n\t\t\t\t    c = lch[1],\n\t\t\t\t    h = lch[2],\n\t\t\t\t    a,\n\t\t\t\t    b,\n\t\t\t\t    hr;\n\n\t\t\t\thr = h / 360 * 2 * Math.PI;\n\t\t\t\ta = c * Math.cos(hr);\n\t\t\t\tb = c * Math.sin(hr);\n\t\t\t\treturn [l, a, b];\n\t\t\t}\n\n\t\t\tfunction lch2xyz(args) {\n\t\t\t\treturn lab2xyz(lch2lab(args));\n\t\t\t}\n\n\t\t\tfunction lch2rgb(args) {\n\t\t\t\treturn lab2rgb(lch2lab(args));\n\t\t\t}\n\n\t\t\tfunction keyword2rgb(keyword) {\n\t\t\t\treturn cssKeywords[keyword];\n\t\t\t}\n\n\t\t\tfunction keyword2hsl(args) {\n\t\t\t\treturn rgb2hsl(keyword2rgb(args));\n\t\t\t}\n\n\t\t\tfunction keyword2hsv(args) {\n\t\t\t\treturn rgb2hsv(keyword2rgb(args));\n\t\t\t}\n\n\t\t\tfunction keyword2hwb(args) {\n\t\t\t\treturn rgb2hwb(keyword2rgb(args));\n\t\t\t}\n\n\t\t\tfunction keyword2cmyk(args) {\n\t\t\t\treturn rgb2cmyk(keyword2rgb(args));\n\t\t\t}\n\n\t\t\tfunction keyword2lab(args) {\n\t\t\t\treturn rgb2lab(keyword2rgb(args));\n\t\t\t}\n\n\t\t\tfunction keyword2xyz(args) {\n\t\t\t\treturn rgb2xyz(keyword2rgb(args));\n\t\t\t}\n\n\t\t\tvar cssKeywords = {\n\t\t\t\taliceblue: [240, 248, 255],\n\t\t\t\tantiquewhite: [250, 235, 215],\n\t\t\t\taqua: [0, 255, 255],\n\t\t\t\taquamarine: [127, 255, 212],\n\t\t\t\tazure: [240, 255, 255],\n\t\t\t\tbeige: [245, 245, 220],\n\t\t\t\tbisque: [255, 228, 196],\n\t\t\t\tblack: [0, 0, 0],\n\t\t\t\tblanchedalmond: [255, 235, 205],\n\t\t\t\tblue: [0, 0, 255],\n\t\t\t\tblueviolet: [138, 43, 226],\n\t\t\t\tbrown: [165, 42, 42],\n\t\t\t\tburlywood: [222, 184, 135],\n\t\t\t\tcadetblue: [95, 158, 160],\n\t\t\t\tchartreuse: [127, 255, 0],\n\t\t\t\tchocolate: [210, 105, 30],\n\t\t\t\tcoral: [255, 127, 80],\n\t\t\t\tcornflowerblue: [100, 149, 237],\n\t\t\t\tcornsilk: [255, 248, 220],\n\t\t\t\tcrimson: [220, 20, 60],\n\t\t\t\tcyan: [0, 255, 255],\n\t\t\t\tdarkblue: [0, 0, 139],\n\t\t\t\tdarkcyan: [0, 139, 139],\n\t\t\t\tdarkgoldenrod: [184, 134, 11],\n\t\t\t\tdarkgray: [169, 169, 169],\n\t\t\t\tdarkgreen: [0, 100, 0],\n\t\t\t\tdarkgrey: [169, 169, 169],\n\t\t\t\tdarkkhaki: [189, 183, 107],\n\t\t\t\tdarkmagenta: [139, 0, 139],\n\t\t\t\tdarkolivegreen: [85, 107, 47],\n\t\t\t\tdarkorange: [255, 140, 0],\n\t\t\t\tdarkorchid: [153, 50, 204],\n\t\t\t\tdarkred: [139, 0, 0],\n\t\t\t\tdarksalmon: [233, 150, 122],\n\t\t\t\tdarkseagreen: [143, 188, 143],\n\t\t\t\tdarkslateblue: [72, 61, 139],\n\t\t\t\tdarkslategray: [47, 79, 79],\n\t\t\t\tdarkslategrey: [47, 79, 79],\n\t\t\t\tdarkturquoise: [0, 206, 209],\n\t\t\t\tdarkviolet: [148, 0, 211],\n\t\t\t\tdeeppink: [255, 20, 147],\n\t\t\t\tdeepskyblue: [0, 191, 255],\n\t\t\t\tdimgray: [105, 105, 105],\n\t\t\t\tdimgrey: [105, 105, 105],\n\t\t\t\tdodgerblue: [30, 144, 255],\n\t\t\t\tfirebrick: [178, 34, 34],\n\t\t\t\tfloralwhite: [255, 250, 240],\n\t\t\t\tforestgreen: [34, 139, 34],\n\t\t\t\tfuchsia: [255, 0, 255],\n\t\t\t\tgainsboro: [220, 220, 220],\n\t\t\t\tghostwhite: [248, 248, 255],\n\t\t\t\tgold: [255, 215, 0],\n\t\t\t\tgoldenrod: [218, 165, 32],\n\t\t\t\tgray: [128, 128, 128],\n\t\t\t\tgreen: [0, 128, 0],\n\t\t\t\tgreenyellow: [173, 255, 47],\n\t\t\t\tgrey: [128, 128, 128],\n\t\t\t\thoneydew: [240, 255, 240],\n\t\t\t\thotpink: [255, 105, 180],\n\t\t\t\tindianred: [205, 92, 92],\n\t\t\t\tindigo: [75, 0, 130],\n\t\t\t\tivory: [255, 255, 240],\n\t\t\t\tkhaki: [240, 230, 140],\n\t\t\t\tlavender: [230, 230, 250],\n\t\t\t\tlavenderblush: [255, 240, 245],\n\t\t\t\tlawngreen: [124, 252, 0],\n\t\t\t\tlemonchiffon: [255, 250, 205],\n\t\t\t\tlightblue: [173, 216, 230],\n\t\t\t\tlightcoral: [240, 128, 128],\n\t\t\t\tlightcyan: [224, 255, 255],\n\t\t\t\tlightgoldenrodyellow: [250, 250, 210],\n\t\t\t\tlightgray: [211, 211, 211],\n\t\t\t\tlightgreen: [144, 238, 144],\n\t\t\t\tlightgrey: [211, 211, 211],\n\t\t\t\tlightpink: [255, 182, 193],\n\t\t\t\tlightsalmon: [255, 160, 122],\n\t\t\t\tlightseagreen: [32, 178, 170],\n\t\t\t\tlightskyblue: [135, 206, 250],\n\t\t\t\tlightslategray: [119, 136, 153],\n\t\t\t\tlightslategrey: [119, 136, 153],\n\t\t\t\tlightsteelblue: [176, 196, 222],\n\t\t\t\tlightyellow: [255, 255, 224],\n\t\t\t\tlime: [0, 255, 0],\n\t\t\t\tlimegreen: [50, 205, 50],\n\t\t\t\tlinen: [250, 240, 230],\n\t\t\t\tmagenta: [255, 0, 255],\n\t\t\t\tmaroon: [128, 0, 0],\n\t\t\t\tmediumaquamarine: [102, 205, 170],\n\t\t\t\tmediumblue: [0, 0, 205],\n\t\t\t\tmediumorchid: [186, 85, 211],\n\t\t\t\tmediumpurple: [147, 112, 219],\n\t\t\t\tmediumseagreen: [60, 179, 113],\n\t\t\t\tmediumslateblue: [123, 104, 238],\n\t\t\t\tmediumspringgreen: [0, 250, 154],\n\t\t\t\tmediumturquoise: [72, 209, 204],\n\t\t\t\tmediumvioletred: [199, 21, 133],\n\t\t\t\tmidnightblue: [25, 25, 112],\n\t\t\t\tmintcream: [245, 255, 250],\n\t\t\t\tmistyrose: [255, 228, 225],\n\t\t\t\tmoccasin: [255, 228, 181],\n\t\t\t\tnavajowhite: [255, 222, 173],\n\t\t\t\tnavy: [0, 0, 128],\n\t\t\t\toldlace: [253, 245, 230],\n\t\t\t\tolive: [128, 128, 0],\n\t\t\t\tolivedrab: [107, 142, 35],\n\t\t\t\torange: [255, 165, 0],\n\t\t\t\torangered: [255, 69, 0],\n\t\t\t\torchid: [218, 112, 214],\n\t\t\t\tpalegoldenrod: [238, 232, 170],\n\t\t\t\tpalegreen: [152, 251, 152],\n\t\t\t\tpaleturquoise: [175, 238, 238],\n\t\t\t\tpalevioletred: [219, 112, 147],\n\t\t\t\tpapayawhip: [255, 239, 213],\n\t\t\t\tpeachpuff: [255, 218, 185],\n\t\t\t\tperu: [205, 133, 63],\n\t\t\t\tpink: [255, 192, 203],\n\t\t\t\tplum: [221, 160, 221],\n\t\t\t\tpowderblue: [176, 224, 230],\n\t\t\t\tpurple: [128, 0, 128],\n\t\t\t\trebeccapurple: [102, 51, 153],\n\t\t\t\tred: [255, 0, 0],\n\t\t\t\trosybrown: [188, 143, 143],\n\t\t\t\troyalblue: [65, 105, 225],\n\t\t\t\tsaddlebrown: [139, 69, 19],\n\t\t\t\tsalmon: [250, 128, 114],\n\t\t\t\tsandybrown: [244, 164, 96],\n\t\t\t\tseagreen: [46, 139, 87],\n\t\t\t\tseashell: [255, 245, 238],\n\t\t\t\tsienna: [160, 82, 45],\n\t\t\t\tsilver: [192, 192, 192],\n\t\t\t\tskyblue: [135, 206, 235],\n\t\t\t\tslateblue: [106, 90, 205],\n\t\t\t\tslategray: [112, 128, 144],\n\t\t\t\tslategrey: [112, 128, 144],\n\t\t\t\tsnow: [255, 250, 250],\n\t\t\t\tspringgreen: [0, 255, 127],\n\t\t\t\tsteelblue: [70, 130, 180],\n\t\t\t\ttan: [210, 180, 140],\n\t\t\t\tteal: [0, 128, 128],\n\t\t\t\tthistle: [216, 191, 216],\n\t\t\t\ttomato: [255, 99, 71],\n\t\t\t\tturquoise: [64, 224, 208],\n\t\t\t\tviolet: [238, 130, 238],\n\t\t\t\twheat: [245, 222, 179],\n\t\t\t\twhite: [255, 255, 255],\n\t\t\t\twhitesmoke: [245, 245, 245],\n\t\t\t\tyellow: [255, 255, 0],\n\t\t\t\tyellowgreen: [154, 205, 50]\n\t\t\t};\n\n\t\t\tvar reverseKeywords = {};\n\t\t\tfor (var key in cssKeywords) {\n\t\t\t\treverseKeywords[JSON.stringify(cssKeywords[key])] = key;\n\t\t\t}\n\t\t}, {}], 5: [function (require, module, exports) {\n\t\t\tvar conversions = require(4);\n\n\t\t\tvar convert = function convert() {\n\t\t\t\treturn new Converter();\n\t\t\t};\n\n\t\t\tfor (var func in conversions) {\n\t\t\t\t// export Raw versions\n\t\t\t\tconvert[func + \"Raw\"] = function (func) {\n\t\t\t\t\t// accept array or plain args\n\t\t\t\t\treturn function (arg) {\n\t\t\t\t\t\tif (typeof arg == \"number\") arg = Array.prototype.slice.call(arguments);\n\t\t\t\t\t\treturn conversions[func](arg);\n\t\t\t\t\t};\n\t\t\t\t}(func);\n\n\t\t\t\tvar pair = /(\\w+)2(\\w+)/.exec(func),\n\t\t\t\t    from = pair[1],\n\t\t\t\t    to = pair[2];\n\n\t\t\t\t// export rgb2hsl and [\"rgb\"][\"hsl\"]\n\t\t\t\tconvert[from] = convert[from] || {};\n\n\t\t\t\tconvert[from][to] = convert[func] = function (func) {\n\t\t\t\t\treturn function (arg) {\n\t\t\t\t\t\tif (typeof arg == \"number\") arg = Array.prototype.slice.call(arguments);\n\n\t\t\t\t\t\tvar val = conversions[func](arg);\n\t\t\t\t\t\tif (typeof val == \"string\" || val === undefined) return val; // keyword\n\n\t\t\t\t\t\tfor (var i = 0; i < val.length; i++) {\n\t\t\t\t\t\t\tval[i] = Math.round(val[i]);\n\t\t\t\t\t\t}return val;\n\t\t\t\t\t};\n\t\t\t\t}(func);\n\t\t\t}\n\n\t\t\t/* Converter does lazy conversion and caching */\n\t\t\tvar Converter = function Converter() {\n\t\t\t\tthis.convs = {};\n\t\t\t};\n\n\t\t\t/* Either get the values for a space or\n     set the values for a space, depending on args */\n\t\t\tConverter.prototype.routeSpace = function (space, args) {\n\t\t\t\tvar values = args[0];\n\t\t\t\tif (values === undefined) {\n\t\t\t\t\t// color.rgb()\n\t\t\t\t\treturn this.getValues(space);\n\t\t\t\t}\n\t\t\t\t// color.rgb(10, 10, 10)\n\t\t\t\tif (typeof values == \"number\") {\n\t\t\t\t\tvalues = Array.prototype.slice.call(args);\n\t\t\t\t}\n\n\t\t\t\treturn this.setValues(space, values);\n\t\t\t};\n\n\t\t\t/* Set the values for a space, invalidating cache */\n\t\t\tConverter.prototype.setValues = function (space, values) {\n\t\t\t\tthis.space = space;\n\t\t\t\tthis.convs = {};\n\t\t\t\tthis.convs[space] = values;\n\t\t\t\treturn this;\n\t\t\t};\n\n\t\t\t/* Get the values for a space. If there's already\n     a conversion for the space, fetch it, otherwise\n     compute it */\n\t\t\tConverter.prototype.getValues = function (space) {\n\t\t\t\tvar vals = this.convs[space];\n\t\t\t\tif (!vals) {\n\t\t\t\t\tvar fspace = this.space,\n\t\t\t\t\t    from = this.convs[fspace];\n\t\t\t\t\tvals = convert[fspace][space](from);\n\n\t\t\t\t\tthis.convs[space] = vals;\n\t\t\t\t}\n\t\t\t\treturn vals;\n\t\t\t};\n\n\t\t\t[\"rgb\", \"hsl\", \"hsv\", \"cmyk\", \"keyword\"].forEach(function (space) {\n\t\t\t\tConverter.prototype[space] = function (vals) {\n\t\t\t\t\treturn this.routeSpace(space, arguments);\n\t\t\t\t};\n\t\t\t});\n\n\t\t\tmodule.exports = convert;\n\t\t}, { \"4\": 4 }], 6: [function (require, module, exports) {\n\t\t\tmodule.exports = {\n\t\t\t\t\"aliceblue\": [240, 248, 255],\n\t\t\t\t\"antiquewhite\": [250, 235, 215],\n\t\t\t\t\"aqua\": [0, 255, 255],\n\t\t\t\t\"aquamarine\": [127, 255, 212],\n\t\t\t\t\"azure\": [240, 255, 255],\n\t\t\t\t\"beige\": [245, 245, 220],\n\t\t\t\t\"bisque\": [255, 228, 196],\n\t\t\t\t\"black\": [0, 0, 0],\n\t\t\t\t\"blanchedalmond\": [255, 235, 205],\n\t\t\t\t\"blue\": [0, 0, 255],\n\t\t\t\t\"blueviolet\": [138, 43, 226],\n\t\t\t\t\"brown\": [165, 42, 42],\n\t\t\t\t\"burlywood\": [222, 184, 135],\n\t\t\t\t\"cadetblue\": [95, 158, 160],\n\t\t\t\t\"chartreuse\": [127, 255, 0],\n\t\t\t\t\"chocolate\": [210, 105, 30],\n\t\t\t\t\"coral\": [255, 127, 80],\n\t\t\t\t\"cornflowerblue\": [100, 149, 237],\n\t\t\t\t\"cornsilk\": [255, 248, 220],\n\t\t\t\t\"crimson\": [220, 20, 60],\n\t\t\t\t\"cyan\": [0, 255, 255],\n\t\t\t\t\"darkblue\": [0, 0, 139],\n\t\t\t\t\"darkcyan\": [0, 139, 139],\n\t\t\t\t\"darkgoldenrod\": [184, 134, 11],\n\t\t\t\t\"darkgray\": [169, 169, 169],\n\t\t\t\t\"darkgreen\": [0, 100, 0],\n\t\t\t\t\"darkgrey\": [169, 169, 169],\n\t\t\t\t\"darkkhaki\": [189, 183, 107],\n\t\t\t\t\"darkmagenta\": [139, 0, 139],\n\t\t\t\t\"darkolivegreen\": [85, 107, 47],\n\t\t\t\t\"darkorange\": [255, 140, 0],\n\t\t\t\t\"darkorchid\": [153, 50, 204],\n\t\t\t\t\"darkred\": [139, 0, 0],\n\t\t\t\t\"darksalmon\": [233, 150, 122],\n\t\t\t\t\"darkseagreen\": [143, 188, 143],\n\t\t\t\t\"darkslateblue\": [72, 61, 139],\n\t\t\t\t\"darkslategray\": [47, 79, 79],\n\t\t\t\t\"darkslategrey\": [47, 79, 79],\n\t\t\t\t\"darkturquoise\": [0, 206, 209],\n\t\t\t\t\"darkviolet\": [148, 0, 211],\n\t\t\t\t\"deeppink\": [255, 20, 147],\n\t\t\t\t\"deepskyblue\": [0, 191, 255],\n\t\t\t\t\"dimgray\": [105, 105, 105],\n\t\t\t\t\"dimgrey\": [105, 105, 105],\n\t\t\t\t\"dodgerblue\": [30, 144, 255],\n\t\t\t\t\"firebrick\": [178, 34, 34],\n\t\t\t\t\"floralwhite\": [255, 250, 240],\n\t\t\t\t\"forestgreen\": [34, 139, 34],\n\t\t\t\t\"fuchsia\": [255, 0, 255],\n\t\t\t\t\"gainsboro\": [220, 220, 220],\n\t\t\t\t\"ghostwhite\": [248, 248, 255],\n\t\t\t\t\"gold\": [255, 215, 0],\n\t\t\t\t\"goldenrod\": [218, 165, 32],\n\t\t\t\t\"gray\": [128, 128, 128],\n\t\t\t\t\"green\": [0, 128, 0],\n\t\t\t\t\"greenyellow\": [173, 255, 47],\n\t\t\t\t\"grey\": [128, 128, 128],\n\t\t\t\t\"honeydew\": [240, 255, 240],\n\t\t\t\t\"hotpink\": [255, 105, 180],\n\t\t\t\t\"indianred\": [205, 92, 92],\n\t\t\t\t\"indigo\": [75, 0, 130],\n\t\t\t\t\"ivory\": [255, 255, 240],\n\t\t\t\t\"khaki\": [240, 230, 140],\n\t\t\t\t\"lavender\": [230, 230, 250],\n\t\t\t\t\"lavenderblush\": [255, 240, 245],\n\t\t\t\t\"lawngreen\": [124, 252, 0],\n\t\t\t\t\"lemonchiffon\": [255, 250, 205],\n\t\t\t\t\"lightblue\": [173, 216, 230],\n\t\t\t\t\"lightcoral\": [240, 128, 128],\n\t\t\t\t\"lightcyan\": [224, 255, 255],\n\t\t\t\t\"lightgoldenrodyellow\": [250, 250, 210],\n\t\t\t\t\"lightgray\": [211, 211, 211],\n\t\t\t\t\"lightgreen\": [144, 238, 144],\n\t\t\t\t\"lightgrey\": [211, 211, 211],\n\t\t\t\t\"lightpink\": [255, 182, 193],\n\t\t\t\t\"lightsalmon\": [255, 160, 122],\n\t\t\t\t\"lightseagreen\": [32, 178, 170],\n\t\t\t\t\"lightskyblue\": [135, 206, 250],\n\t\t\t\t\"lightslategray\": [119, 136, 153],\n\t\t\t\t\"lightslategrey\": [119, 136, 153],\n\t\t\t\t\"lightsteelblue\": [176, 196, 222],\n\t\t\t\t\"lightyellow\": [255, 255, 224],\n\t\t\t\t\"lime\": [0, 255, 0],\n\t\t\t\t\"limegreen\": [50, 205, 50],\n\t\t\t\t\"linen\": [250, 240, 230],\n\t\t\t\t\"magenta\": [255, 0, 255],\n\t\t\t\t\"maroon\": [128, 0, 0],\n\t\t\t\t\"mediumaquamarine\": [102, 205, 170],\n\t\t\t\t\"mediumblue\": [0, 0, 205],\n\t\t\t\t\"mediumorchid\": [186, 85, 211],\n\t\t\t\t\"mediumpurple\": [147, 112, 219],\n\t\t\t\t\"mediumseagreen\": [60, 179, 113],\n\t\t\t\t\"mediumslateblue\": [123, 104, 238],\n\t\t\t\t\"mediumspringgreen\": [0, 250, 154],\n\t\t\t\t\"mediumturquoise\": [72, 209, 204],\n\t\t\t\t\"mediumvioletred\": [199, 21, 133],\n\t\t\t\t\"midnightblue\": [25, 25, 112],\n\t\t\t\t\"mintcream\": [245, 255, 250],\n\t\t\t\t\"mistyrose\": [255, 228, 225],\n\t\t\t\t\"moccasin\": [255, 228, 181],\n\t\t\t\t\"navajowhite\": [255, 222, 173],\n\t\t\t\t\"navy\": [0, 0, 128],\n\t\t\t\t\"oldlace\": [253, 245, 230],\n\t\t\t\t\"olive\": [128, 128, 0],\n\t\t\t\t\"olivedrab\": [107, 142, 35],\n\t\t\t\t\"orange\": [255, 165, 0],\n\t\t\t\t\"orangered\": [255, 69, 0],\n\t\t\t\t\"orchid\": [218, 112, 214],\n\t\t\t\t\"palegoldenrod\": [238, 232, 170],\n\t\t\t\t\"palegreen\": [152, 251, 152],\n\t\t\t\t\"paleturquoise\": [175, 238, 238],\n\t\t\t\t\"palevioletred\": [219, 112, 147],\n\t\t\t\t\"papayawhip\": [255, 239, 213],\n\t\t\t\t\"peachpuff\": [255, 218, 185],\n\t\t\t\t\"peru\": [205, 133, 63],\n\t\t\t\t\"pink\": [255, 192, 203],\n\t\t\t\t\"plum\": [221, 160, 221],\n\t\t\t\t\"powderblue\": [176, 224, 230],\n\t\t\t\t\"purple\": [128, 0, 128],\n\t\t\t\t\"rebeccapurple\": [102, 51, 153],\n\t\t\t\t\"red\": [255, 0, 0],\n\t\t\t\t\"rosybrown\": [188, 143, 143],\n\t\t\t\t\"royalblue\": [65, 105, 225],\n\t\t\t\t\"saddlebrown\": [139, 69, 19],\n\t\t\t\t\"salmon\": [250, 128, 114],\n\t\t\t\t\"sandybrown\": [244, 164, 96],\n\t\t\t\t\"seagreen\": [46, 139, 87],\n\t\t\t\t\"seashell\": [255, 245, 238],\n\t\t\t\t\"sienna\": [160, 82, 45],\n\t\t\t\t\"silver\": [192, 192, 192],\n\t\t\t\t\"skyblue\": [135, 206, 235],\n\t\t\t\t\"slateblue\": [106, 90, 205],\n\t\t\t\t\"slategray\": [112, 128, 144],\n\t\t\t\t\"slategrey\": [112, 128, 144],\n\t\t\t\t\"snow\": [255, 250, 250],\n\t\t\t\t\"springgreen\": [0, 255, 127],\n\t\t\t\t\"steelblue\": [70, 130, 180],\n\t\t\t\t\"tan\": [210, 180, 140],\n\t\t\t\t\"teal\": [0, 128, 128],\n\t\t\t\t\"thistle\": [216, 191, 216],\n\t\t\t\t\"tomato\": [255, 99, 71],\n\t\t\t\t\"turquoise\": [64, 224, 208],\n\t\t\t\t\"violet\": [238, 130, 238],\n\t\t\t\t\"wheat\": [245, 222, 179],\n\t\t\t\t\"white\": [255, 255, 255],\n\t\t\t\t\"whitesmoke\": [245, 245, 245],\n\t\t\t\t\"yellow\": [255, 255, 0],\n\t\t\t\t\"yellowgreen\": [154, 205, 50]\n\t\t\t};\n\t\t}, {}], 7: [function (require, module, exports) {\n\t\t\t/**\n    * @namespace Chart\n    */\n\t\t\tvar Chart = require(28)();\n\n\t\t\trequire(26)(Chart);\n\t\t\trequire(42)(Chart);\n\t\t\trequire(22)(Chart);\n\t\t\trequire(31)(Chart);\n\t\t\trequire(25)(Chart);\n\t\t\trequire(21)(Chart);\n\t\t\trequire(23)(Chart);\n\t\t\trequire(24)(Chart);\n\t\t\trequire(29)(Chart);\n\t\t\trequire(33)(Chart);\n\t\t\trequire(34)(Chart);\n\t\t\trequire(32)(Chart);\n\t\t\trequire(35)(Chart);\n\t\t\trequire(30)(Chart);\n\t\t\trequire(27)(Chart);\n\t\t\trequire(36)(Chart);\n\n\t\t\trequire(37)(Chart);\n\t\t\trequire(38)(Chart);\n\t\t\trequire(39)(Chart);\n\t\t\trequire(40)(Chart);\n\n\t\t\trequire(45)(Chart);\n\t\t\trequire(43)(Chart);\n\t\t\trequire(44)(Chart);\n\t\t\trequire(46)(Chart);\n\t\t\trequire(47)(Chart);\n\t\t\trequire(48)(Chart);\n\n\t\t\t// Controllers must be loaded after elements\n\t\t\t// See Chart.core.datasetController.dataElementType\n\t\t\trequire(15)(Chart);\n\t\t\trequire(16)(Chart);\n\t\t\trequire(17)(Chart);\n\t\t\trequire(18)(Chart);\n\t\t\trequire(19)(Chart);\n\t\t\trequire(20)(Chart);\n\n\t\t\trequire(8)(Chart);\n\t\t\trequire(9)(Chart);\n\t\t\trequire(10)(Chart);\n\t\t\trequire(11)(Chart);\n\t\t\trequire(12)(Chart);\n\t\t\trequire(13)(Chart);\n\t\t\trequire(14)(Chart);\n\n\t\t\twindow.Chart = module.exports = Chart;\n\t\t}, { \"10\": 10, \"11\": 11, \"12\": 12, \"13\": 13, \"14\": 14, \"15\": 15, \"16\": 16, \"17\": 17, \"18\": 18, \"19\": 19, \"20\": 20, \"21\": 21, \"22\": 22, \"23\": 23, \"24\": 24, \"25\": 25, \"26\": 26, \"27\": 27, \"28\": 28, \"29\": 29, \"30\": 30, \"31\": 31, \"32\": 32, \"33\": 33, \"34\": 34, \"35\": 35, \"36\": 36, \"37\": 37, \"38\": 38, \"39\": 39, \"40\": 40, \"42\": 42, \"43\": 43, \"44\": 44, \"45\": 45, \"46\": 46, \"47\": 47, \"48\": 48, \"8\": 8, \"9\": 9 }], 8: [function (require, module, exports) {\n\t\t\t'use strict';\n\n\t\t\tmodule.exports = function (Chart) {\n\n\t\t\t\tChart.Bar = function (context, config) {\n\t\t\t\t\tconfig.type = 'bar';\n\n\t\t\t\t\treturn new Chart(context, config);\n\t\t\t\t};\n\t\t\t};\n\t\t}, {}], 9: [function (require, module, exports) {\n\t\t\t'use strict';\n\n\t\t\tmodule.exports = function (Chart) {\n\n\t\t\t\tChart.Bubble = function (context, config) {\n\t\t\t\t\tconfig.type = 'bubble';\n\t\t\t\t\treturn new Chart(context, config);\n\t\t\t\t};\n\t\t\t};\n\t\t}, {}], 10: [function (require, module, exports) {\n\t\t\t'use strict';\n\n\t\t\tmodule.exports = function (Chart) {\n\n\t\t\t\tChart.Doughnut = function (context, config) {\n\t\t\t\t\tconfig.type = 'doughnut';\n\n\t\t\t\t\treturn new Chart(context, config);\n\t\t\t\t};\n\t\t\t};\n\t\t}, {}], 11: [function (require, module, exports) {\n\t\t\t'use strict';\n\n\t\t\tmodule.exports = function (Chart) {\n\n\t\t\t\tChart.Line = function (context, config) {\n\t\t\t\t\tconfig.type = 'line';\n\n\t\t\t\t\treturn new Chart(context, config);\n\t\t\t\t};\n\t\t\t};\n\t\t}, {}], 12: [function (require, module, exports) {\n\t\t\t'use strict';\n\n\t\t\tmodule.exports = function (Chart) {\n\n\t\t\t\tChart.PolarArea = function (context, config) {\n\t\t\t\t\tconfig.type = 'polarArea';\n\n\t\t\t\t\treturn new Chart(context, config);\n\t\t\t\t};\n\t\t\t};\n\t\t}, {}], 13: [function (require, module, exports) {\n\t\t\t'use strict';\n\n\t\t\tmodule.exports = function (Chart) {\n\n\t\t\t\tChart.Radar = function (context, config) {\n\t\t\t\t\tconfig.type = 'radar';\n\n\t\t\t\t\treturn new Chart(context, config);\n\t\t\t\t};\n\t\t\t};\n\t\t}, {}], 14: [function (require, module, exports) {\n\t\t\t'use strict';\n\n\t\t\tmodule.exports = function (Chart) {\n\n\t\t\t\tvar defaultConfig = {\n\t\t\t\t\thover: {\n\t\t\t\t\t\tmode: 'single'\n\t\t\t\t\t},\n\n\t\t\t\t\tscales: {\n\t\t\t\t\t\txAxes: [{\n\t\t\t\t\t\t\ttype: 'linear', // scatter should not use a category axis\n\t\t\t\t\t\t\tposition: 'bottom',\n\t\t\t\t\t\t\tid: 'x-axis-1' // need an ID so datasets can reference the scale\n\t\t\t\t\t\t}],\n\t\t\t\t\t\tyAxes: [{\n\t\t\t\t\t\t\ttype: 'linear',\n\t\t\t\t\t\t\tposition: 'left',\n\t\t\t\t\t\t\tid: 'y-axis-1'\n\t\t\t\t\t\t}]\n\t\t\t\t\t},\n\n\t\t\t\t\ttooltips: {\n\t\t\t\t\t\tcallbacks: {\n\t\t\t\t\t\t\ttitle: function title() {\n\t\t\t\t\t\t\t\t// Title doesn't make sense for scatter since we format the data as a point\n\t\t\t\t\t\t\t\treturn '';\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tlabel: function label(tooltipItem) {\n\t\t\t\t\t\t\t\treturn '(' + tooltipItem.xLabel + ', ' + tooltipItem.yLabel + ')';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\t// Register the default config for this type\n\t\t\t\tChart.defaults.scatter = defaultConfig;\n\n\t\t\t\t// Scatter charts use line controllers\n\t\t\t\tChart.controllers.scatter = Chart.controllers.line;\n\n\t\t\t\tChart.Scatter = function (context, config) {\n\t\t\t\t\tconfig.type = 'scatter';\n\t\t\t\t\treturn new Chart(context, config);\n\t\t\t\t};\n\t\t\t};\n\t\t}, {}], 15: [function (require, module, exports) {\n\t\t\t'use strict';\n\n\t\t\tmodule.exports = function (Chart) {\n\n\t\t\t\tvar helpers = Chart.helpers;\n\n\t\t\t\tChart.defaults.bar = {\n\t\t\t\t\thover: {\n\t\t\t\t\t\tmode: 'label'\n\t\t\t\t\t},\n\n\t\t\t\t\tscales: {\n\t\t\t\t\t\txAxes: [{\n\t\t\t\t\t\t\ttype: 'category',\n\n\t\t\t\t\t\t\t// Specific to Bar Controller\n\t\t\t\t\t\t\tcategoryPercentage: 0.8,\n\t\t\t\t\t\t\tbarPercentage: 0.9,\n\n\t\t\t\t\t\t\t// grid line settings\n\t\t\t\t\t\t\tgridLines: {\n\t\t\t\t\t\t\t\toffsetGridLines: true\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}],\n\t\t\t\t\t\tyAxes: [{\n\t\t\t\t\t\t\ttype: 'linear'\n\t\t\t\t\t\t}]\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\tChart.controllers.bar = Chart.DatasetController.extend({\n\n\t\t\t\t\tdataElementType: Chart.elements.Rectangle,\n\n\t\t\t\t\tinitialize: function initialize(chart, datasetIndex) {\n\t\t\t\t\t\tChart.DatasetController.prototype.initialize.call(this, chart, datasetIndex);\n\n\t\t\t\t\t\tvar me = this;\n\t\t\t\t\t\tvar meta = me.getMeta();\n\t\t\t\t\t\tvar dataset = me.getDataset();\n\n\t\t\t\t\t\tmeta.stack = dataset.stack;\n\t\t\t\t\t\t// Use this to indicate that this is a bar dataset.\n\t\t\t\t\t\tmeta.bar = true;\n\t\t\t\t\t},\n\n\t\t\t\t\t// Correctly calculate the bar width accounting for stacks and the fact that not all bars are visible\n\t\t\t\t\tgetStackCount: function getStackCount() {\n\t\t\t\t\t\tvar me = this;\n\t\t\t\t\t\tvar meta = me.getMeta();\n\t\t\t\t\t\tvar yScale = me.getScaleForId(meta.yAxisID);\n\n\t\t\t\t\t\tvar stacks = [];\n\t\t\t\t\t\thelpers.each(me.chart.data.datasets, function (dataset, datasetIndex) {\n\t\t\t\t\t\t\tvar dsMeta = me.chart.getDatasetMeta(datasetIndex);\n\t\t\t\t\t\t\tif (dsMeta.bar && me.chart.isDatasetVisible(datasetIndex) && (yScale.options.stacked === false || yScale.options.stacked === true && stacks.indexOf(dsMeta.stack) === -1 || yScale.options.stacked === undefined && (dsMeta.stack === undefined || stacks.indexOf(dsMeta.stack) === -1))) {\n\t\t\t\t\t\t\t\tstacks.push(dsMeta.stack);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}, me);\n\n\t\t\t\t\t\treturn stacks.length;\n\t\t\t\t\t},\n\n\t\t\t\t\tupdate: function update(reset) {\n\t\t\t\t\t\tvar me = this;\n\t\t\t\t\t\thelpers.each(me.getMeta().data, function (rectangle, index) {\n\t\t\t\t\t\t\tme.updateElement(rectangle, index, reset);\n\t\t\t\t\t\t}, me);\n\t\t\t\t\t},\n\n\t\t\t\t\tupdateElement: function updateElement(rectangle, index, reset) {\n\t\t\t\t\t\tvar me = this;\n\t\t\t\t\t\tvar meta = me.getMeta();\n\t\t\t\t\t\tvar xScale = me.getScaleForId(meta.xAxisID);\n\t\t\t\t\t\tvar yScale = me.getScaleForId(meta.yAxisID);\n\t\t\t\t\t\tvar scaleBase = yScale.getBasePixel();\n\t\t\t\t\t\tvar rectangleElementOptions = me.chart.options.elements.rectangle;\n\t\t\t\t\t\tvar custom = rectangle.custom || {};\n\t\t\t\t\t\tvar dataset = me.getDataset();\n\n\t\t\t\t\t\trectangle._xScale = xScale;\n\t\t\t\t\t\trectangle._yScale = yScale;\n\t\t\t\t\t\trectangle._datasetIndex = me.index;\n\t\t\t\t\t\trectangle._index = index;\n\n\t\t\t\t\t\tvar ruler = me.getRuler(index); // The index argument for compatible\n\t\t\t\t\t\trectangle._model = {\n\t\t\t\t\t\t\tx: me.calculateBarX(index, me.index, ruler),\n\t\t\t\t\t\t\ty: reset ? scaleBase : me.calculateBarY(index, me.index),\n\n\t\t\t\t\t\t\t// Tooltip\n\t\t\t\t\t\t\tlabel: me.chart.data.labels[index],\n\t\t\t\t\t\t\tdatasetLabel: dataset.label,\n\n\t\t\t\t\t\t\t// Appearance\n\t\t\t\t\t\t\thorizontal: false,\n\t\t\t\t\t\t\tbase: reset ? scaleBase : me.calculateBarBase(me.index, index),\n\t\t\t\t\t\t\twidth: me.calculateBarWidth(ruler),\n\t\t\t\t\t\t\tbackgroundColor: custom.backgroundColor ? custom.backgroundColor : helpers.getValueAtIndexOrDefault(dataset.backgroundColor, index, rectangleElementOptions.backgroundColor),\n\t\t\t\t\t\t\tborderSkipped: custom.borderSkipped ? custom.borderSkipped : rectangleElementOptions.borderSkipped,\n\t\t\t\t\t\t\tborderColor: custom.borderColor ? custom.borderColor : helpers.getValueAtIndexOrDefault(dataset.borderColor, index, rectangleElementOptions.borderColor),\n\t\t\t\t\t\t\tborderWidth: custom.borderWidth ? custom.borderWidth : helpers.getValueAtIndexOrDefault(dataset.borderWidth, index, rectangleElementOptions.borderWidth)\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\trectangle.pivot();\n\t\t\t\t\t},\n\n\t\t\t\t\tcalculateBarBase: function calculateBarBase(datasetIndex, index) {\n\t\t\t\t\t\tvar me = this;\n\t\t\t\t\t\tvar meta = me.getMeta();\n\t\t\t\t\t\tvar yScale = me.getScaleForId(meta.yAxisID);\n\t\t\t\t\t\tvar base = yScale.getBaseValue();\n\t\t\t\t\t\tvar original = base;\n\n\t\t\t\t\t\tif (yScale.options.stacked === true || yScale.options.stacked === undefined && meta.stack !== undefined) {\n\t\t\t\t\t\t\tvar chart = me.chart;\n\t\t\t\t\t\t\tvar datasets = chart.data.datasets;\n\t\t\t\t\t\t\tvar value = Number(datasets[datasetIndex].data[index]);\n\n\t\t\t\t\t\t\tfor (var i = 0; i < datasetIndex; i++) {\n\t\t\t\t\t\t\t\tvar currentDs = datasets[i];\n\t\t\t\t\t\t\t\tvar currentDsMeta = chart.getDatasetMeta(i);\n\t\t\t\t\t\t\t\tif (currentDsMeta.bar && currentDsMeta.yAxisID === yScale.id && chart.isDatasetVisible(i) && meta.stack === currentDsMeta.stack) {\n\t\t\t\t\t\t\t\t\tvar currentVal = Number(currentDs.data[index]);\n\t\t\t\t\t\t\t\t\tbase += value < 0 ? Math.min(currentVal, original) : Math.max(currentVal, original);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treturn yScale.getPixelForValue(base);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn yScale.getBasePixel();\n\t\t\t\t\t},\n\n\t\t\t\t\tgetRuler: function getRuler() {\n\t\t\t\t\t\tvar me = this;\n\t\t\t\t\t\tvar meta = me.getMeta();\n\t\t\t\t\t\tvar xScale = me.getScaleForId(meta.xAxisID);\n\t\t\t\t\t\tvar stackCount = me.getStackCount();\n\n\t\t\t\t\t\tvar tickWidth = xScale.width / xScale.ticks.length;\n\t\t\t\t\t\tvar categoryWidth = tickWidth * xScale.options.categoryPercentage;\n\t\t\t\t\t\tvar categorySpacing = (tickWidth - tickWidth * xScale.options.categoryPercentage) / 2;\n\t\t\t\t\t\tvar fullBarWidth = categoryWidth / stackCount;\n\n\t\t\t\t\t\tvar barWidth = fullBarWidth * xScale.options.barPercentage;\n\t\t\t\t\t\tvar barSpacing = fullBarWidth - fullBarWidth * xScale.options.barPercentage;\n\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tstackCount: stackCount,\n\t\t\t\t\t\t\ttickWidth: tickWidth,\n\t\t\t\t\t\t\tcategoryWidth: categoryWidth,\n\t\t\t\t\t\t\tcategorySpacing: categorySpacing,\n\t\t\t\t\t\t\tfullBarWidth: fullBarWidth,\n\t\t\t\t\t\t\tbarWidth: barWidth,\n\t\t\t\t\t\t\tbarSpacing: barSpacing\n\t\t\t\t\t\t};\n\t\t\t\t\t},\n\n\t\t\t\t\tcalculateBarWidth: function calculateBarWidth(ruler) {\n\t\t\t\t\t\tvar me = this;\n\t\t\t\t\t\tvar meta = me.getMeta();\n\t\t\t\t\t\tvar xScale = me.getScaleForId(meta.xAxisID);\n\t\t\t\t\t\tif (xScale.options.barThickness) {\n\t\t\t\t\t\t\treturn xScale.options.barThickness;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn ruler.barWidth;\n\t\t\t\t\t},\n\n\t\t\t\t\t// Get stack index from the given dataset index accounting for stacks and the fact that not all bars are visible\n\t\t\t\t\tgetStackIndex: function getStackIndex(datasetIndex) {\n\t\t\t\t\t\tvar me = this;\n\t\t\t\t\t\tvar meta = me.chart.getDatasetMeta(datasetIndex);\n\t\t\t\t\t\tvar yScale = me.getScaleForId(meta.yAxisID);\n\t\t\t\t\t\tvar dsMeta, j;\n\t\t\t\t\t\tvar stacks = [meta.stack];\n\n\t\t\t\t\t\tfor (j = 0; j < datasetIndex; ++j) {\n\t\t\t\t\t\t\tdsMeta = this.chart.getDatasetMeta(j);\n\t\t\t\t\t\t\tif (dsMeta.bar && this.chart.isDatasetVisible(j) && (yScale.options.stacked === false || yScale.options.stacked === true && stacks.indexOf(dsMeta.stack) === -1 || yScale.options.stacked === undefined && (dsMeta.stack === undefined || stacks.indexOf(dsMeta.stack) === -1))) {\n\t\t\t\t\t\t\t\tstacks.push(dsMeta.stack);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn stacks.length - 1;\n\t\t\t\t\t},\n\n\t\t\t\t\tcalculateBarX: function calculateBarX(index, datasetIndex, ruler) {\n\t\t\t\t\t\tvar me = this;\n\t\t\t\t\t\tvar meta = me.getMeta();\n\t\t\t\t\t\tvar xScale = me.getScaleForId(meta.xAxisID);\n\t\t\t\t\t\tvar stackIndex = me.getStackIndex(datasetIndex);\n\t\t\t\t\t\tvar leftTick = xScale.getPixelForValue(null, index, datasetIndex, me.chart.isCombo);\n\t\t\t\t\t\tleftTick -= me.chart.isCombo ? ruler.tickWidth / 2 : 0;\n\n\t\t\t\t\t\treturn leftTick + ruler.barWidth / 2 + ruler.categorySpacing + ruler.barWidth * stackIndex + ruler.barSpacing / 2 + ruler.barSpacing * stackIndex;\n\t\t\t\t\t},\n\n\t\t\t\t\tcalculateBarY: function calculateBarY(index, datasetIndex) {\n\t\t\t\t\t\tvar me = this;\n\t\t\t\t\t\tvar meta = me.getMeta();\n\t\t\t\t\t\tvar yScale = me.getScaleForId(meta.yAxisID);\n\t\t\t\t\t\tvar value = Number(me.getDataset().data[index]);\n\n\t\t\t\t\t\tif (yScale.options.stacked || yScale.options.stacked === undefined && meta.stack !== undefined) {\n\t\t\t\t\t\t\tvar base = yScale.getBaseValue();\n\t\t\t\t\t\t\tvar sumPos = base,\n\t\t\t\t\t\t\t    sumNeg = base;\n\n\t\t\t\t\t\t\tfor (var i = 0; i < datasetIndex; i++) {\n\t\t\t\t\t\t\t\tvar ds = me.chart.data.datasets[i];\n\t\t\t\t\t\t\t\tvar dsMeta = me.chart.getDatasetMeta(i);\n\t\t\t\t\t\t\t\tif (dsMeta.bar && dsMeta.yAxisID === yScale.id && me.chart.isDatasetVisible(i) && meta.stack === dsMeta.stack) {\n\t\t\t\t\t\t\t\t\tvar stackedVal = Number(ds.data[index]);\n\t\t\t\t\t\t\t\t\tif (stackedVal < 0) {\n\t\t\t\t\t\t\t\t\t\tsumNeg += stackedVal || 0;\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tsumPos += stackedVal || 0;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (value < 0) {\n\t\t\t\t\t\t\t\treturn yScale.getPixelForValue(sumNeg + value);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn yScale.getPixelForValue(sumPos + value);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn yScale.getPixelForValue(value);\n\t\t\t\t\t},\n\n\t\t\t\t\tdraw: function draw(ease) {\n\t\t\t\t\t\tvar me = this;\n\t\t\t\t\t\tvar easingDecimal = ease || 1;\n\t\t\t\t\t\tvar metaData = me.getMeta().data;\n\t\t\t\t\t\tvar dataset = me.getDataset();\n\t\t\t\t\t\tvar i, len;\n\n\t\t\t\t\t\tChart.canvasHelpers.clipArea(me.chart.chart.ctx, me.chart.chartArea);\n\t\t\t\t\t\tfor (i = 0, len = metaData.length; i < len; ++i) {\n\t\t\t\t\t\t\tvar d = dataset.data[i];\n\t\t\t\t\t\t\tif (d !== null && d !== undefined && !isNaN(d)) {\n\t\t\t\t\t\t\t\tmetaData[i].transition(easingDecimal).draw();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tChart.canvasHelpers.unclipArea(me.chart.chart.ctx);\n\t\t\t\t\t},\n\n\t\t\t\t\tsetHoverStyle: function setHoverStyle(rectangle) {\n\t\t\t\t\t\tvar dataset = this.chart.data.datasets[rectangle._datasetIndex];\n\t\t\t\t\t\tvar index = rectangle._index;\n\n\t\t\t\t\t\tvar custom = rectangle.custom || {};\n\t\t\t\t\t\tvar model = rectangle._model;\n\t\t\t\t\t\tmodel.backgroundColor = custom.hoverBackgroundColor ? custom.hoverBackgroundColor : helpers.getValueAtIndexOrDefault(dataset.hoverBackgroundColor, index, helpers.getHoverColor(model.backgroundColor));\n\t\t\t\t\t\tmodel.borderColor = custom.hoverBorderColor ? custom.hoverBorderColor : helpers.getValueAtIndexOrDefault(dataset.hoverBorderColor, index, helpers.getHoverColor(model.borderColor));\n\t\t\t\t\t\tmodel.borderWidth = custom.hoverBorderWidth ? custom.hoverBorderWidth : helpers.getValueAtIndexOrDefault(dataset.hoverBorderWidth, index, model.borderWidth);\n\t\t\t\t\t},\n\n\t\t\t\t\tremoveHoverStyle: function removeHoverStyle(rectangle) {\n\t\t\t\t\t\tvar dataset = this.chart.data.datasets[rectangle._datasetIndex];\n\t\t\t\t\t\tvar index = rectangle._index;\n\t\t\t\t\t\tvar custom = rectangle.custom || {};\n\t\t\t\t\t\tvar model = rectangle._model;\n\t\t\t\t\t\tvar rectangleElementOptions = this.chart.options.elements.rectangle;\n\n\t\t\t\t\t\tmodel.backgroundColor = custom.backgroundColor ? custom.backgroundColor : helpers.getValueAtIndexOrDefault(dataset.backgroundColor, index, rectangleElementOptions.backgroundColor);\n\t\t\t\t\t\tmodel.borderColor = custom.borderColor ? custom.borderColor : helpers.getValueAtIndexOrDefault(dataset.borderColor, index, rectangleElementOptions.borderColor);\n\t\t\t\t\t\tmodel.borderWidth = custom.borderWidth ? custom.borderWidth : helpers.getValueAtIndexOrDefault(dataset.borderWidth, index, rectangleElementOptions.borderWidth);\n\t\t\t\t\t}\n\n\t\t\t\t});\n\n\t\t\t\t// including horizontalBar in the bar file, instead of a file of its own\n\t\t\t\t// it extends bar (like pie extends doughnut)\n\t\t\t\tChart.defaults.horizontalBar = {\n\t\t\t\t\thover: {\n\t\t\t\t\t\tmode: 'label'\n\t\t\t\t\t},\n\n\t\t\t\t\tscales: {\n\t\t\t\t\t\txAxes: [{\n\t\t\t\t\t\t\ttype: 'linear',\n\t\t\t\t\t\t\tposition: 'bottom'\n\t\t\t\t\t\t}],\n\t\t\t\t\t\tyAxes: [{\n\t\t\t\t\t\t\tposition: 'left',\n\t\t\t\t\t\t\ttype: 'category',\n\n\t\t\t\t\t\t\t// Specific to Horizontal Bar Controller\n\t\t\t\t\t\t\tcategoryPercentage: 0.8,\n\t\t\t\t\t\t\tbarPercentage: 0.9,\n\n\t\t\t\t\t\t\t// grid line settings\n\t\t\t\t\t\t\tgridLines: {\n\t\t\t\t\t\t\t\toffsetGridLines: true\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}]\n\t\t\t\t\t},\n\t\t\t\t\telements: {\n\t\t\t\t\t\trectangle: {\n\t\t\t\t\t\t\tborderSkipped: 'left'\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\ttooltips: {\n\t\t\t\t\t\tcallbacks: {\n\t\t\t\t\t\t\ttitle: function title(tooltipItems, data) {\n\t\t\t\t\t\t\t\t// Pick first xLabel for now\n\t\t\t\t\t\t\t\tvar title = '';\n\n\t\t\t\t\t\t\t\tif (tooltipItems.length > 0) {\n\t\t\t\t\t\t\t\t\tif (tooltipItems[0].yLabel) {\n\t\t\t\t\t\t\t\t\t\ttitle = tooltipItems[0].yLabel;\n\t\t\t\t\t\t\t\t\t} else if (data.labels.length > 0 && tooltipItems[0].index < data.labels.length) {\n\t\t\t\t\t\t\t\t\t\ttitle = data.labels[tooltipItems[0].index];\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\treturn title;\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tlabel: function label(tooltipItem, data) {\n\t\t\t\t\t\t\t\tvar datasetLabel = data.datasets[tooltipItem.datasetIndex].label || '';\n\t\t\t\t\t\t\t\treturn datasetLabel + ': ' + tooltipItem.xLabel;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\tChart.controllers.horizontalBar = Chart.controllers.bar.extend({\n\n\t\t\t\t\t// Correctly calculate the bar width accounting for stacks and the fact that not all bars are visible\n\t\t\t\t\tgetStackCount: function getStackCount() {\n\t\t\t\t\t\tvar me = this;\n\t\t\t\t\t\tvar meta = me.getMeta();\n\t\t\t\t\t\tvar xScale = me.getScaleForId(meta.xAxisID);\n\n\t\t\t\t\t\tvar stacks = [];\n\t\t\t\t\t\thelpers.each(me.chart.data.datasets, function (dataset, datasetIndex) {\n\t\t\t\t\t\t\tvar dsMeta = me.chart.getDatasetMeta(datasetIndex);\n\t\t\t\t\t\t\tif (dsMeta.bar && me.chart.isDatasetVisible(datasetIndex) && (xScale.options.stacked === false || xScale.options.stacked === true && stacks.indexOf(dsMeta.stack) === -1 || xScale.options.stacked === undefined && (dsMeta.stack === undefined || stacks.indexOf(dsMeta.stack) === -1))) {\n\t\t\t\t\t\t\t\tstacks.push(dsMeta.stack);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}, me);\n\n\t\t\t\t\t\treturn stacks.length;\n\t\t\t\t\t},\n\n\t\t\t\t\tupdateElement: function updateElement(rectangle, index, reset) {\n\t\t\t\t\t\tvar me = this;\n\t\t\t\t\t\tvar meta = me.getMeta();\n\t\t\t\t\t\tvar xScale = me.getScaleForId(meta.xAxisID);\n\t\t\t\t\t\tvar yScale = me.getScaleForId(meta.yAxisID);\n\t\t\t\t\t\tvar scaleBase = xScale.getBasePixel();\n\t\t\t\t\t\tvar custom = rectangle.custom || {};\n\t\t\t\t\t\tvar dataset = me.getDataset();\n\t\t\t\t\t\tvar rectangleElementOptions = me.chart.options.elements.rectangle;\n\n\t\t\t\t\t\trectangle._xScale = xScale;\n\t\t\t\t\t\trectangle._yScale = yScale;\n\t\t\t\t\t\trectangle._datasetIndex = me.index;\n\t\t\t\t\t\trectangle._index = index;\n\n\t\t\t\t\t\tvar ruler = me.getRuler(index); // The index argument for compatible\n\t\t\t\t\t\trectangle._model = {\n\t\t\t\t\t\t\tx: reset ? scaleBase : me.calculateBarX(index, me.index),\n\t\t\t\t\t\t\ty: me.calculateBarY(index, me.index, ruler),\n\n\t\t\t\t\t\t\t// Tooltip\n\t\t\t\t\t\t\tlabel: me.chart.data.labels[index],\n\t\t\t\t\t\t\tdatasetLabel: dataset.label,\n\n\t\t\t\t\t\t\t// Appearance\n\t\t\t\t\t\t\thorizontal: true,\n\t\t\t\t\t\t\tbase: reset ? scaleBase : me.calculateBarBase(me.index, index),\n\t\t\t\t\t\t\theight: me.calculateBarHeight(ruler),\n\t\t\t\t\t\t\tbackgroundColor: custom.backgroundColor ? custom.backgroundColor : helpers.getValueAtIndexOrDefault(dataset.backgroundColor, index, rectangleElementOptions.backgroundColor),\n\t\t\t\t\t\t\tborderSkipped: custom.borderSkipped ? custom.borderSkipped : rectangleElementOptions.borderSkipped,\n\t\t\t\t\t\t\tborderColor: custom.borderColor ? custom.borderColor : helpers.getValueAtIndexOrDefault(dataset.borderColor, index, rectangleElementOptions.borderColor),\n\t\t\t\t\t\t\tborderWidth: custom.borderWidth ? custom.borderWidth : helpers.getValueAtIndexOrDefault(dataset.borderWidth, index, rectangleElementOptions.borderWidth)\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\trectangle.pivot();\n\t\t\t\t\t},\n\n\t\t\t\t\tcalculateBarBase: function calculateBarBase(datasetIndex, index) {\n\t\t\t\t\t\tvar me = this;\n\t\t\t\t\t\tvar meta = me.getMeta();\n\t\t\t\t\t\tvar xScale = me.getScaleForId(meta.xAxisID);\n\t\t\t\t\t\tvar base = xScale.getBaseValue();\n\t\t\t\t\t\tvar originalBase = base;\n\n\t\t\t\t\t\tif (xScale.options.stacked || xScale.options.stacked === undefined && meta.stack !== undefined) {\n\t\t\t\t\t\t\tvar chart = me.chart;\n\t\t\t\t\t\t\tvar datasets = chart.data.datasets;\n\t\t\t\t\t\t\tvar value = Number(datasets[datasetIndex].data[index]);\n\n\t\t\t\t\t\t\tfor (var i = 0; i < datasetIndex; i++) {\n\t\t\t\t\t\t\t\tvar currentDs = datasets[i];\n\t\t\t\t\t\t\t\tvar currentDsMeta = chart.getDatasetMeta(i);\n\t\t\t\t\t\t\t\tif (currentDsMeta.bar && currentDsMeta.xAxisID === xScale.id && chart.isDatasetVisible(i) && meta.stack === currentDsMeta.stack) {\n\t\t\t\t\t\t\t\t\tvar currentVal = Number(currentDs.data[index]);\n\t\t\t\t\t\t\t\t\tbase += value < 0 ? Math.min(currentVal, originalBase) : Math.max(currentVal, originalBase);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treturn xScale.getPixelForValue(base);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn xScale.getBasePixel();\n\t\t\t\t\t},\n\n\t\t\t\t\tgetRuler: function getRuler() {\n\t\t\t\t\t\tvar me = this;\n\t\t\t\t\t\tvar meta = me.getMeta();\n\t\t\t\t\t\tvar yScale = me.getScaleForId(meta.yAxisID);\n\t\t\t\t\t\tvar stackCount = me.getStackCount();\n\n\t\t\t\t\t\tvar tickHeight = yScale.height / yScale.ticks.length;\n\t\t\t\t\t\tvar categoryHeight = tickHeight * yScale.options.categoryPercentage;\n\t\t\t\t\t\tvar categorySpacing = (tickHeight - tickHeight * yScale.options.categoryPercentage) / 2;\n\t\t\t\t\t\tvar fullBarHeight = categoryHeight / stackCount;\n\n\t\t\t\t\t\tvar barHeight = fullBarHeight * yScale.options.barPercentage;\n\t\t\t\t\t\tvar barSpacing = fullBarHeight - fullBarHeight * yScale.options.barPercentage;\n\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tstackCount: stackCount,\n\t\t\t\t\t\t\ttickHeight: tickHeight,\n\t\t\t\t\t\t\tcategoryHeight: categoryHeight,\n\t\t\t\t\t\t\tcategorySpacing: categorySpacing,\n\t\t\t\t\t\t\tfullBarHeight: fullBarHeight,\n\t\t\t\t\t\t\tbarHeight: barHeight,\n\t\t\t\t\t\t\tbarSpacing: barSpacing\n\t\t\t\t\t\t};\n\t\t\t\t\t},\n\n\t\t\t\t\tcalculateBarHeight: function calculateBarHeight(ruler) {\n\t\t\t\t\t\tvar me = this;\n\t\t\t\t\t\tvar meta = me.getMeta();\n\t\t\t\t\t\tvar yScale = me.getScaleForId(meta.yAxisID);\n\t\t\t\t\t\tif (yScale.options.barThickness) {\n\t\t\t\t\t\t\treturn yScale.options.barThickness;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn ruler.barHeight;\n\t\t\t\t\t},\n\n\t\t\t\t\t// Get stack index from the given dataset index accounting for stacks and the fact that not all bars are visible\n\t\t\t\t\tgetStackIndex: function getStackIndex(datasetIndex) {\n\t\t\t\t\t\tvar me = this;\n\t\t\t\t\t\tvar meta = me.chart.getDatasetMeta(datasetIndex);\n\t\t\t\t\t\tvar xScale = me.getScaleForId(meta.xAxisID);\n\t\t\t\t\t\tvar dsMeta, j;\n\t\t\t\t\t\tvar stacks = [meta.stack];\n\n\t\t\t\t\t\tfor (j = 0; j < datasetIndex; ++j) {\n\t\t\t\t\t\t\tdsMeta = this.chart.getDatasetMeta(j);\n\t\t\t\t\t\t\tif (dsMeta.bar && this.chart.isDatasetVisible(j) && (xScale.options.stacked === false || xScale.options.stacked === true && stacks.indexOf(dsMeta.stack) === -1 || xScale.options.stacked === undefined && (dsMeta.stack === undefined || stacks.indexOf(dsMeta.stack) === -1))) {\n\t\t\t\t\t\t\t\tstacks.push(dsMeta.stack);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn stacks.length - 1;\n\t\t\t\t\t},\n\n\t\t\t\t\tcalculateBarX: function calculateBarX(index, datasetIndex) {\n\t\t\t\t\t\tvar me = this;\n\t\t\t\t\t\tvar meta = me.getMeta();\n\t\t\t\t\t\tvar xScale = me.getScaleForId(meta.xAxisID);\n\t\t\t\t\t\tvar value = Number(me.getDataset().data[index]);\n\n\t\t\t\t\t\tif (xScale.options.stacked || xScale.options.stacked === undefined && meta.stack !== undefined) {\n\t\t\t\t\t\t\tvar base = xScale.getBaseValue();\n\t\t\t\t\t\t\tvar sumPos = base,\n\t\t\t\t\t\t\t    sumNeg = base;\n\n\t\t\t\t\t\t\tfor (var i = 0; i < datasetIndex; i++) {\n\t\t\t\t\t\t\t\tvar ds = me.chart.data.datasets[i];\n\t\t\t\t\t\t\t\tvar dsMeta = me.chart.getDatasetMeta(i);\n\t\t\t\t\t\t\t\tif (dsMeta.bar && dsMeta.xAxisID === xScale.id && me.chart.isDatasetVisible(i) && meta.stack === dsMeta.stack) {\n\t\t\t\t\t\t\t\t\tvar stackedVal = Number(ds.data[index]);\n\t\t\t\t\t\t\t\t\tif (stackedVal < 0) {\n\t\t\t\t\t\t\t\t\t\tsumNeg += stackedVal || 0;\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tsumPos += stackedVal || 0;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (value < 0) {\n\t\t\t\t\t\t\t\treturn xScale.getPixelForValue(sumNeg + value);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn xScale.getPixelForValue(sumPos + value);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn xScale.getPixelForValue(value);\n\t\t\t\t\t},\n\n\t\t\t\t\tcalculateBarY: function calculateBarY(index, datasetIndex, ruler) {\n\t\t\t\t\t\tvar me = this;\n\t\t\t\t\t\tvar meta = me.getMeta();\n\t\t\t\t\t\tvar yScale = me.getScaleForId(meta.yAxisID);\n\t\t\t\t\t\tvar stackIndex = me.getStackIndex(datasetIndex);\n\t\t\t\t\t\tvar topTick = yScale.getPixelForValue(null, index, datasetIndex, me.chart.isCombo);\n\t\t\t\t\t\ttopTick -= me.chart.isCombo ? ruler.tickHeight / 2 : 0;\n\n\t\t\t\t\t\treturn topTick + ruler.barHeight / 2 + ruler.categorySpacing + ruler.barHeight * stackIndex + ruler.barSpacing / 2 + ruler.barSpacing * stackIndex;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t};\n\t\t}, {}], 16: [function (require, module, exports) {\n\t\t\t'use strict';\n\n\t\t\tmodule.exports = function (Chart) {\n\n\t\t\t\tvar helpers = Chart.helpers;\n\n\t\t\t\tChart.defaults.bubble = {\n\t\t\t\t\thover: {\n\t\t\t\t\t\tmode: 'single'\n\t\t\t\t\t},\n\n\t\t\t\t\tscales: {\n\t\t\t\t\t\txAxes: [{\n\t\t\t\t\t\t\ttype: 'linear', // bubble should probably use a linear scale by default\n\t\t\t\t\t\t\tposition: 'bottom',\n\t\t\t\t\t\t\tid: 'x-axis-0' // need an ID so datasets can reference the scale\n\t\t\t\t\t\t}],\n\t\t\t\t\t\tyAxes: [{\n\t\t\t\t\t\t\ttype: 'linear',\n\t\t\t\t\t\t\tposition: 'left',\n\t\t\t\t\t\t\tid: 'y-axis-0'\n\t\t\t\t\t\t}]\n\t\t\t\t\t},\n\n\t\t\t\t\ttooltips: {\n\t\t\t\t\t\tcallbacks: {\n\t\t\t\t\t\t\ttitle: function title() {\n\t\t\t\t\t\t\t\t// Title doesn't make sense for scatter since we format the data as a point\n\t\t\t\t\t\t\t\treturn '';\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tlabel: function label(tooltipItem, data) {\n\t\t\t\t\t\t\t\tvar datasetLabel = data.datasets[tooltipItem.datasetIndex].label || '';\n\t\t\t\t\t\t\t\tvar dataPoint = data.datasets[tooltipItem.datasetIndex].data[tooltipItem.index];\n\t\t\t\t\t\t\t\treturn datasetLabel + ': (' + tooltipItem.xLabel + ', ' + tooltipItem.yLabel + ', ' + dataPoint.r + ')';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\tChart.controllers.bubble = Chart.DatasetController.extend({\n\n\t\t\t\t\tdataElementType: Chart.elements.Point,\n\n\t\t\t\t\tupdate: function update(reset) {\n\t\t\t\t\t\tvar me = this;\n\t\t\t\t\t\tvar meta = me.getMeta();\n\t\t\t\t\t\tvar points = meta.data;\n\n\t\t\t\t\t\t// Update Points\n\t\t\t\t\t\thelpers.each(points, function (point, index) {\n\t\t\t\t\t\t\tme.updateElement(point, index, reset);\n\t\t\t\t\t\t});\n\t\t\t\t\t},\n\n\t\t\t\t\tupdateElement: function updateElement(point, index, reset) {\n\t\t\t\t\t\tvar me = this;\n\t\t\t\t\t\tvar meta = me.getMeta();\n\t\t\t\t\t\tvar xScale = me.getScaleForId(meta.xAxisID);\n\t\t\t\t\t\tvar yScale = me.getScaleForId(meta.yAxisID);\n\n\t\t\t\t\t\tvar custom = point.custom || {};\n\t\t\t\t\t\tvar dataset = me.getDataset();\n\t\t\t\t\t\tvar data = dataset.data[index];\n\t\t\t\t\t\tvar pointElementOptions = me.chart.options.elements.point;\n\t\t\t\t\t\tvar dsIndex = me.index;\n\n\t\t\t\t\t\thelpers.extend(point, {\n\t\t\t\t\t\t\t// Utility\n\t\t\t\t\t\t\t_xScale: xScale,\n\t\t\t\t\t\t\t_yScale: yScale,\n\t\t\t\t\t\t\t_datasetIndex: dsIndex,\n\t\t\t\t\t\t\t_index: index,\n\n\t\t\t\t\t\t\t// Desired view properties\n\t\t\t\t\t\t\t_model: {\n\t\t\t\t\t\t\t\tx: reset ? xScale.getPixelForDecimal(0.5) : xScale.getPixelForValue((typeof data === \"undefined\" ? \"undefined\" : _typeof(data)) === 'object' ? data : NaN, index, dsIndex, me.chart.isCombo),\n\t\t\t\t\t\t\t\ty: reset ? yScale.getBasePixel() : yScale.getPixelForValue(data, index, dsIndex),\n\t\t\t\t\t\t\t\t// Appearance\n\t\t\t\t\t\t\t\tradius: reset ? 0 : custom.radius ? custom.radius : me.getRadius(data),\n\n\t\t\t\t\t\t\t\t// Tooltip\n\t\t\t\t\t\t\t\thitRadius: custom.hitRadius ? custom.hitRadius : helpers.getValueAtIndexOrDefault(dataset.hitRadius, index, pointElementOptions.hitRadius)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\t// Trick to reset the styles of the point\n\t\t\t\t\t\tChart.DatasetController.prototype.removeHoverStyle.call(me, point, pointElementOptions);\n\n\t\t\t\t\t\tvar model = point._model;\n\t\t\t\t\t\tmodel.skip = custom.skip ? custom.skip : isNaN(model.x) || isNaN(model.y);\n\n\t\t\t\t\t\tpoint.pivot();\n\t\t\t\t\t},\n\n\t\t\t\t\tgetRadius: function getRadius(value) {\n\t\t\t\t\t\treturn value.r || this.chart.options.elements.point.radius;\n\t\t\t\t\t},\n\n\t\t\t\t\tsetHoverStyle: function setHoverStyle(point) {\n\t\t\t\t\t\tvar me = this;\n\t\t\t\t\t\tChart.DatasetController.prototype.setHoverStyle.call(me, point);\n\n\t\t\t\t\t\t// Radius\n\t\t\t\t\t\tvar dataset = me.chart.data.datasets[point._datasetIndex];\n\t\t\t\t\t\tvar index = point._index;\n\t\t\t\t\t\tvar custom = point.custom || {};\n\t\t\t\t\t\tvar model = point._model;\n\t\t\t\t\t\tmodel.radius = custom.hoverRadius ? custom.hoverRadius : helpers.getValueAtIndexOrDefault(dataset.hoverRadius, index, me.chart.options.elements.point.hoverRadius) + me.getRadius(dataset.data[index]);\n\t\t\t\t\t},\n\n\t\t\t\t\tremoveHoverStyle: function removeHoverStyle(point) {\n\t\t\t\t\t\tvar me = this;\n\t\t\t\t\t\tChart.DatasetController.prototype.removeHoverStyle.call(me, point, me.chart.options.elements.point);\n\n\t\t\t\t\t\tvar dataVal = me.chart.data.datasets[point._datasetIndex].data[point._index];\n\t\t\t\t\t\tvar custom = point.custom || {};\n\t\t\t\t\t\tvar model = point._model;\n\n\t\t\t\t\t\tmodel.radius = custom.radius ? custom.radius : me.getRadius(dataVal);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t};\n\t\t}, {}], 17: [function (require, module, exports) {\n\t\t\t'use strict';\n\n\t\t\tmodule.exports = function (Chart) {\n\n\t\t\t\tvar helpers = Chart.helpers,\n\t\t\t\t    defaults = Chart.defaults;\n\n\t\t\t\tdefaults.doughnut = {\n\t\t\t\t\tanimation: {\n\t\t\t\t\t\t// Boolean - Whether we animate the rotation of the Doughnut\n\t\t\t\t\t\tanimateRotate: true,\n\t\t\t\t\t\t// Boolean - Whether we animate scaling the Doughnut from the centre\n\t\t\t\t\t\tanimateScale: false\n\t\t\t\t\t},\n\t\t\t\t\taspectRatio: 1,\n\t\t\t\t\thover: {\n\t\t\t\t\t\tmode: 'single'\n\t\t\t\t\t},\n\t\t\t\t\tlegendCallback: function legendCallback(chart) {\n\t\t\t\t\t\tvar text = [];\n\t\t\t\t\t\ttext.push('<ul class=\"' + chart.id + '-legend\">');\n\n\t\t\t\t\t\tvar data = chart.data;\n\t\t\t\t\t\tvar datasets = data.datasets;\n\t\t\t\t\t\tvar labels = data.labels;\n\n\t\t\t\t\t\tif (datasets.length) {\n\t\t\t\t\t\t\tfor (var i = 0; i < datasets[0].data.length; ++i) {\n\t\t\t\t\t\t\t\ttext.push('<li><span style=\"background-color:' + datasets[0].backgroundColor[i] + '\"></span>');\n\t\t\t\t\t\t\t\tif (labels[i]) {\n\t\t\t\t\t\t\t\t\ttext.push(labels[i]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\ttext.push('</li>');\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttext.push('</ul>');\n\t\t\t\t\t\treturn text.join('');\n\t\t\t\t\t},\n\t\t\t\t\tlegend: {\n\t\t\t\t\t\tlabels: {\n\t\t\t\t\t\t\tgenerateLabels: function generateLabels(chart) {\n\t\t\t\t\t\t\t\tvar data = chart.data;\n\t\t\t\t\t\t\t\tif (data.labels.length && data.datasets.length) {\n\t\t\t\t\t\t\t\t\treturn data.labels.map(function (label, i) {\n\t\t\t\t\t\t\t\t\t\tvar meta = chart.getDatasetMeta(0);\n\t\t\t\t\t\t\t\t\t\tvar ds = data.datasets[0];\n\t\t\t\t\t\t\t\t\t\tvar arc = meta.data[i];\n\t\t\t\t\t\t\t\t\t\tvar custom = arc && arc.custom || {};\n\t\t\t\t\t\t\t\t\t\tvar getValueAtIndexOrDefault = helpers.getValueAtIndexOrDefault;\n\t\t\t\t\t\t\t\t\t\tvar arcOpts = chart.options.elements.arc;\n\t\t\t\t\t\t\t\t\t\tvar fill = custom.backgroundColor ? custom.backgroundColor : getValueAtIndexOrDefault(ds.backgroundColor, i, arcOpts.backgroundColor);\n\t\t\t\t\t\t\t\t\t\tvar stroke = custom.borderColor ? custom.borderColor : getValueAtIndexOrDefault(ds.borderColor, i, arcOpts.borderColor);\n\t\t\t\t\t\t\t\t\t\tvar bw = custom.borderWidth ? custom.borderWidth : getValueAtIndexOrDefault(ds.borderWidth, i, arcOpts.borderWidth);\n\n\t\t\t\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\t\t\t\ttext: label,\n\t\t\t\t\t\t\t\t\t\t\tfillStyle: fill,\n\t\t\t\t\t\t\t\t\t\t\tstrokeStyle: stroke,\n\t\t\t\t\t\t\t\t\t\t\tlineWidth: bw,\n\t\t\t\t\t\t\t\t\t\t\thidden: isNaN(ds.data[i]) || meta.data[i].hidden,\n\n\t\t\t\t\t\t\t\t\t\t\t// Extra data used for toggling the correct item\n\t\t\t\t\t\t\t\t\t\t\tindex: i\n\t\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn [];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tonClick: function onClick(e, legendItem) {\n\t\t\t\t\t\t\tvar index = legendItem.index;\n\t\t\t\t\t\t\tvar chart = this.chart;\n\t\t\t\t\t\t\tvar i, ilen, meta;\n\n\t\t\t\t\t\t\tfor (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {\n\t\t\t\t\t\t\t\tmeta = chart.getDatasetMeta(i);\n\t\t\t\t\t\t\t\t// toggle visibility of index if exists\n\t\t\t\t\t\t\t\tif (meta.data[index]) {\n\t\t\t\t\t\t\t\t\tmeta.data[index].hidden = !meta.data[index].hidden;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tchart.update();\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\n\t\t\t\t\t// The percentage of the chart that we cut out of the middle.\n\t\t\t\t\tcutoutPercentage: 50,\n\n\t\t\t\t\t// The rotation of the chart, where the first data arc begins.\n\t\t\t\t\trotation: Math.PI * -0.5,\n\n\t\t\t\t\t// The total circumference of the chart.\n\t\t\t\t\tcircumference: Math.PI * 2.0,\n\n\t\t\t\t\t// Need to override these to give a nice default\n\t\t\t\t\ttooltips: {\n\t\t\t\t\t\tcallbacks: {\n\t\t\t\t\t\t\ttitle: function title() {\n\t\t\t\t\t\t\t\treturn '';\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tlabel: function label(tooltipItem, data) {\n\t\t\t\t\t\t\t\tvar dataLabel = data.labels[tooltipItem.index];\n\t\t\t\t\t\t\t\tvar value = ': ' + data.datasets[tooltipItem.datasetIndex].data[tooltipItem.index];\n\n\t\t\t\t\t\t\t\tif (helpers.isArray(dataLabel)) {\n\t\t\t\t\t\t\t\t\t// show value on first line of multiline label\n\t\t\t\t\t\t\t\t\t// need to clone because we are changing the value\n\t\t\t\t\t\t\t\t\tdataLabel = dataLabel.slice();\n\t\t\t\t\t\t\t\t\tdataLabel[0] += value;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tdataLabel += value;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\treturn dataLabel;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\tdefaults.pie = helpers.clone(defaults.doughnut);\n\t\t\t\thelpers.extend(defaults.pie, {\n\t\t\t\t\tcutoutPercentage: 0\n\t\t\t\t});\n\n\t\t\t\tChart.controllers.doughnut = Chart.controllers.pie = Chart.DatasetController.extend({\n\n\t\t\t\t\tdataElementType: Chart.elements.Arc,\n\n\t\t\t\t\tlinkScales: helpers.noop,\n\n\t\t\t\t\t// Get index of the dataset in relation to the visible datasets. This allows determining the inner and outer radius correctly\n\t\t\t\t\tgetRingIndex: function getRingIndex(datasetIndex) {\n\t\t\t\t\t\tvar ringIndex = 0;\n\n\t\t\t\t\t\tfor (var j = 0; j < datasetIndex; ++j) {\n\t\t\t\t\t\t\tif (this.chart.isDatasetVisible(j)) {\n\t\t\t\t\t\t\t\t++ringIndex;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn ringIndex;\n\t\t\t\t\t},\n\n\t\t\t\t\tupdate: function update(reset) {\n\t\t\t\t\t\tvar me = this;\n\t\t\t\t\t\tvar chart = me.chart,\n\t\t\t\t\t\t    chartArea = chart.chartArea,\n\t\t\t\t\t\t    opts = chart.options,\n\t\t\t\t\t\t    arcOpts = opts.elements.arc,\n\t\t\t\t\t\t    availableWidth = chartArea.right - chartArea.left - arcOpts.borderWidth,\n\t\t\t\t\t\t    availableHeight = chartArea.bottom - chartArea.top - arcOpts.borderWidth,\n\t\t\t\t\t\t    minSize = Math.min(availableWidth, availableHeight),\n\t\t\t\t\t\t    offset = {\n\t\t\t\t\t\t\tx: 0,\n\t\t\t\t\t\t\ty: 0\n\t\t\t\t\t\t},\n\t\t\t\t\t\t    meta = me.getMeta(),\n\t\t\t\t\t\t    cutoutPercentage = opts.cutoutPercentage,\n\t\t\t\t\t\t    circumference = opts.circumference;\n\n\t\t\t\t\t\t// If the chart's circumference isn't a full circle, calculate minSize as a ratio of the width/height of the arc\n\t\t\t\t\t\tif (circumference < Math.PI * 2.0) {\n\t\t\t\t\t\t\tvar startAngle = opts.rotation % (Math.PI * 2.0);\n\t\t\t\t\t\t\tstartAngle += Math.PI * 2.0 * (startAngle >= Math.PI ? -1 : startAngle < -Math.PI ? 1 : 0);\n\t\t\t\t\t\t\tvar endAngle = startAngle + circumference;\n\t\t\t\t\t\t\tvar start = { x: Math.cos(startAngle), y: Math.sin(startAngle) };\n\t\t\t\t\t\t\tvar end = { x: Math.cos(endAngle), y: Math.sin(endAngle) };\n\t\t\t\t\t\t\tvar contains0 = startAngle <= 0 && 0 <= endAngle || startAngle <= Math.PI * 2.0 && Math.PI * 2.0 <= endAngle;\n\t\t\t\t\t\t\tvar contains90 = startAngle <= Math.PI * 0.5 && Math.PI * 0.5 <= endAngle || startAngle <= Math.PI * 2.5 && Math.PI * 2.5 <= endAngle;\n\t\t\t\t\t\t\tvar contains180 = startAngle <= -Math.PI && -Math.PI <= endAngle || startAngle <= Math.PI && Math.PI <= endAngle;\n\t\t\t\t\t\t\tvar contains270 = startAngle <= -Math.PI * 0.5 && -Math.PI * 0.5 <= endAngle || startAngle <= Math.PI * 1.5 && Math.PI * 1.5 <= endAngle;\n\t\t\t\t\t\t\tvar cutout = cutoutPercentage / 100.0;\n\t\t\t\t\t\t\tvar min = { x: contains180 ? -1 : Math.min(start.x * (start.x < 0 ? 1 : cutout), end.x * (end.x < 0 ? 1 : cutout)), y: contains270 ? -1 : Math.min(start.y * (start.y < 0 ? 1 : cutout), end.y * (end.y < 0 ? 1 : cutout)) };\n\t\t\t\t\t\t\tvar max = { x: contains0 ? 1 : Math.max(start.x * (start.x > 0 ? 1 : cutout), end.x * (end.x > 0 ? 1 : cutout)), y: contains90 ? 1 : Math.max(start.y * (start.y > 0 ? 1 : cutout), end.y * (end.y > 0 ? 1 : cutout)) };\n\t\t\t\t\t\t\tvar size = { width: (max.x - min.x) * 0.5, height: (max.y - min.y) * 0.5 };\n\t\t\t\t\t\t\tminSize = Math.min(availableWidth / size.width, availableHeight / size.height);\n\t\t\t\t\t\t\toffset = { x: (max.x + min.x) * -0.5, y: (max.y + min.y) * -0.5 };\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tchart.borderWidth = me.getMaxBorderWidth(meta.data);\n\t\t\t\t\t\tchart.outerRadius = Math.max((minSize - chart.borderWidth) / 2, 0);\n\t\t\t\t\t\tchart.innerRadius = Math.max(cutoutPercentage ? chart.outerRadius / 100 * cutoutPercentage : 0, 0);\n\t\t\t\t\t\tchart.radiusLength = (chart.outerRadius - chart.innerRadius) / chart.getVisibleDatasetCount();\n\t\t\t\t\t\tchart.offsetX = offset.x * chart.outerRadius;\n\t\t\t\t\t\tchart.offsetY = offset.y * chart.outerRadius;\n\n\t\t\t\t\t\tmeta.total = me.calculateTotal();\n\n\t\t\t\t\t\tme.outerRadius = chart.outerRadius - chart.radiusLength * me.getRingIndex(me.index);\n\t\t\t\t\t\tme.innerRadius = Math.max(me.outerRadius - chart.radiusLength, 0);\n\n\t\t\t\t\t\thelpers.each(meta.data, function (arc, index) {\n\t\t\t\t\t\t\tme.updateElement(arc, index, reset);\n\t\t\t\t\t\t});\n\t\t\t\t\t},\n\n\t\t\t\t\tupdateElement: function updateElement(arc, index, reset) {\n\t\t\t\t\t\tvar me = this;\n\t\t\t\t\t\tvar chart = me.chart,\n\t\t\t\t\t\t    chartArea = chart.chartArea,\n\t\t\t\t\t\t    opts = chart.options,\n\t\t\t\t\t\t    animationOpts = opts.animation,\n\t\t\t\t\t\t    centerX = (chartArea.left + chartArea.right) / 2,\n\t\t\t\t\t\t    centerY = (chartArea.top + chartArea.bottom) / 2,\n\t\t\t\t\t\t    startAngle = opts.rotation,\n\t\t\t\t\t\t    // non reset case handled later\n\t\t\t\t\t\tendAngle = opts.rotation,\n\t\t\t\t\t\t    // non reset case handled later\n\t\t\t\t\t\tdataset = me.getDataset(),\n\t\t\t\t\t\t    circumference = reset && animationOpts.animateRotate ? 0 : arc.hidden ? 0 : me.calculateCircumference(dataset.data[index]) * (opts.circumference / (2.0 * Math.PI)),\n\t\t\t\t\t\t    innerRadius = reset && animationOpts.animateScale ? 0 : me.innerRadius,\n\t\t\t\t\t\t    outerRadius = reset && animationOpts.animateScale ? 0 : me.outerRadius,\n\t\t\t\t\t\t    valueAtIndexOrDefault = helpers.getValueAtIndexOrDefault;\n\n\t\t\t\t\t\thelpers.extend(arc, {\n\t\t\t\t\t\t\t// Utility\n\t\t\t\t\t\t\t_datasetIndex: me.index,\n\t\t\t\t\t\t\t_index: index,\n\n\t\t\t\t\t\t\t// Desired view properties\n\t\t\t\t\t\t\t_model: {\n\t\t\t\t\t\t\t\tx: centerX + chart.offsetX,\n\t\t\t\t\t\t\t\ty: centerY + chart.offsetY,\n\t\t\t\t\t\t\t\tstartAngle: startAngle,\n\t\t\t\t\t\t\t\tendAngle: endAngle,\n\t\t\t\t\t\t\t\tcircumference: circumference,\n\t\t\t\t\t\t\t\touterRadius: outerRadius,\n\t\t\t\t\t\t\t\tinnerRadius: innerRadius,\n\t\t\t\t\t\t\t\tlabel: valueAtIndexOrDefault(dataset.label, index, chart.data.labels[index])\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tvar model = arc._model;\n\t\t\t\t\t\t// Resets the visual styles\n\t\t\t\t\t\tthis.removeHoverStyle(arc);\n\n\t\t\t\t\t\t// Set correct angles if not resetting\n\t\t\t\t\t\tif (!reset || !animationOpts.animateRotate) {\n\t\t\t\t\t\t\tif (index === 0) {\n\t\t\t\t\t\t\t\tmodel.startAngle = opts.rotation;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tmodel.startAngle = me.getMeta().data[index - 1]._model.endAngle;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tmodel.endAngle = model.startAngle + model.circumference;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tarc.pivot();\n\t\t\t\t\t},\n\n\t\t\t\t\tremoveHoverStyle: function removeHoverStyle(arc) {\n\t\t\t\t\t\tChart.DatasetController.prototype.removeHoverStyle.call(this, arc, this.chart.options.elements.arc);\n\t\t\t\t\t},\n\n\t\t\t\t\tcalculateTotal: function calculateTotal() {\n\t\t\t\t\t\tvar dataset = this.getDataset();\n\t\t\t\t\t\tvar meta = this.getMeta();\n\t\t\t\t\t\tvar total = 0;\n\t\t\t\t\t\tvar value;\n\n\t\t\t\t\t\thelpers.each(meta.data, function (element, index) {\n\t\t\t\t\t\t\tvalue = dataset.data[index];\n\t\t\t\t\t\t\tif (!isNaN(value) && !element.hidden) {\n\t\t\t\t\t\t\t\ttotal += Math.abs(value);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\t/* if (total === 0) {\n      \ttotal = NaN;\n      }*/\n\n\t\t\t\t\t\treturn total;\n\t\t\t\t\t},\n\n\t\t\t\t\tcalculateCircumference: function calculateCircumference(value) {\n\t\t\t\t\t\tvar total = this.getMeta().total;\n\t\t\t\t\t\tif (total > 0 && !isNaN(value)) {\n\t\t\t\t\t\t\treturn Math.PI * 2.0 * (value / total);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t},\n\n\t\t\t\t\t// gets the max border or hover width to properly scale pie charts\n\t\t\t\t\tgetMaxBorderWidth: function getMaxBorderWidth(elements) {\n\t\t\t\t\t\tvar max = 0,\n\t\t\t\t\t\t    index = this.index,\n\t\t\t\t\t\t    length = elements.length,\n\t\t\t\t\t\t    borderWidth,\n\t\t\t\t\t\t    hoverWidth;\n\n\t\t\t\t\t\tfor (var i = 0; i < length; i++) {\n\t\t\t\t\t\t\tborderWidth = elements[i]._model ? elements[i]._model.borderWidth : 0;\n\t\t\t\t\t\t\thoverWidth = elements[i]._chart ? elements[i]._chart.config.data.datasets[index].hoverBorderWidth : 0;\n\n\t\t\t\t\t\t\tmax = borderWidth > max ? borderWidth : max;\n\t\t\t\t\t\t\tmax = hoverWidth > max ? hoverWidth : max;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn max;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t};\n\t\t}, {}], 18: [function (require, module, exports) {\n\t\t\t'use strict';\n\n\t\t\tmodule.exports = function (Chart) {\n\n\t\t\t\tvar helpers = Chart.helpers;\n\n\t\t\t\tChart.defaults.line = {\n\t\t\t\t\tshowLines: true,\n\t\t\t\t\tspanGaps: false,\n\n\t\t\t\t\thover: {\n\t\t\t\t\t\tmode: 'label'\n\t\t\t\t\t},\n\n\t\t\t\t\tscales: {\n\t\t\t\t\t\txAxes: [{\n\t\t\t\t\t\t\ttype: 'category',\n\t\t\t\t\t\t\tid: 'x-axis-0'\n\t\t\t\t\t\t}],\n\t\t\t\t\t\tyAxes: [{\n\t\t\t\t\t\t\ttype: 'linear',\n\t\t\t\t\t\t\tid: 'y-axis-0'\n\t\t\t\t\t\t}]\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\tfunction lineEnabled(dataset, options) {\n\t\t\t\t\treturn helpers.getValueOrDefault(dataset.showLine, options.showLines);\n\t\t\t\t}\n\n\t\t\t\tChart.controllers.line = Chart.DatasetController.extend({\n\n\t\t\t\t\tdatasetElementType: Chart.elements.Line,\n\n\t\t\t\t\tdataElementType: Chart.elements.Point,\n\n\t\t\t\t\tupdate: function update(reset) {\n\t\t\t\t\t\tvar me = this;\n\t\t\t\t\t\tvar meta = me.getMeta();\n\t\t\t\t\t\tvar line = meta.dataset;\n\t\t\t\t\t\tvar points = meta.data || [];\n\t\t\t\t\t\tvar options = me.chart.options;\n\t\t\t\t\t\tvar lineElementOptions = options.elements.line;\n\t\t\t\t\t\tvar scale = me.getScaleForId(meta.yAxisID);\n\t\t\t\t\t\tvar i, ilen, custom;\n\t\t\t\t\t\tvar dataset = me.getDataset();\n\t\t\t\t\t\tvar showLine = lineEnabled(dataset, options);\n\n\t\t\t\t\t\t// Update Line\n\t\t\t\t\t\tif (showLine) {\n\t\t\t\t\t\t\tcustom = line.custom || {};\n\n\t\t\t\t\t\t\t// Compatibility: If the properties are defined with only the old name, use those values\n\t\t\t\t\t\t\tif (dataset.tension !== undefined && dataset.lineTension === undefined) {\n\t\t\t\t\t\t\t\tdataset.lineTension = dataset.tension;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Utility\n\t\t\t\t\t\t\tline._scale = scale;\n\t\t\t\t\t\t\tline._datasetIndex = me.index;\n\t\t\t\t\t\t\t// Data\n\t\t\t\t\t\t\tline._children = points;\n\t\t\t\t\t\t\t// Model\n\t\t\t\t\t\t\tline._model = {\n\t\t\t\t\t\t\t\t// Appearance\n\t\t\t\t\t\t\t\t// The default behavior of lines is to break at null values, according\n\t\t\t\t\t\t\t\t// to https://github.com/chartjs/Chart.js/issues/2435#issuecomment-216718158\n\t\t\t\t\t\t\t\t// This option gives lines the ability to span gaps\n\t\t\t\t\t\t\t\tspanGaps: dataset.spanGaps ? dataset.spanGaps : options.spanGaps,\n\t\t\t\t\t\t\t\ttension: custom.tension ? custom.tension : helpers.getValueOrDefault(dataset.lineTension, lineElementOptions.tension),\n\t\t\t\t\t\t\t\tbackgroundColor: custom.backgroundColor ? custom.backgroundColor : dataset.backgroundColor || lineElementOptions.backgroundColor,\n\t\t\t\t\t\t\t\tborderWidth: custom.borderWidth ? custom.borderWidth : dataset.borderWidth || lineElementOptions.borderWidth,\n\t\t\t\t\t\t\t\tborderColor: custom.borderColor ? custom.borderColor : dataset.borderColor || lineElementOptions.borderColor,\n\t\t\t\t\t\t\t\tborderCapStyle: custom.borderCapStyle ? custom.borderCapStyle : dataset.borderCapStyle || lineElementOptions.borderCapStyle,\n\t\t\t\t\t\t\t\tborderDash: custom.borderDash ? custom.borderDash : dataset.borderDash || lineElementOptions.borderDash,\n\t\t\t\t\t\t\t\tborderDashOffset: custom.borderDashOffset ? custom.borderDashOffset : dataset.borderDashOffset || lineElementOptions.borderDashOffset,\n\t\t\t\t\t\t\t\tborderJoinStyle: custom.borderJoinStyle ? custom.borderJoinStyle : dataset.borderJoinStyle || lineElementOptions.borderJoinStyle,\n\t\t\t\t\t\t\t\tfill: custom.fill ? custom.fill : dataset.fill !== undefined ? dataset.fill : lineElementOptions.fill,\n\t\t\t\t\t\t\t\tsteppedLine: custom.steppedLine ? custom.steppedLine : helpers.getValueOrDefault(dataset.steppedLine, lineElementOptions.stepped),\n\t\t\t\t\t\t\t\tcubicInterpolationMode: custom.cubicInterpolationMode ? custom.cubicInterpolationMode : helpers.getValueOrDefault(dataset.cubicInterpolationMode, lineElementOptions.cubicInterpolationMode),\n\t\t\t\t\t\t\t\t// Scale\n\t\t\t\t\t\t\t\tscaleTop: scale.top,\n\t\t\t\t\t\t\t\tscaleBottom: scale.bottom,\n\t\t\t\t\t\t\t\tscaleZero: scale.getBasePixel()\n\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\tline.pivot();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Update Points\n\t\t\t\t\t\tfor (i = 0, ilen = points.length; i < ilen; ++i) {\n\t\t\t\t\t\t\tme.updateElement(points[i], i, reset);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (showLine && line._model.tension !== 0) {\n\t\t\t\t\t\t\tme.updateBezierControlPoints();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Now pivot the point for animation\n\t\t\t\t\t\tfor (i = 0, ilen = points.length; i < ilen; ++i) {\n\t\t\t\t\t\t\tpoints[i].pivot();\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\n\t\t\t\t\tgetPointBackgroundColor: function getPointBackgroundColor(point, index) {\n\t\t\t\t\t\tvar backgroundColor = this.chart.options.elements.point.backgroundColor;\n\t\t\t\t\t\tvar dataset = this.getDataset();\n\t\t\t\t\t\tvar custom = point.custom || {};\n\n\t\t\t\t\t\tif (custom.backgroundColor) {\n\t\t\t\t\t\t\tbackgroundColor = custom.backgroundColor;\n\t\t\t\t\t\t} else if (dataset.pointBackgroundColor) {\n\t\t\t\t\t\t\tbackgroundColor = helpers.getValueAtIndexOrDefault(dataset.pointBackgroundColor, index, backgroundColor);\n\t\t\t\t\t\t} else if (dataset.backgroundColor) {\n\t\t\t\t\t\t\tbackgroundColor = dataset.backgroundColor;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn backgroundColor;\n\t\t\t\t\t},\n\n\t\t\t\t\tgetPointBorderColor: function getPointBorderColor(point, index) {\n\t\t\t\t\t\tvar borderColor = this.chart.options.elements.point.borderColor;\n\t\t\t\t\t\tvar dataset = this.getDataset();\n\t\t\t\t\t\tvar custom = point.custom || {};\n\n\t\t\t\t\t\tif (custom.borderColor) {\n\t\t\t\t\t\t\tborderColor = custom.borderColor;\n\t\t\t\t\t\t} else if (dataset.pointBorderColor) {\n\t\t\t\t\t\t\tborderColor = helpers.getValueAtIndexOrDefault(dataset.pointBorderColor, index, borderColor);\n\t\t\t\t\t\t} else if (dataset.borderColor) {\n\t\t\t\t\t\t\tborderColor = dataset.borderColor;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn borderColor;\n\t\t\t\t\t},\n\n\t\t\t\t\tgetPointBorderWidth: function getPointBorderWidth(point, index) {\n\t\t\t\t\t\tvar borderWidth = this.chart.options.elements.point.borderWidth;\n\t\t\t\t\t\tvar dataset = this.getDataset();\n\t\t\t\t\t\tvar custom = point.custom || {};\n\n\t\t\t\t\t\tif (!isNaN(custom.borderWidth)) {\n\t\t\t\t\t\t\tborderWidth = custom.borderWidth;\n\t\t\t\t\t\t} else if (!isNaN(dataset.pointBorderWidth)) {\n\t\t\t\t\t\t\tborderWidth = helpers.getValueAtIndexOrDefault(dataset.pointBorderWidth, index, borderWidth);\n\t\t\t\t\t\t} else if (!isNaN(dataset.borderWidth)) {\n\t\t\t\t\t\t\tborderWidth = dataset.borderWidth;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn borderWidth;\n\t\t\t\t\t},\n\n\t\t\t\t\tupdateElement: function updateElement(point, index, reset) {\n\t\t\t\t\t\tvar me = this;\n\t\t\t\t\t\tvar meta = me.getMeta();\n\t\t\t\t\t\tvar custom = point.custom || {};\n\t\t\t\t\t\tvar dataset = me.getDataset();\n\t\t\t\t\t\tvar datasetIndex = me.index;\n\t\t\t\t\t\tvar value = dataset.data[index];\n\t\t\t\t\t\tvar yScale = me.getScaleForId(meta.yAxisID);\n\t\t\t\t\t\tvar xScale = me.getScaleForId(meta.xAxisID);\n\t\t\t\t\t\tvar pointOptions = me.chart.options.elements.point;\n\t\t\t\t\t\tvar x, y;\n\t\t\t\t\t\tvar labels = me.chart.data.labels || [];\n\t\t\t\t\t\tvar includeOffset = labels.length === 1 || dataset.data.length === 1 || me.chart.isCombo;\n\n\t\t\t\t\t\t// Compatibility: If the properties are defined with only the old name, use those values\n\t\t\t\t\t\tif (dataset.radius !== undefined && dataset.pointRadius === undefined) {\n\t\t\t\t\t\t\tdataset.pointRadius = dataset.radius;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (dataset.hitRadius !== undefined && dataset.pointHitRadius === undefined) {\n\t\t\t\t\t\t\tdataset.pointHitRadius = dataset.hitRadius;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tx = xScale.getPixelForValue((typeof value === \"undefined\" ? \"undefined\" : _typeof(value)) === 'object' ? value : NaN, index, datasetIndex, includeOffset);\n\t\t\t\t\t\ty = reset ? yScale.getBasePixel() : me.calculatePointY(value, index, datasetIndex);\n\n\t\t\t\t\t\t// Utility\n\t\t\t\t\t\tpoint._xScale = xScale;\n\t\t\t\t\t\tpoint._yScale = yScale;\n\t\t\t\t\t\tpoint._datasetIndex = datasetIndex;\n\t\t\t\t\t\tpoint._index = index;\n\n\t\t\t\t\t\t// Desired view properties\n\t\t\t\t\t\tpoint._model = {\n\t\t\t\t\t\t\tx: x,\n\t\t\t\t\t\t\ty: y,\n\t\t\t\t\t\t\tskip: custom.skip || isNaN(x) || isNaN(y),\n\t\t\t\t\t\t\t// Appearance\n\t\t\t\t\t\t\tradius: custom.radius || helpers.getValueAtIndexOrDefault(dataset.pointRadius, index, pointOptions.radius),\n\t\t\t\t\t\t\tpointStyle: custom.pointStyle || helpers.getValueAtIndexOrDefault(dataset.pointStyle, index, pointOptions.pointStyle),\n\t\t\t\t\t\t\tbackgroundColor: me.getPointBackgroundColor(point, index),\n\t\t\t\t\t\t\tborderColor: me.getPointBorderColor(point, index),\n\t\t\t\t\t\t\tborderWidth: me.getPointBorderWidth(point, index),\n\t\t\t\t\t\t\ttension: meta.dataset._model ? meta.dataset._model.tension : 0,\n\t\t\t\t\t\t\tsteppedLine: meta.dataset._model ? meta.dataset._model.steppedLine : false,\n\t\t\t\t\t\t\t// Tooltip\n\t\t\t\t\t\t\thitRadius: custom.hitRadius || helpers.getValueAtIndexOrDefault(dataset.pointHitRadius, index, pointOptions.hitRadius)\n\t\t\t\t\t\t};\n\t\t\t\t\t},\n\n\t\t\t\t\tcalculatePointY: function calculatePointY(value, index, datasetIndex) {\n\t\t\t\t\t\tvar me = this;\n\t\t\t\t\t\tvar chart = me.chart;\n\t\t\t\t\t\tvar meta = me.getMeta();\n\t\t\t\t\t\tvar yScale = me.getScaleForId(meta.yAxisID);\n\t\t\t\t\t\tvar sumPos = 0;\n\t\t\t\t\t\tvar sumNeg = 0;\n\t\t\t\t\t\tvar i, ds, dsMeta;\n\n\t\t\t\t\t\tif (yScale.options.stacked) {\n\t\t\t\t\t\t\tfor (i = 0; i < datasetIndex; i++) {\n\t\t\t\t\t\t\t\tds = chart.data.datasets[i];\n\t\t\t\t\t\t\t\tdsMeta = chart.getDatasetMeta(i);\n\t\t\t\t\t\t\t\tif (dsMeta.type === 'line' && dsMeta.yAxisID === yScale.id && chart.isDatasetVisible(i)) {\n\t\t\t\t\t\t\t\t\tvar stackedRightValue = Number(yScale.getRightValue(ds.data[index]));\n\t\t\t\t\t\t\t\t\tif (stackedRightValue < 0) {\n\t\t\t\t\t\t\t\t\t\tsumNeg += stackedRightValue || 0;\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tsumPos += stackedRightValue || 0;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tvar rightValue = Number(yScale.getRightValue(value));\n\t\t\t\t\t\t\tif (rightValue < 0) {\n\t\t\t\t\t\t\t\treturn yScale.getPixelForValue(sumNeg + rightValue);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn yScale.getPixelForValue(sumPos + rightValue);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn yScale.getPixelForValue(value);\n\t\t\t\t\t},\n\n\t\t\t\t\tupdateBezierControlPoints: function updateBezierControlPoints() {\n\t\t\t\t\t\tvar me = this;\n\t\t\t\t\t\tvar meta = me.getMeta();\n\t\t\t\t\t\tvar area = me.chart.chartArea;\n\t\t\t\t\t\tvar points = meta.data || [];\n\t\t\t\t\t\tvar i, ilen, point, model, controlPoints;\n\n\t\t\t\t\t\t// Only consider points that are drawn in case the spanGaps option is used\n\t\t\t\t\t\tif (meta.dataset._model.spanGaps) {\n\t\t\t\t\t\t\tpoints = points.filter(function (pt) {\n\t\t\t\t\t\t\t\treturn !pt._model.skip;\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfunction capControlPoint(pt, min, max) {\n\t\t\t\t\t\t\treturn Math.max(Math.min(pt, max), min);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (meta.dataset._model.cubicInterpolationMode === 'monotone') {\n\t\t\t\t\t\t\thelpers.splineCurveMonotone(points);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfor (i = 0, ilen = points.length; i < ilen; ++i) {\n\t\t\t\t\t\t\t\tpoint = points[i];\n\t\t\t\t\t\t\t\tmodel = point._model;\n\t\t\t\t\t\t\t\tcontrolPoints = helpers.splineCurve(helpers.previousItem(points, i)._model, model, helpers.nextItem(points, i)._model, meta.dataset._model.tension);\n\t\t\t\t\t\t\t\tmodel.controlPointPreviousX = controlPoints.previous.x;\n\t\t\t\t\t\t\t\tmodel.controlPointPreviousY = controlPoints.previous.y;\n\t\t\t\t\t\t\t\tmodel.controlPointNextX = controlPoints.next.x;\n\t\t\t\t\t\t\t\tmodel.controlPointNextY = controlPoints.next.y;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (me.chart.options.elements.line.capBezierPoints) {\n\t\t\t\t\t\t\tfor (i = 0, ilen = points.length; i < ilen; ++i) {\n\t\t\t\t\t\t\t\tmodel = points[i]._model;\n\t\t\t\t\t\t\t\tmodel.controlPointPreviousX = capControlPoint(model.controlPointPreviousX, area.left, area.right);\n\t\t\t\t\t\t\t\tmodel.controlPointPreviousY = capControlPoint(model.controlPointPreviousY, area.top, area.bottom);\n\t\t\t\t\t\t\t\tmodel.controlPointNextX = capControlPoint(model.controlPointNextX, area.left, area.right);\n\t\t\t\t\t\t\t\tmodel.controlPointNextY = capControlPoint(model.controlPointNextY, area.top, area.bottom);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\n\t\t\t\t\tdraw: function draw(ease) {\n\t\t\t\t\t\tvar me = this;\n\t\t\t\t\t\tvar meta = me.getMeta();\n\t\t\t\t\t\tvar points = meta.data || [];\n\t\t\t\t\t\tvar easingDecimal = ease || 1;\n\t\t\t\t\t\tvar i, ilen;\n\n\t\t\t\t\t\t// Transition Point Locations\n\t\t\t\t\t\tfor (i = 0, ilen = points.length; i < ilen; ++i) {\n\t\t\t\t\t\t\tpoints[i].transition(easingDecimal);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tChart.canvasHelpers.clipArea(me.chart.chart.ctx, me.chart.chartArea);\n\t\t\t\t\t\t// Transition and Draw the line\n\t\t\t\t\t\tif (lineEnabled(me.getDataset(), me.chart.options)) {\n\t\t\t\t\t\t\tmeta.dataset.transition(easingDecimal).draw();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tChart.canvasHelpers.unclipArea(me.chart.chart.ctx);\n\n\t\t\t\t\t\t// Draw the points\n\t\t\t\t\t\tfor (i = 0, ilen = points.length; i < ilen; ++i) {\n\t\t\t\t\t\t\tpoints[i].draw(me.chart.chartArea);\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\n\t\t\t\t\tsetHoverStyle: function setHoverStyle(point) {\n\t\t\t\t\t\t// Point\n\t\t\t\t\t\tvar dataset = this.chart.data.datasets[point._datasetIndex];\n\t\t\t\t\t\tvar index = point._index;\n\t\t\t\t\t\tvar custom = point.custom || {};\n\t\t\t\t\t\tvar model = point._model;\n\n\t\t\t\t\t\tmodel.radius = custom.hoverRadius || helpers.getValueAtIndexOrDefault(dataset.pointHoverRadius, index, this.chart.options.elements.point.hoverRadius);\n\t\t\t\t\t\tmodel.backgroundColor = custom.hoverBackgroundColor || helpers.getValueAtIndexOrDefault(dataset.pointHoverBackgroundColor, index, helpers.getHoverColor(model.backgroundColor));\n\t\t\t\t\t\tmodel.borderColor = custom.hoverBorderColor || helpers.getValueAtIndexOrDefault(dataset.pointHoverBorderColor, index, helpers.getHoverColor(model.borderColor));\n\t\t\t\t\t\tmodel.borderWidth = custom.hoverBorderWidth || helpers.getValueAtIndexOrDefault(dataset.pointHoverBorderWidth, index, model.borderWidth);\n\t\t\t\t\t},\n\n\t\t\t\t\tremoveHoverStyle: function removeHoverStyle(point) {\n\t\t\t\t\t\tvar me = this;\n\t\t\t\t\t\tvar dataset = me.chart.data.datasets[point._datasetIndex];\n\t\t\t\t\t\tvar index = point._index;\n\t\t\t\t\t\tvar custom = point.custom || {};\n\t\t\t\t\t\tvar model = point._model;\n\n\t\t\t\t\t\t// Compatibility: If the properties are defined with only the old name, use those values\n\t\t\t\t\t\tif (dataset.radius !== undefined && dataset.pointRadius === undefined) {\n\t\t\t\t\t\t\tdataset.pointRadius = dataset.radius;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tmodel.radius = custom.radius || helpers.getValueAtIndexOrDefault(dataset.pointRadius, index, me.chart.options.elements.point.radius);\n\t\t\t\t\t\tmodel.backgroundColor = me.getPointBackgroundColor(point, index);\n\t\t\t\t\t\tmodel.borderColor = me.getPointBorderColor(point, index);\n\t\t\t\t\t\tmodel.borderWidth = me.getPointBorderWidth(point, index);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t};\n\t\t}, {}], 19: [function (require, module, exports) {\n\t\t\t'use strict';\n\n\t\t\tmodule.exports = function (Chart) {\n\n\t\t\t\tvar helpers = Chart.helpers;\n\n\t\t\t\tChart.defaults.polarArea = {\n\n\t\t\t\t\tscale: {\n\t\t\t\t\t\ttype: 'radialLinear',\n\t\t\t\t\t\tlineArc: true, // so that lines are circular\n\t\t\t\t\t\tticks: {\n\t\t\t\t\t\t\tbeginAtZero: true\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\n\t\t\t\t\t// Boolean - Whether to animate the rotation of the chart\n\t\t\t\t\tanimation: {\n\t\t\t\t\t\tanimateRotate: true,\n\t\t\t\t\t\tanimateScale: true\n\t\t\t\t\t},\n\n\t\t\t\t\tstartAngle: -0.5 * Math.PI,\n\t\t\t\t\taspectRatio: 1,\n\t\t\t\t\tlegendCallback: function legendCallback(chart) {\n\t\t\t\t\t\tvar text = [];\n\t\t\t\t\t\ttext.push('<ul class=\"' + chart.id + '-legend\">');\n\n\t\t\t\t\t\tvar data = chart.data;\n\t\t\t\t\t\tvar datasets = data.datasets;\n\t\t\t\t\t\tvar labels = data.labels;\n\n\t\t\t\t\t\tif (datasets.length) {\n\t\t\t\t\t\t\tfor (var i = 0; i < datasets[0].data.length; ++i) {\n\t\t\t\t\t\t\t\ttext.push('<li><span style=\"background-color:' + datasets[0].backgroundColor[i] + '\"></span>');\n\t\t\t\t\t\t\t\tif (labels[i]) {\n\t\t\t\t\t\t\t\t\ttext.push(labels[i]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\ttext.push('</li>');\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttext.push('</ul>');\n\t\t\t\t\t\treturn text.join('');\n\t\t\t\t\t},\n\t\t\t\t\tlegend: {\n\t\t\t\t\t\tlabels: {\n\t\t\t\t\t\t\tgenerateLabels: function generateLabels(chart) {\n\t\t\t\t\t\t\t\tvar data = chart.data;\n\t\t\t\t\t\t\t\tif (data.labels.length && data.datasets.length) {\n\t\t\t\t\t\t\t\t\treturn data.labels.map(function (label, i) {\n\t\t\t\t\t\t\t\t\t\tvar meta = chart.getDatasetMeta(0);\n\t\t\t\t\t\t\t\t\t\tvar ds = data.datasets[0];\n\t\t\t\t\t\t\t\t\t\tvar arc = meta.data[i];\n\t\t\t\t\t\t\t\t\t\tvar custom = arc.custom || {};\n\t\t\t\t\t\t\t\t\t\tvar getValueAtIndexOrDefault = helpers.getValueAtIndexOrDefault;\n\t\t\t\t\t\t\t\t\t\tvar arcOpts = chart.options.elements.arc;\n\t\t\t\t\t\t\t\t\t\tvar fill = custom.backgroundColor ? custom.backgroundColor : getValueAtIndexOrDefault(ds.backgroundColor, i, arcOpts.backgroundColor);\n\t\t\t\t\t\t\t\t\t\tvar stroke = custom.borderColor ? custom.borderColor : getValueAtIndexOrDefault(ds.borderColor, i, arcOpts.borderColor);\n\t\t\t\t\t\t\t\t\t\tvar bw = custom.borderWidth ? custom.borderWidth : getValueAtIndexOrDefault(ds.borderWidth, i, arcOpts.borderWidth);\n\n\t\t\t\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\t\t\t\ttext: label,\n\t\t\t\t\t\t\t\t\t\t\tfillStyle: fill,\n\t\t\t\t\t\t\t\t\t\t\tstrokeStyle: stroke,\n\t\t\t\t\t\t\t\t\t\t\tlineWidth: bw,\n\t\t\t\t\t\t\t\t\t\t\thidden: isNaN(ds.data[i]) || meta.data[i].hidden,\n\n\t\t\t\t\t\t\t\t\t\t\t// Extra data used for toggling the correct item\n\t\t\t\t\t\t\t\t\t\t\tindex: i\n\t\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn [];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tonClick: function onClick(e, legendItem) {\n\t\t\t\t\t\t\tvar index = legendItem.index;\n\t\t\t\t\t\t\tvar chart = this.chart;\n\t\t\t\t\t\t\tvar i, ilen, meta;\n\n\t\t\t\t\t\t\tfor (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {\n\t\t\t\t\t\t\t\tmeta = chart.getDatasetMeta(i);\n\t\t\t\t\t\t\t\tmeta.data[index].hidden = !meta.data[index].hidden;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tchart.update();\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\n\t\t\t\t\t// Need to override these to give a nice default\n\t\t\t\t\ttooltips: {\n\t\t\t\t\t\tcallbacks: {\n\t\t\t\t\t\t\ttitle: function title() {\n\t\t\t\t\t\t\t\treturn '';\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tlabel: function label(tooltipItem, data) {\n\t\t\t\t\t\t\t\treturn data.labels[tooltipItem.index] + ': ' + tooltipItem.yLabel;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\tChart.controllers.polarArea = Chart.DatasetController.extend({\n\n\t\t\t\t\tdataElementType: Chart.elements.Arc,\n\n\t\t\t\t\tlinkScales: helpers.noop,\n\n\t\t\t\t\tupdate: function update(reset) {\n\t\t\t\t\t\tvar me = this;\n\t\t\t\t\t\tvar chart = me.chart;\n\t\t\t\t\t\tvar chartArea = chart.chartArea;\n\t\t\t\t\t\tvar meta = me.getMeta();\n\t\t\t\t\t\tvar opts = chart.options;\n\t\t\t\t\t\tvar arcOpts = opts.elements.arc;\n\t\t\t\t\t\tvar minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);\n\t\t\t\t\t\tchart.outerRadius = Math.max((minSize - arcOpts.borderWidth / 2) / 2, 0);\n\t\t\t\t\t\tchart.innerRadius = Math.max(opts.cutoutPercentage ? chart.outerRadius / 100 * opts.cutoutPercentage : 1, 0);\n\t\t\t\t\t\tchart.radiusLength = (chart.outerRadius - chart.innerRadius) / chart.getVisibleDatasetCount();\n\n\t\t\t\t\t\tme.outerRadius = chart.outerRadius - chart.radiusLength * me.index;\n\t\t\t\t\t\tme.innerRadius = me.outerRadius - chart.radiusLength;\n\n\t\t\t\t\t\tmeta.count = me.countVisibleElements();\n\n\t\t\t\t\t\thelpers.each(meta.data, function (arc, index) {\n\t\t\t\t\t\t\tme.updateElement(arc, index, reset);\n\t\t\t\t\t\t});\n\t\t\t\t\t},\n\n\t\t\t\t\tupdateElement: function updateElement(arc, index, reset) {\n\t\t\t\t\t\tvar me = this;\n\t\t\t\t\t\tvar chart = me.chart;\n\t\t\t\t\t\tvar dataset = me.getDataset();\n\t\t\t\t\t\tvar opts = chart.options;\n\t\t\t\t\t\tvar animationOpts = opts.animation;\n\t\t\t\t\t\tvar scale = chart.scale;\n\t\t\t\t\t\tvar getValueAtIndexOrDefault = helpers.getValueAtIndexOrDefault;\n\t\t\t\t\t\tvar labels = chart.data.labels;\n\n\t\t\t\t\t\tvar circumference = me.calculateCircumference(dataset.data[index]);\n\t\t\t\t\t\tvar centerX = scale.xCenter;\n\t\t\t\t\t\tvar centerY = scale.yCenter;\n\n\t\t\t\t\t\t// If there is NaN data before us, we need to calculate the starting angle correctly.\n\t\t\t\t\t\t// We could be way more efficient here, but its unlikely that the polar area chart will have a lot of data\n\t\t\t\t\t\tvar visibleCount = 0;\n\t\t\t\t\t\tvar meta = me.getMeta();\n\t\t\t\t\t\tfor (var i = 0; i < index; ++i) {\n\t\t\t\t\t\t\tif (!isNaN(dataset.data[i]) && !meta.data[i].hidden) {\n\t\t\t\t\t\t\t\t++visibleCount;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// var negHalfPI = -0.5 * Math.PI;\n\t\t\t\t\t\tvar datasetStartAngle = opts.startAngle;\n\t\t\t\t\t\tvar distance = arc.hidden ? 0 : scale.getDistanceFromCenterForValue(dataset.data[index]);\n\t\t\t\t\t\tvar startAngle = datasetStartAngle + circumference * visibleCount;\n\t\t\t\t\t\tvar endAngle = startAngle + (arc.hidden ? 0 : circumference);\n\n\t\t\t\t\t\tvar resetRadius = animationOpts.animateScale ? 0 : scale.getDistanceFromCenterForValue(dataset.data[index]);\n\n\t\t\t\t\t\thelpers.extend(arc, {\n\t\t\t\t\t\t\t// Utility\n\t\t\t\t\t\t\t_datasetIndex: me.index,\n\t\t\t\t\t\t\t_index: index,\n\t\t\t\t\t\t\t_scale: scale,\n\n\t\t\t\t\t\t\t// Desired view properties\n\t\t\t\t\t\t\t_model: {\n\t\t\t\t\t\t\t\tx: centerX,\n\t\t\t\t\t\t\t\ty: centerY,\n\t\t\t\t\t\t\t\tinnerRadius: 0,\n\t\t\t\t\t\t\t\touterRadius: reset ? resetRadius : distance,\n\t\t\t\t\t\t\t\tstartAngle: reset && animationOpts.animateRotate ? datasetStartAngle : startAngle,\n\t\t\t\t\t\t\t\tendAngle: reset && animationOpts.animateRotate ? datasetStartAngle : endAngle,\n\t\t\t\t\t\t\t\tlabel: getValueAtIndexOrDefault(labels, index, labels[index])\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\t// Apply border and fill style\n\t\t\t\t\t\tme.removeHoverStyle(arc);\n\n\t\t\t\t\t\tarc.pivot();\n\t\t\t\t\t},\n\n\t\t\t\t\tremoveHoverStyle: function removeHoverStyle(arc) {\n\t\t\t\t\t\tChart.DatasetController.prototype.removeHoverStyle.call(this, arc, this.chart.options.elements.arc);\n\t\t\t\t\t},\n\n\t\t\t\t\tcountVisibleElements: function countVisibleElements() {\n\t\t\t\t\t\tvar dataset = this.getDataset();\n\t\t\t\t\t\tvar meta = this.getMeta();\n\t\t\t\t\t\tvar count = 0;\n\n\t\t\t\t\t\thelpers.each(meta.data, function (element, index) {\n\t\t\t\t\t\t\tif (!isNaN(dataset.data[index]) && !element.hidden) {\n\t\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\treturn count;\n\t\t\t\t\t},\n\n\t\t\t\t\tcalculateCircumference: function calculateCircumference(value) {\n\t\t\t\t\t\tvar count = this.getMeta().count;\n\t\t\t\t\t\tif (count > 0 && !isNaN(value)) {\n\t\t\t\t\t\t\treturn 2 * Math.PI / count;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t};\n\t\t}, {}], 20: [function (require, module, exports) {\n\t\t\t'use strict';\n\n\t\t\tmodule.exports = function (Chart) {\n\n\t\t\t\tvar helpers = Chart.helpers;\n\n\t\t\t\tChart.defaults.radar = {\n\t\t\t\t\taspectRatio: 1,\n\t\t\t\t\tscale: {\n\t\t\t\t\t\ttype: 'radialLinear'\n\t\t\t\t\t},\n\t\t\t\t\telements: {\n\t\t\t\t\t\tline: {\n\t\t\t\t\t\t\ttension: 0 // no bezier in radar\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\tChart.controllers.radar = Chart.DatasetController.extend({\n\n\t\t\t\t\tdatasetElementType: Chart.elements.Line,\n\n\t\t\t\t\tdataElementType: Chart.elements.Point,\n\n\t\t\t\t\tlinkScales: helpers.noop,\n\n\t\t\t\t\tupdate: function update(reset) {\n\t\t\t\t\t\tvar me = this;\n\t\t\t\t\t\tvar meta = me.getMeta();\n\t\t\t\t\t\tvar line = meta.dataset;\n\t\t\t\t\t\tvar points = meta.data;\n\t\t\t\t\t\tvar custom = line.custom || {};\n\t\t\t\t\t\tvar dataset = me.getDataset();\n\t\t\t\t\t\tvar lineElementOptions = me.chart.options.elements.line;\n\t\t\t\t\t\tvar scale = me.chart.scale;\n\n\t\t\t\t\t\t// Compatibility: If the properties are defined with only the old name, use those values\n\t\t\t\t\t\tif (dataset.tension !== undefined && dataset.lineTension === undefined) {\n\t\t\t\t\t\t\tdataset.lineTension = dataset.tension;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\thelpers.extend(meta.dataset, {\n\t\t\t\t\t\t\t// Utility\n\t\t\t\t\t\t\t_datasetIndex: me.index,\n\t\t\t\t\t\t\t// Data\n\t\t\t\t\t\t\t_children: points,\n\t\t\t\t\t\t\t_loop: true,\n\t\t\t\t\t\t\t// Model\n\t\t\t\t\t\t\t_model: {\n\t\t\t\t\t\t\t\t// Appearance\n\t\t\t\t\t\t\t\ttension: custom.tension ? custom.tension : helpers.getValueOrDefault(dataset.lineTension, lineElementOptions.tension),\n\t\t\t\t\t\t\t\tbackgroundColor: custom.backgroundColor ? custom.backgroundColor : dataset.backgroundColor || lineElementOptions.backgroundColor,\n\t\t\t\t\t\t\t\tborderWidth: custom.borderWidth ? custom.borderWidth : dataset.borderWidth || lineElementOptions.borderWidth,\n\t\t\t\t\t\t\t\tborderColor: custom.borderColor ? custom.borderColor : dataset.borderColor || lineElementOptions.borderColor,\n\t\t\t\t\t\t\t\tfill: custom.fill ? custom.fill : dataset.fill !== undefined ? dataset.fill : lineElementOptions.fill,\n\t\t\t\t\t\t\t\tborderCapStyle: custom.borderCapStyle ? custom.borderCapStyle : dataset.borderCapStyle || lineElementOptions.borderCapStyle,\n\t\t\t\t\t\t\t\tborderDash: custom.borderDash ? custom.borderDash : dataset.borderDash || lineElementOptions.borderDash,\n\t\t\t\t\t\t\t\tborderDashOffset: custom.borderDashOffset ? custom.borderDashOffset : dataset.borderDashOffset || lineElementOptions.borderDashOffset,\n\t\t\t\t\t\t\t\tborderJoinStyle: custom.borderJoinStyle ? custom.borderJoinStyle : dataset.borderJoinStyle || lineElementOptions.borderJoinStyle,\n\n\t\t\t\t\t\t\t\t// Scale\n\t\t\t\t\t\t\t\tscaleTop: scale.top,\n\t\t\t\t\t\t\t\tscaleBottom: scale.bottom,\n\t\t\t\t\t\t\t\tscaleZero: scale.getBasePosition()\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tmeta.dataset.pivot();\n\n\t\t\t\t\t\t// Update Points\n\t\t\t\t\t\thelpers.each(points, function (point, index) {\n\t\t\t\t\t\t\tme.updateElement(point, index, reset);\n\t\t\t\t\t\t}, me);\n\n\t\t\t\t\t\t// Update bezier control points\n\t\t\t\t\t\tme.updateBezierControlPoints();\n\t\t\t\t\t},\n\t\t\t\t\tupdateElement: function updateElement(point, index, reset) {\n\t\t\t\t\t\tvar me = this;\n\t\t\t\t\t\tvar custom = point.custom || {};\n\t\t\t\t\t\tvar dataset = me.getDataset();\n\t\t\t\t\t\tvar scale = me.chart.scale;\n\t\t\t\t\t\tvar pointElementOptions = me.chart.options.elements.point;\n\t\t\t\t\t\tvar pointPosition = scale.getPointPositionForValue(index, dataset.data[index]);\n\n\t\t\t\t\t\thelpers.extend(point, {\n\t\t\t\t\t\t\t// Utility\n\t\t\t\t\t\t\t_datasetIndex: me.index,\n\t\t\t\t\t\t\t_index: index,\n\t\t\t\t\t\t\t_scale: scale,\n\n\t\t\t\t\t\t\t// Desired view properties\n\t\t\t\t\t\t\t_model: {\n\t\t\t\t\t\t\t\tx: reset ? scale.xCenter : pointPosition.x, // value not used in dataset scale, but we want a consistent API between scales\n\t\t\t\t\t\t\t\ty: reset ? scale.yCenter : pointPosition.y,\n\n\t\t\t\t\t\t\t\t// Appearance\n\t\t\t\t\t\t\t\ttension: custom.tension ? custom.tension : helpers.getValueOrDefault(dataset.lineTension, me.chart.options.elements.line.tension),\n\t\t\t\t\t\t\t\tradius: custom.radius ? custom.radius : helpers.getValueAtIndexOrDefault(dataset.pointRadius, index, pointElementOptions.radius),\n\t\t\t\t\t\t\t\tbackgroundColor: custom.backgroundColor ? custom.backgroundColor : helpers.getValueAtIndexOrDefault(dataset.pointBackgroundColor, index, pointElementOptions.backgroundColor),\n\t\t\t\t\t\t\t\tborderColor: custom.borderColor ? custom.borderColor : helpers.getValueAtIndexOrDefault(dataset.pointBorderColor, index, pointElementOptions.borderColor),\n\t\t\t\t\t\t\t\tborderWidth: custom.borderWidth ? custom.borderWidth : helpers.getValueAtIndexOrDefault(dataset.pointBorderWidth, index, pointElementOptions.borderWidth),\n\t\t\t\t\t\t\t\tpointStyle: custom.pointStyle ? custom.pointStyle : helpers.getValueAtIndexOrDefault(dataset.pointStyle, index, pointElementOptions.pointStyle),\n\n\t\t\t\t\t\t\t\t// Tooltip\n\t\t\t\t\t\t\t\thitRadius: custom.hitRadius ? custom.hitRadius : helpers.getValueAtIndexOrDefault(dataset.hitRadius, index, pointElementOptions.hitRadius)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tpoint._model.skip = custom.skip ? custom.skip : isNaN(point._model.x) || isNaN(point._model.y);\n\t\t\t\t\t},\n\t\t\t\t\tupdateBezierControlPoints: function updateBezierControlPoints() {\n\t\t\t\t\t\tvar chartArea = this.chart.chartArea;\n\t\t\t\t\t\tvar meta = this.getMeta();\n\n\t\t\t\t\t\thelpers.each(meta.data, function (point, index) {\n\t\t\t\t\t\t\tvar model = point._model;\n\t\t\t\t\t\t\tvar controlPoints = helpers.splineCurve(helpers.previousItem(meta.data, index, true)._model, model, helpers.nextItem(meta.data, index, true)._model, model.tension);\n\n\t\t\t\t\t\t\t// Prevent the bezier going outside of the bounds of the graph\n\t\t\t\t\t\t\tmodel.controlPointPreviousX = Math.max(Math.min(controlPoints.previous.x, chartArea.right), chartArea.left);\n\t\t\t\t\t\t\tmodel.controlPointPreviousY = Math.max(Math.min(controlPoints.previous.y, chartArea.bottom), chartArea.top);\n\n\t\t\t\t\t\t\tmodel.controlPointNextX = Math.max(Math.min(controlPoints.next.x, chartArea.right), chartArea.left);\n\t\t\t\t\t\t\tmodel.controlPointNextY = Math.max(Math.min(controlPoints.next.y, chartArea.bottom), chartArea.top);\n\n\t\t\t\t\t\t\t// Now pivot the point for animation\n\t\t\t\t\t\t\tpoint.pivot();\n\t\t\t\t\t\t});\n\t\t\t\t\t},\n\n\t\t\t\t\tdraw: function draw(ease) {\n\t\t\t\t\t\tvar meta = this.getMeta();\n\t\t\t\t\t\tvar easingDecimal = ease || 1;\n\n\t\t\t\t\t\t// Transition Point Locations\n\t\t\t\t\t\thelpers.each(meta.data, function (point) {\n\t\t\t\t\t\t\tpoint.transition(easingDecimal);\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\t// Transition and Draw the line\n\t\t\t\t\t\tmeta.dataset.transition(easingDecimal).draw();\n\n\t\t\t\t\t\t// Draw the points\n\t\t\t\t\t\thelpers.each(meta.data, function (point) {\n\t\t\t\t\t\t\tpoint.draw();\n\t\t\t\t\t\t});\n\t\t\t\t\t},\n\n\t\t\t\t\tsetHoverStyle: function setHoverStyle(point) {\n\t\t\t\t\t\t// Point\n\t\t\t\t\t\tvar dataset = this.chart.data.datasets[point._datasetIndex];\n\t\t\t\t\t\tvar custom = point.custom || {};\n\t\t\t\t\t\tvar index = point._index;\n\t\t\t\t\t\tvar model = point._model;\n\n\t\t\t\t\t\tmodel.radius = custom.hoverRadius ? custom.hoverRadius : helpers.getValueAtIndexOrDefault(dataset.pointHoverRadius, index, this.chart.options.elements.point.hoverRadius);\n\t\t\t\t\t\tmodel.backgroundColor = custom.hoverBackgroundColor ? custom.hoverBackgroundColor : helpers.getValueAtIndexOrDefault(dataset.pointHoverBackgroundColor, index, helpers.getHoverColor(model.backgroundColor));\n\t\t\t\t\t\tmodel.borderColor = custom.hoverBorderColor ? custom.hoverBorderColor : helpers.getValueAtIndexOrDefault(dataset.pointHoverBorderColor, index, helpers.getHoverColor(model.borderColor));\n\t\t\t\t\t\tmodel.borderWidth = custom.hoverBorderWidth ? custom.hoverBorderWidth : helpers.getValueAtIndexOrDefault(dataset.pointHoverBorderWidth, index, model.borderWidth);\n\t\t\t\t\t},\n\n\t\t\t\t\tremoveHoverStyle: function removeHoverStyle(point) {\n\t\t\t\t\t\tvar dataset = this.chart.data.datasets[point._datasetIndex];\n\t\t\t\t\t\tvar custom = point.custom || {};\n\t\t\t\t\t\tvar index = point._index;\n\t\t\t\t\t\tvar model = point._model;\n\t\t\t\t\t\tvar pointElementOptions = this.chart.options.elements.point;\n\n\t\t\t\t\t\tmodel.radius = custom.radius ? custom.radius : helpers.getValueAtIndexOrDefault(dataset.radius, index, pointElementOptions.radius);\n\t\t\t\t\t\tmodel.backgroundColor = custom.backgroundColor ? custom.backgroundColor : helpers.getValueAtIndexOrDefault(dataset.pointBackgroundColor, index, pointElementOptions.backgroundColor);\n\t\t\t\t\t\tmodel.borderColor = custom.borderColor ? custom.borderColor : helpers.getValueAtIndexOrDefault(dataset.pointBorderColor, index, pointElementOptions.borderColor);\n\t\t\t\t\t\tmodel.borderWidth = custom.borderWidth ? custom.borderWidth : helpers.getValueAtIndexOrDefault(dataset.pointBorderWidth, index, pointElementOptions.borderWidth);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t};\n\t\t}, {}], 21: [function (require, module, exports) {\n\t\t\t/* global window: false */\n\t\t\t'use strict';\n\n\t\t\tmodule.exports = function (Chart) {\n\n\t\t\t\tvar helpers = Chart.helpers;\n\n\t\t\t\tChart.defaults.global.animation = {\n\t\t\t\t\tduration: 1000,\n\t\t\t\t\teasing: 'easeOutQuart',\n\t\t\t\t\tonProgress: helpers.noop,\n\t\t\t\t\tonComplete: helpers.noop\n\t\t\t\t};\n\n\t\t\t\tChart.Animation = Chart.Element.extend({\n\t\t\t\t\tcurrentStep: null, // the current animation step\n\t\t\t\t\tnumSteps: 60, // default number of steps\n\t\t\t\t\teasing: '', // the easing to use for this animation\n\t\t\t\t\trender: null, // render function used by the animation service\n\n\t\t\t\t\tonAnimationProgress: null, // user specified callback to fire on each step of the animation\n\t\t\t\t\tonAnimationComplete: null // user specified callback to fire when the animation finishes\n\t\t\t\t});\n\n\t\t\t\tChart.animationService = {\n\t\t\t\t\tframeDuration: 17,\n\t\t\t\t\tanimations: [],\n\t\t\t\t\tdropFrames: 0,\n\t\t\t\t\trequest: null,\n\n\t\t\t\t\t/**\n      * @function Chart.animationService.addAnimation\n      * @param chartInstance {ChartController} the chart to animate\n      * @param animationObject {IAnimation} the animation that we will animate\n      * @param duration {Number} length of animation in ms\n      * @param lazy {Boolean} if true, the chart is not marked as animating to enable more responsive interactions\n      */\n\t\t\t\t\taddAnimation: function addAnimation(chartInstance, animationObject, duration, lazy) {\n\t\t\t\t\t\tvar me = this;\n\n\t\t\t\t\t\tif (!lazy) {\n\t\t\t\t\t\t\tchartInstance.animating = true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfor (var index = 0; index < me.animations.length; ++index) {\n\t\t\t\t\t\t\tif (me.animations[index].chartInstance === chartInstance) {\n\t\t\t\t\t\t\t\t// replacing an in progress animation\n\t\t\t\t\t\t\t\tme.animations[index].animationObject = animationObject;\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tme.animations.push({\n\t\t\t\t\t\t\tchartInstance: chartInstance,\n\t\t\t\t\t\t\tanimationObject: animationObject\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\t// If there are no animations queued, manually kickstart a digest, for lack of a better word\n\t\t\t\t\t\tif (me.animations.length === 1) {\n\t\t\t\t\t\t\tme.requestAnimationFrame();\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t// Cancel the animation for a given chart instance\n\t\t\t\t\tcancelAnimation: function cancelAnimation(chartInstance) {\n\t\t\t\t\t\tvar index = helpers.findIndex(this.animations, function (animationWrapper) {\n\t\t\t\t\t\t\treturn animationWrapper.chartInstance === chartInstance;\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tif (index !== -1) {\n\t\t\t\t\t\t\tthis.animations.splice(index, 1);\n\t\t\t\t\t\t\tchartInstance.animating = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\trequestAnimationFrame: function requestAnimationFrame() {\n\t\t\t\t\t\tvar me = this;\n\t\t\t\t\t\tif (me.request === null) {\n\t\t\t\t\t\t\t// Skip animation frame requests until the active one is executed.\n\t\t\t\t\t\t\t// This can happen when processing mouse events, e.g. 'mousemove'\n\t\t\t\t\t\t\t// and 'mouseout' events will trigger multiple renders.\n\t\t\t\t\t\t\tme.request = helpers.requestAnimFrame.call(window, function () {\n\t\t\t\t\t\t\t\tme.request = null;\n\t\t\t\t\t\t\t\tme.startDigest();\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tstartDigest: function startDigest() {\n\t\t\t\t\t\tvar me = this;\n\n\t\t\t\t\t\tvar startTime = Date.now();\n\t\t\t\t\t\tvar framesToDrop = 0;\n\n\t\t\t\t\t\tif (me.dropFrames > 1) {\n\t\t\t\t\t\t\tframesToDrop = Math.floor(me.dropFrames);\n\t\t\t\t\t\t\tme.dropFrames = me.dropFrames % 1;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar i = 0;\n\t\t\t\t\t\twhile (i < me.animations.length) {\n\t\t\t\t\t\t\tif (me.animations[i].animationObject.currentStep === null) {\n\t\t\t\t\t\t\t\tme.animations[i].animationObject.currentStep = 0;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tme.animations[i].animationObject.currentStep += 1 + framesToDrop;\n\n\t\t\t\t\t\t\tif (me.animations[i].animationObject.currentStep > me.animations[i].animationObject.numSteps) {\n\t\t\t\t\t\t\t\tme.animations[i].animationObject.currentStep = me.animations[i].animationObject.numSteps;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tme.animations[i].animationObject.render(me.animations[i].chartInstance, me.animations[i].animationObject);\n\t\t\t\t\t\t\tif (me.animations[i].animationObject.onAnimationProgress && me.animations[i].animationObject.onAnimationProgress.call) {\n\t\t\t\t\t\t\t\tme.animations[i].animationObject.onAnimationProgress.call(me.animations[i].chartInstance, me.animations[i]);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (me.animations[i].animationObject.currentStep === me.animations[i].animationObject.numSteps) {\n\t\t\t\t\t\t\t\tif (me.animations[i].animationObject.onAnimationComplete && me.animations[i].animationObject.onAnimationComplete.call) {\n\t\t\t\t\t\t\t\t\tme.animations[i].animationObject.onAnimationComplete.call(me.animations[i].chartInstance, me.animations[i]);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// executed the last frame. Remove the animation.\n\t\t\t\t\t\t\t\tme.animations[i].chartInstance.animating = false;\n\n\t\t\t\t\t\t\t\tme.animations.splice(i, 1);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t++i;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar endTime = Date.now();\n\t\t\t\t\t\tvar dropFrames = (endTime - startTime) / me.frameDuration;\n\n\t\t\t\t\t\tme.dropFrames += dropFrames;\n\n\t\t\t\t\t\t// Do we have more stuff to animate?\n\t\t\t\t\t\tif (me.animations.length > 0) {\n\t\t\t\t\t\t\tme.requestAnimationFrame();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t};\n\t\t}, {}], 22: [function (require, module, exports) {\n\t\t\t'use strict';\n\n\t\t\tmodule.exports = function (Chart) {\n\t\t\t\t// Global Chart canvas helpers object for drawing items to canvas\n\t\t\t\tvar helpers = Chart.canvasHelpers = {};\n\n\t\t\t\thelpers.drawPoint = function (ctx, pointStyle, radius, x, y) {\n\t\t\t\t\tvar type, edgeLength, xOffset, yOffset, height, size;\n\n\t\t\t\t\tif ((typeof pointStyle === \"undefined\" ? \"undefined\" : _typeof(pointStyle)) === 'object') {\n\t\t\t\t\t\ttype = pointStyle.toString();\n\t\t\t\t\t\tif (type === '[object HTMLImageElement]' || type === '[object HTMLCanvasElement]') {\n\t\t\t\t\t\t\tctx.drawImage(pointStyle, x - pointStyle.width / 2, y - pointStyle.height / 2);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (isNaN(radius) || radius <= 0) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tswitch (pointStyle) {\n\t\t\t\t\t\t// Default includes circle\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tctx.beginPath();\n\t\t\t\t\t\t\tctx.arc(x, y, radius, 0, Math.PI * 2);\n\t\t\t\t\t\t\tctx.closePath();\n\t\t\t\t\t\t\tctx.fill();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'triangle':\n\t\t\t\t\t\t\tctx.beginPath();\n\t\t\t\t\t\t\tedgeLength = 3 * radius / Math.sqrt(3);\n\t\t\t\t\t\t\theight = edgeLength * Math.sqrt(3) / 2;\n\t\t\t\t\t\t\tctx.moveTo(x - edgeLength / 2, y + height / 3);\n\t\t\t\t\t\t\tctx.lineTo(x + edgeLength / 2, y + height / 3);\n\t\t\t\t\t\t\tctx.lineTo(x, y - 2 * height / 3);\n\t\t\t\t\t\t\tctx.closePath();\n\t\t\t\t\t\t\tctx.fill();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'rect':\n\t\t\t\t\t\t\tsize = 1 / Math.SQRT2 * radius;\n\t\t\t\t\t\t\tctx.beginPath();\n\t\t\t\t\t\t\tctx.fillRect(x - size, y - size, 2 * size, 2 * size);\n\t\t\t\t\t\t\tctx.strokeRect(x - size, y - size, 2 * size, 2 * size);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'rectRounded':\n\t\t\t\t\t\t\tvar offset = radius / Math.SQRT2;\n\t\t\t\t\t\t\tvar leftX = x - offset;\n\t\t\t\t\t\t\tvar topY = y - offset;\n\t\t\t\t\t\t\tvar sideSize = Math.SQRT2 * radius;\n\t\t\t\t\t\t\tChart.helpers.drawRoundedRectangle(ctx, leftX, topY, sideSize, sideSize, radius / 2);\n\t\t\t\t\t\t\tctx.fill();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'rectRot':\n\t\t\t\t\t\t\tsize = 1 / Math.SQRT2 * radius;\n\t\t\t\t\t\t\tctx.beginPath();\n\t\t\t\t\t\t\tctx.moveTo(x - size, y);\n\t\t\t\t\t\t\tctx.lineTo(x, y + size);\n\t\t\t\t\t\t\tctx.lineTo(x + size, y);\n\t\t\t\t\t\t\tctx.lineTo(x, y - size);\n\t\t\t\t\t\t\tctx.closePath();\n\t\t\t\t\t\t\tctx.fill();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'cross':\n\t\t\t\t\t\t\tctx.beginPath();\n\t\t\t\t\t\t\tctx.moveTo(x, y + radius);\n\t\t\t\t\t\t\tctx.lineTo(x, y - radius);\n\t\t\t\t\t\t\tctx.moveTo(x - radius, y);\n\t\t\t\t\t\t\tctx.lineTo(x + radius, y);\n\t\t\t\t\t\t\tctx.closePath();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'crossRot':\n\t\t\t\t\t\t\tctx.beginPath();\n\t\t\t\t\t\t\txOffset = Math.cos(Math.PI / 4) * radius;\n\t\t\t\t\t\t\tyOffset = Math.sin(Math.PI / 4) * radius;\n\t\t\t\t\t\t\tctx.moveTo(x - xOffset, y - yOffset);\n\t\t\t\t\t\t\tctx.lineTo(x + xOffset, y + yOffset);\n\t\t\t\t\t\t\tctx.moveTo(x - xOffset, y + yOffset);\n\t\t\t\t\t\t\tctx.lineTo(x + xOffset, y - yOffset);\n\t\t\t\t\t\t\tctx.closePath();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'star':\n\t\t\t\t\t\t\tctx.beginPath();\n\t\t\t\t\t\t\tctx.moveTo(x, y + radius);\n\t\t\t\t\t\t\tctx.lineTo(x, y - radius);\n\t\t\t\t\t\t\tctx.moveTo(x - radius, y);\n\t\t\t\t\t\t\tctx.lineTo(x + radius, y);\n\t\t\t\t\t\t\txOffset = Math.cos(Math.PI / 4) * radius;\n\t\t\t\t\t\t\tyOffset = Math.sin(Math.PI / 4) * radius;\n\t\t\t\t\t\t\tctx.moveTo(x - xOffset, y - yOffset);\n\t\t\t\t\t\t\tctx.lineTo(x + xOffset, y + yOffset);\n\t\t\t\t\t\t\tctx.moveTo(x - xOffset, y + yOffset);\n\t\t\t\t\t\t\tctx.lineTo(x + xOffset, y - yOffset);\n\t\t\t\t\t\t\tctx.closePath();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'line':\n\t\t\t\t\t\t\tctx.beginPath();\n\t\t\t\t\t\t\tctx.moveTo(x - radius, y);\n\t\t\t\t\t\t\tctx.lineTo(x + radius, y);\n\t\t\t\t\t\t\tctx.closePath();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'dash':\n\t\t\t\t\t\t\tctx.beginPath();\n\t\t\t\t\t\t\tctx.moveTo(x, y);\n\t\t\t\t\t\t\tctx.lineTo(x + radius, y);\n\t\t\t\t\t\t\tctx.closePath();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tctx.stroke();\n\t\t\t\t};\n\n\t\t\t\thelpers.clipArea = function (ctx, clipArea) {\n\t\t\t\t\tctx.save();\n\t\t\t\t\tctx.beginPath();\n\t\t\t\t\tctx.rect(clipArea.left, clipArea.top, clipArea.right - clipArea.left, clipArea.bottom - clipArea.top);\n\t\t\t\t\tctx.clip();\n\t\t\t\t};\n\n\t\t\t\thelpers.unclipArea = function (ctx) {\n\t\t\t\t\tctx.restore();\n\t\t\t\t};\n\t\t\t};\n\t\t}, {}], 23: [function (require, module, exports) {\n\t\t\t'use strict';\n\n\t\t\tmodule.exports = function (Chart) {\n\n\t\t\t\tvar helpers = Chart.helpers;\n\t\t\t\tvar plugins = Chart.plugins;\n\t\t\t\tvar platform = Chart.platform;\n\n\t\t\t\t// Create a dictionary of chart types, to allow for extension of existing types\n\t\t\t\tChart.types = {};\n\n\t\t\t\t// Store a reference to each instance - allowing us to globally resize chart instances on window resize.\n\t\t\t\t// Destroy method on the chart will remove the instance of the chart from this reference.\n\t\t\t\tChart.instances = {};\n\n\t\t\t\t// Controllers available for dataset visualization eg. bar, line, slice, etc.\n\t\t\t\tChart.controllers = {};\n\n\t\t\t\t/**\n     * Initializes the given config with global and chart default values.\n     */\n\t\t\t\tfunction initConfig(config) {\n\t\t\t\t\tconfig = config || {};\n\n\t\t\t\t\t// Do NOT use configMerge() for the data object because this method merges arrays\n\t\t\t\t\t// and so would change references to labels and datasets, preventing data updates.\n\t\t\t\t\tvar data = config.data = config.data || {};\n\t\t\t\t\tdata.datasets = data.datasets || [];\n\t\t\t\t\tdata.labels = data.labels || [];\n\n\t\t\t\t\tconfig.options = helpers.configMerge(Chart.defaults.global, Chart.defaults[config.type], config.options || {});\n\n\t\t\t\t\treturn config;\n\t\t\t\t}\n\n\t\t\t\t/**\n     * Updates the config of the chart\n     * @param chart {Chart.Controller} chart to update the options for\n     */\n\t\t\t\tfunction updateConfig(chart) {\n\t\t\t\t\tvar newOptions = chart.options;\n\n\t\t\t\t\t// Update Scale(s) with options\n\t\t\t\t\tif (newOptions.scale) {\n\t\t\t\t\t\tchart.scale.options = newOptions.scale;\n\t\t\t\t\t} else if (newOptions.scales) {\n\t\t\t\t\t\tnewOptions.scales.xAxes.concat(newOptions.scales.yAxes).forEach(function (scaleOptions) {\n\t\t\t\t\t\t\tchart.scales[scaleOptions.id].options = scaleOptions;\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\n\t\t\t\t\t// Tooltip\n\t\t\t\t\tchart.tooltip._options = newOptions.tooltips;\n\t\t\t\t}\n\n\t\t\t\t/**\n     * @class Chart.Controller\n     * The main controller of a chart.\n     */\n\t\t\t\tChart.Controller = function (item, config, instance) {\n\t\t\t\t\tvar me = this;\n\n\t\t\t\t\tconfig = initConfig(config);\n\n\t\t\t\t\tvar context = platform.acquireContext(item, config);\n\t\t\t\t\tvar canvas = context && context.canvas;\n\t\t\t\t\tvar height = canvas && canvas.height;\n\t\t\t\t\tvar width = canvas && canvas.width;\n\n\t\t\t\t\tinstance.ctx = context;\n\t\t\t\t\tinstance.canvas = canvas;\n\t\t\t\t\tinstance.config = config;\n\t\t\t\t\tinstance.width = width;\n\t\t\t\t\tinstance.height = height;\n\t\t\t\t\tinstance.aspectRatio = height ? width / height : null;\n\n\t\t\t\t\tme.id = helpers.uid();\n\t\t\t\t\tme.chart = instance;\n\t\t\t\t\tme.config = config;\n\t\t\t\t\tme.options = config.options;\n\t\t\t\t\tme._bufferedRender = false;\n\n\t\t\t\t\t// Add the chart instance to the global namespace\n\t\t\t\t\tChart.instances[me.id] = me;\n\n\t\t\t\t\tObject.defineProperty(me, 'data', {\n\t\t\t\t\t\tget: function get() {\n\t\t\t\t\t\t\treturn me.config.data;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t\tif (!context || !canvas) {\n\t\t\t\t\t\t// The given item is not a compatible context2d element, let's return before finalizing\n\t\t\t\t\t\t// the chart initialization but after setting basic chart / controller properties that\n\t\t\t\t\t\t// can help to figure out that the chart is not valid (e.g chart.canvas !== null);\n\t\t\t\t\t\t// https://github.com/chartjs/Chart.js/issues/2807\n\t\t\t\t\t\tconsole.error(\"Failed to create chart: can't acquire context from the given item\");\n\t\t\t\t\t\treturn me;\n\t\t\t\t\t}\n\n\t\t\t\t\tme.initialize();\n\t\t\t\t\tme.update();\n\n\t\t\t\t\treturn me;\n\t\t\t\t};\n\n\t\t\t\thelpers.extend(Chart.Controller.prototype, /** @lends Chart.Controller.prototype */{\n\t\t\t\t\tinitialize: function initialize() {\n\t\t\t\t\t\tvar me = this;\n\n\t\t\t\t\t\t// Before init plugin notification\n\t\t\t\t\t\tplugins.notify(me, 'beforeInit');\n\n\t\t\t\t\t\thelpers.retinaScale(me.chart);\n\n\t\t\t\t\t\tme.bindEvents();\n\n\t\t\t\t\t\tif (me.options.responsive) {\n\t\t\t\t\t\t\t// Initial resize before chart draws (must be silent to preserve initial animations).\n\t\t\t\t\t\t\tme.resize(true);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Make sure scales have IDs and are built before we build any controllers.\n\t\t\t\t\t\tme.ensureScalesHaveIDs();\n\t\t\t\t\t\tme.buildScales();\n\t\t\t\t\t\tme.initToolTip();\n\n\t\t\t\t\t\t// After init plugin notification\n\t\t\t\t\t\tplugins.notify(me, 'afterInit');\n\n\t\t\t\t\t\treturn me;\n\t\t\t\t\t},\n\n\t\t\t\t\tclear: function clear() {\n\t\t\t\t\t\thelpers.clear(this.chart);\n\t\t\t\t\t\treturn this;\n\t\t\t\t\t},\n\n\t\t\t\t\tstop: function stop() {\n\t\t\t\t\t\t// Stops any current animation loop occurring\n\t\t\t\t\t\tChart.animationService.cancelAnimation(this);\n\t\t\t\t\t\treturn this;\n\t\t\t\t\t},\n\n\t\t\t\t\tresize: function resize(silent) {\n\t\t\t\t\t\tvar me = this;\n\t\t\t\t\t\tvar chart = me.chart;\n\t\t\t\t\t\tvar options = me.options;\n\t\t\t\t\t\tvar canvas = chart.canvas;\n\t\t\t\t\t\tvar aspectRatio = options.maintainAspectRatio && chart.aspectRatio || null;\n\n\t\t\t\t\t\t// the canvas render width and height will be casted to integers so make sure that\n\t\t\t\t\t\t// the canvas display style uses the same integer values to avoid blurring effect.\n\t\t\t\t\t\tvar newWidth = Math.floor(helpers.getMaximumWidth(canvas));\n\t\t\t\t\t\tvar newHeight = Math.floor(aspectRatio ? newWidth / aspectRatio : helpers.getMaximumHeight(canvas));\n\n\t\t\t\t\t\tif (chart.width === newWidth && chart.height === newHeight) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcanvas.width = chart.width = newWidth;\n\t\t\t\t\t\tcanvas.height = chart.height = newHeight;\n\t\t\t\t\t\tcanvas.style.width = newWidth + 'px';\n\t\t\t\t\t\tcanvas.style.height = newHeight + 'px';\n\n\t\t\t\t\t\thelpers.retinaScale(chart);\n\n\t\t\t\t\t\tif (!silent) {\n\t\t\t\t\t\t\t// Notify any plugins about the resize\n\t\t\t\t\t\t\tvar newSize = { width: newWidth, height: newHeight };\n\t\t\t\t\t\t\tplugins.notify(me, 'resize', [newSize]);\n\n\t\t\t\t\t\t\t// Notify of resize\n\t\t\t\t\t\t\tif (me.options.onResize) {\n\t\t\t\t\t\t\t\tme.options.onResize(me, newSize);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tme.stop();\n\t\t\t\t\t\t\tme.update(me.options.responsiveAnimationDuration);\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\n\t\t\t\t\tensureScalesHaveIDs: function ensureScalesHaveIDs() {\n\t\t\t\t\t\tvar options = this.options;\n\t\t\t\t\t\tvar scalesOptions = options.scales || {};\n\t\t\t\t\t\tvar scaleOptions = options.scale;\n\n\t\t\t\t\t\thelpers.each(scalesOptions.xAxes, function (xAxisOptions, index) {\n\t\t\t\t\t\t\txAxisOptions.id = xAxisOptions.id || 'x-axis-' + index;\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\thelpers.each(scalesOptions.yAxes, function (yAxisOptions, index) {\n\t\t\t\t\t\t\tyAxisOptions.id = yAxisOptions.id || 'y-axis-' + index;\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tif (scaleOptions) {\n\t\t\t\t\t\t\tscaleOptions.id = scaleOptions.id || 'scale';\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\n\t\t\t\t\t/**\n      * Builds a map of scale ID to scale object for future lookup.\n      */\n\t\t\t\t\tbuildScales: function buildScales() {\n\t\t\t\t\t\tvar me = this;\n\t\t\t\t\t\tvar options = me.options;\n\t\t\t\t\t\tvar scales = me.scales = {};\n\t\t\t\t\t\tvar items = [];\n\n\t\t\t\t\t\tif (options.scales) {\n\t\t\t\t\t\t\titems = items.concat((options.scales.xAxes || []).map(function (xAxisOptions) {\n\t\t\t\t\t\t\t\treturn { options: xAxisOptions, dtype: 'category' };\n\t\t\t\t\t\t\t}), (options.scales.yAxes || []).map(function (yAxisOptions) {\n\t\t\t\t\t\t\t\treturn { options: yAxisOptions, dtype: 'linear' };\n\t\t\t\t\t\t\t}));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (options.scale) {\n\t\t\t\t\t\t\titems.push({ options: options.scale, dtype: 'radialLinear', isDefault: true });\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\thelpers.each(items, function (item) {\n\t\t\t\t\t\t\tvar scaleOptions = item.options;\n\t\t\t\t\t\t\tvar scaleType = helpers.getValueOrDefault(scaleOptions.type, item.dtype);\n\t\t\t\t\t\t\tvar scaleClass = Chart.scaleService.getScaleConstructor(scaleType);\n\t\t\t\t\t\t\tif (!scaleClass) {\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tvar scale = new scaleClass({\n\t\t\t\t\t\t\t\tid: scaleOptions.id,\n\t\t\t\t\t\t\t\toptions: scaleOptions,\n\t\t\t\t\t\t\t\tctx: me.chart.ctx,\n\t\t\t\t\t\t\t\tchart: me\n\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\tscales[scale.id] = scale;\n\n\t\t\t\t\t\t\t// TODO(SB): I think we should be able to remove this custom case (options.scale)\n\t\t\t\t\t\t\t// and consider it as a regular scale part of the \"scales\"\" map only! This would\n\t\t\t\t\t\t\t// make the logic easier and remove some useless? custom code.\n\t\t\t\t\t\t\tif (item.isDefault) {\n\t\t\t\t\t\t\t\tme.scale = scale;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tChart.scaleService.addScalesToLayout(this);\n\t\t\t\t\t},\n\n\t\t\t\t\tbuildOrUpdateControllers: function buildOrUpdateControllers() {\n\t\t\t\t\t\tvar me = this;\n\t\t\t\t\t\tvar types = [];\n\t\t\t\t\t\tvar newControllers = [];\n\n\t\t\t\t\t\thelpers.each(me.data.datasets, function (dataset, datasetIndex) {\n\t\t\t\t\t\t\tvar meta = me.getDatasetMeta(datasetIndex);\n\t\t\t\t\t\t\tif (!meta.type) {\n\t\t\t\t\t\t\t\tmeta.type = dataset.type || me.config.type;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\ttypes.push(meta.type);\n\n\t\t\t\t\t\t\tif (meta.controller) {\n\t\t\t\t\t\t\t\tmeta.controller.updateIndex(datasetIndex);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tmeta.controller = new Chart.controllers[meta.type](me, datasetIndex);\n\t\t\t\t\t\t\t\tnewControllers.push(meta.controller);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}, me);\n\n\t\t\t\t\t\tif (types.length > 1) {\n\t\t\t\t\t\t\tfor (var i = 1; i < types.length; i++) {\n\t\t\t\t\t\t\t\tif (types[i] !== types[i - 1]) {\n\t\t\t\t\t\t\t\t\tme.isCombo = true;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn newControllers;\n\t\t\t\t\t},\n\n\t\t\t\t\t/**\n      * Reset the elements of all datasets\n      * @private\n      */\n\t\t\t\t\tresetElements: function resetElements() {\n\t\t\t\t\t\tvar me = this;\n\t\t\t\t\t\thelpers.each(me.data.datasets, function (dataset, datasetIndex) {\n\t\t\t\t\t\t\tme.getDatasetMeta(datasetIndex).controller.reset();\n\t\t\t\t\t\t}, me);\n\t\t\t\t\t},\n\n\t\t\t\t\t/**\n     * Resets the chart back to it's state before the initial animation\n     */\n\t\t\t\t\treset: function reset() {\n\t\t\t\t\t\tthis.resetElements();\n\t\t\t\t\t\tthis.tooltip.initialize();\n\t\t\t\t\t},\n\n\t\t\t\t\tupdate: function update(animationDuration, lazy) {\n\t\t\t\t\t\tvar me = this;\n\n\t\t\t\t\t\tupdateConfig(me);\n\n\t\t\t\t\t\tif (plugins.notify(me, 'beforeUpdate') === false) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// In case the entire data object changed\n\t\t\t\t\t\tme.tooltip._data = me.data;\n\n\t\t\t\t\t\t// Make sure dataset controllers are updated and new controllers are reset\n\t\t\t\t\t\tvar newControllers = me.buildOrUpdateControllers();\n\n\t\t\t\t\t\t// Make sure all dataset controllers have correct meta data counts\n\t\t\t\t\t\thelpers.each(me.data.datasets, function (dataset, datasetIndex) {\n\t\t\t\t\t\t\tme.getDatasetMeta(datasetIndex).controller.buildOrUpdateElements();\n\t\t\t\t\t\t}, me);\n\n\t\t\t\t\t\tme.updateLayout();\n\n\t\t\t\t\t\t// Can only reset the new controllers after the scales have been updated\n\t\t\t\t\t\thelpers.each(newControllers, function (controller) {\n\t\t\t\t\t\t\tcontroller.reset();\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tme.updateDatasets();\n\n\t\t\t\t\t\t// Do this before render so that any plugins that need final scale updates can use it\n\t\t\t\t\t\tplugins.notify(me, 'afterUpdate');\n\n\t\t\t\t\t\tif (me._bufferedRender) {\n\t\t\t\t\t\t\tme._bufferedRequest = {\n\t\t\t\t\t\t\t\tlazy: lazy,\n\t\t\t\t\t\t\t\tduration: animationDuration\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tme.render(animationDuration, lazy);\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\n\t\t\t\t\t/**\n      * Updates the chart layout unless a plugin returns `false` to the `beforeLayout`\n      * hook, in which case, plugins will not be called on `afterLayout`.\n      * @private\n      */\n\t\t\t\t\tupdateLayout: function updateLayout() {\n\t\t\t\t\t\tvar me = this;\n\n\t\t\t\t\t\tif (plugins.notify(me, 'beforeLayout') === false) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tChart.layoutService.update(this, this.chart.width, this.chart.height);\n\n\t\t\t\t\t\t/**\n       * Provided for backward compatibility, use `afterLayout` instead.\n       * @method IPlugin#afterScaleUpdate\n       * @deprecated since version 2.5.0\n       * @todo remove at version 3\n       */\n\t\t\t\t\t\tplugins.notify(me, 'afterScaleUpdate');\n\t\t\t\t\t\tplugins.notify(me, 'afterLayout');\n\t\t\t\t\t},\n\n\t\t\t\t\t/**\n      * Updates all datasets unless a plugin returns `false` to the `beforeDatasetsUpdate`\n      * hook, in which case, plugins will not be called on `afterDatasetsUpdate`.\n      * @private\n      */\n\t\t\t\t\tupdateDatasets: function updateDatasets() {\n\t\t\t\t\t\tvar me = this;\n\n\t\t\t\t\t\tif (plugins.notify(me, 'beforeDatasetsUpdate') === false) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfor (var i = 0, ilen = me.data.datasets.length; i < ilen; ++i) {\n\t\t\t\t\t\t\tme.getDatasetMeta(i).controller.update();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tplugins.notify(me, 'afterDatasetsUpdate');\n\t\t\t\t\t},\n\n\t\t\t\t\trender: function render(duration, lazy) {\n\t\t\t\t\t\tvar me = this;\n\n\t\t\t\t\t\tif (plugins.notify(me, 'beforeRender') === false) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar animationOptions = me.options.animation;\n\t\t\t\t\t\tvar onComplete = function onComplete() {\n\t\t\t\t\t\t\tplugins.notify(me, 'afterRender');\n\t\t\t\t\t\t\tvar callback = animationOptions && animationOptions.onComplete;\n\t\t\t\t\t\t\tif (callback && callback.call) {\n\t\t\t\t\t\t\t\tcallback.call(me);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tif (animationOptions && (typeof duration !== 'undefined' && duration !== 0 || typeof duration === 'undefined' && animationOptions.duration !== 0)) {\n\t\t\t\t\t\t\tvar animation = new Chart.Animation();\n\t\t\t\t\t\t\tanimation.numSteps = (duration || animationOptions.duration) / 16.66; // 60 fps\n\t\t\t\t\t\t\tanimation.easing = animationOptions.easing;\n\n\t\t\t\t\t\t\t// render function\n\t\t\t\t\t\t\tanimation.render = function (chartInstance, animationObject) {\n\t\t\t\t\t\t\t\tvar easingFunction = helpers.easingEffects[animationObject.easing];\n\t\t\t\t\t\t\t\tvar stepDecimal = animationObject.currentStep / animationObject.numSteps;\n\t\t\t\t\t\t\t\tvar easeDecimal = easingFunction(stepDecimal);\n\n\t\t\t\t\t\t\t\tchartInstance.draw(easeDecimal, stepDecimal, animationObject.currentStep);\n\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t// user events\n\t\t\t\t\t\t\tanimation.onAnimationProgress = animationOptions.onProgress;\n\t\t\t\t\t\t\tanimation.onAnimationComplete = onComplete;\n\n\t\t\t\t\t\t\tChart.animationService.addAnimation(me, animation, duration, lazy);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tme.draw();\n\t\t\t\t\t\t\tonComplete();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn me;\n\t\t\t\t\t},\n\n\t\t\t\t\tdraw: function draw(easingValue) {\n\t\t\t\t\t\tvar me = this;\n\n\t\t\t\t\t\tme.clear();\n\n\t\t\t\t\t\tif (easingValue === undefined || easingValue === null) {\n\t\t\t\t\t\t\teasingValue = 1;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (plugins.notify(me, 'beforeDraw', [easingValue]) === false) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Draw all the scales\n\t\t\t\t\t\thelpers.each(me.boxes, function (box) {\n\t\t\t\t\t\t\tbox.draw(me.chartArea);\n\t\t\t\t\t\t}, me);\n\n\t\t\t\t\t\tif (me.scale) {\n\t\t\t\t\t\t\tme.scale.draw();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tme.drawDatasets(easingValue);\n\n\t\t\t\t\t\t// Finally draw the tooltip\n\t\t\t\t\t\tme.tooltip.transition(easingValue).draw();\n\n\t\t\t\t\t\tplugins.notify(me, 'afterDraw', [easingValue]);\n\t\t\t\t\t},\n\n\t\t\t\t\t/**\n      * Draws all datasets unless a plugin returns `false` to the `beforeDatasetsDraw`\n      * hook, in which case, plugins will not be called on `afterDatasetsDraw`.\n      * @private\n      */\n\t\t\t\t\tdrawDatasets: function drawDatasets(easingValue) {\n\t\t\t\t\t\tvar me = this;\n\n\t\t\t\t\t\tif (plugins.notify(me, 'beforeDatasetsDraw', [easingValue]) === false) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Draw each dataset via its respective controller (reversed to support proper line stacking)\n\t\t\t\t\t\thelpers.each(me.data.datasets, function (dataset, datasetIndex) {\n\t\t\t\t\t\t\tif (me.isDatasetVisible(datasetIndex)) {\n\t\t\t\t\t\t\t\tme.getDatasetMeta(datasetIndex).controller.draw(easingValue);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}, me, true);\n\n\t\t\t\t\t\tplugins.notify(me, 'afterDatasetsDraw', [easingValue]);\n\t\t\t\t\t},\n\n\t\t\t\t\t// Get the single element that was clicked on\n\t\t\t\t\t// @return : An object containing the dataset index and element index of the matching element. Also contains the rectangle that was draw\n\t\t\t\t\tgetElementAtEvent: function getElementAtEvent(e) {\n\t\t\t\t\t\treturn Chart.Interaction.modes.single(this, e);\n\t\t\t\t\t},\n\n\t\t\t\t\tgetElementsAtEvent: function getElementsAtEvent(e) {\n\t\t\t\t\t\treturn Chart.Interaction.modes.label(this, e, { intersect: true });\n\t\t\t\t\t},\n\n\t\t\t\t\tgetElementsAtXAxis: function getElementsAtXAxis(e) {\n\t\t\t\t\t\treturn Chart.Interaction.modes['x-axis'](this, e, { intersect: true });\n\t\t\t\t\t},\n\n\t\t\t\t\tgetElementsAtEventForMode: function getElementsAtEventForMode(e, mode, options) {\n\t\t\t\t\t\tvar method = Chart.Interaction.modes[mode];\n\t\t\t\t\t\tif (typeof method === 'function') {\n\t\t\t\t\t\t\treturn method(this, e, options);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn [];\n\t\t\t\t\t},\n\n\t\t\t\t\tgetDatasetAtEvent: function getDatasetAtEvent(e) {\n\t\t\t\t\t\treturn Chart.Interaction.modes.dataset(this, e, { intersect: true });\n\t\t\t\t\t},\n\n\t\t\t\t\tgetDatasetMeta: function getDatasetMeta(datasetIndex) {\n\t\t\t\t\t\tvar me = this;\n\t\t\t\t\t\tvar dataset = me.data.datasets[datasetIndex];\n\t\t\t\t\t\tif (!dataset._meta) {\n\t\t\t\t\t\t\tdataset._meta = {};\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar meta = dataset._meta[me.id];\n\t\t\t\t\t\tif (!meta) {\n\t\t\t\t\t\t\tmeta = dataset._meta[me.id] = {\n\t\t\t\t\t\t\t\ttype: null,\n\t\t\t\t\t\t\t\tdata: [],\n\t\t\t\t\t\t\t\tdataset: null,\n\t\t\t\t\t\t\t\tcontroller: null,\n\t\t\t\t\t\t\t\thidden: null, // See isDatasetVisible() comment\n\t\t\t\t\t\t\t\txAxisID: null,\n\t\t\t\t\t\t\t\tyAxisID: null\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn meta;\n\t\t\t\t\t},\n\n\t\t\t\t\tgetVisibleDatasetCount: function getVisibleDatasetCount() {\n\t\t\t\t\t\tvar count = 0;\n\t\t\t\t\t\tfor (var i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {\n\t\t\t\t\t\t\tif (this.isDatasetVisible(i)) {\n\t\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn count;\n\t\t\t\t\t},\n\n\t\t\t\t\tisDatasetVisible: function isDatasetVisible(datasetIndex) {\n\t\t\t\t\t\tvar meta = this.getDatasetMeta(datasetIndex);\n\n\t\t\t\t\t\t// meta.hidden is a per chart dataset hidden flag override with 3 states: if true or false,\n\t\t\t\t\t\t// the dataset.hidden value is ignored, else if null, the dataset hidden state is returned.\n\t\t\t\t\t\treturn typeof meta.hidden === 'boolean' ? !meta.hidden : !this.data.datasets[datasetIndex].hidden;\n\t\t\t\t\t},\n\n\t\t\t\t\tgenerateLegend: function generateLegend() {\n\t\t\t\t\t\treturn this.options.legendCallback(this);\n\t\t\t\t\t},\n\n\t\t\t\t\tdestroy: function destroy() {\n\t\t\t\t\t\tvar me = this;\n\t\t\t\t\t\tvar canvas = me.chart.canvas;\n\t\t\t\t\t\tvar meta, i, ilen;\n\n\t\t\t\t\t\tme.stop();\n\n\t\t\t\t\t\t// dataset controllers need to cleanup associated data\n\t\t\t\t\t\tfor (i = 0, ilen = me.data.datasets.length; i < ilen; ++i) {\n\t\t\t\t\t\t\tmeta = me.getDatasetMeta(i);\n\t\t\t\t\t\t\tif (meta.controller) {\n\t\t\t\t\t\t\t\tmeta.controller.destroy();\n\t\t\t\t\t\t\t\tmeta.controller = null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (canvas) {\n\t\t\t\t\t\t\tme.unbindEvents();\n\t\t\t\t\t\t\thelpers.clear(me.chart);\n\t\t\t\t\t\t\tplatform.releaseContext(me.chart.ctx);\n\t\t\t\t\t\t\tme.chart.canvas = null;\n\t\t\t\t\t\t\tme.chart.ctx = null;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tplugins.notify(me, 'destroy');\n\n\t\t\t\t\t\tdelete Chart.instances[me.id];\n\t\t\t\t\t},\n\n\t\t\t\t\ttoBase64Image: function toBase64Image() {\n\t\t\t\t\t\treturn this.chart.canvas.toDataURL.apply(this.chart.canvas, arguments);\n\t\t\t\t\t},\n\n\t\t\t\t\tinitToolTip: function initToolTip() {\n\t\t\t\t\t\tvar me = this;\n\t\t\t\t\t\tme.tooltip = new Chart.Tooltip({\n\t\t\t\t\t\t\t_chart: me.chart,\n\t\t\t\t\t\t\t_chartInstance: me,\n\t\t\t\t\t\t\t_data: me.data,\n\t\t\t\t\t\t\t_options: me.options.tooltips\n\t\t\t\t\t\t}, me);\n\t\t\t\t\t\tme.tooltip.initialize();\n\t\t\t\t\t},\n\n\t\t\t\t\t/**\n      * @private\n      */\n\t\t\t\t\tbindEvents: function bindEvents() {\n\t\t\t\t\t\tvar me = this;\n\t\t\t\t\t\tvar listeners = me._listeners = {};\n\t\t\t\t\t\tvar listener = function listener() {\n\t\t\t\t\t\t\tme.eventHandler.apply(me, arguments);\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\thelpers.each(me.options.events, function (type) {\n\t\t\t\t\t\t\tplatform.addEventListener(me, type, listener);\n\t\t\t\t\t\t\tlisteners[type] = listener;\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\t// Responsiveness is currently based on the use of an iframe, however this method causes\n\t\t\t\t\t\t// performance issues and could be troublesome when used with ad blockers. So make sure\n\t\t\t\t\t\t// that the user is still able to create a chart without iframe when responsive is false.\n\t\t\t\t\t\t// See https://github.com/chartjs/Chart.js/issues/2210\n\t\t\t\t\t\tif (me.options.responsive) {\n\t\t\t\t\t\t\tlistener = function listener() {\n\t\t\t\t\t\t\t\tme.resize();\n\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\tplatform.addEventListener(me, 'resize', listener);\n\t\t\t\t\t\t\tlisteners.resize = listener;\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\n\t\t\t\t\t/**\n      * @private\n      */\n\t\t\t\t\tunbindEvents: function unbindEvents() {\n\t\t\t\t\t\tvar me = this;\n\t\t\t\t\t\tvar listeners = me._listeners;\n\t\t\t\t\t\tif (!listeners) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tdelete me._listeners;\n\t\t\t\t\t\thelpers.each(listeners, function (listener, type) {\n\t\t\t\t\t\t\tplatform.removeEventListener(me, type, listener);\n\t\t\t\t\t\t});\n\t\t\t\t\t},\n\n\t\t\t\t\tupdateHoverStyle: function updateHoverStyle(elements, mode, enabled) {\n\t\t\t\t\t\tvar method = enabled ? 'setHoverStyle' : 'removeHoverStyle';\n\t\t\t\t\t\tvar element, i, ilen;\n\n\t\t\t\t\t\tfor (i = 0, ilen = elements.length; i < ilen; ++i) {\n\t\t\t\t\t\t\telement = elements[i];\n\t\t\t\t\t\t\tif (element) {\n\t\t\t\t\t\t\t\tthis.getDatasetMeta(element._datasetIndex).controller[method](element);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\n\t\t\t\t\t/**\n      * @private\n      */\n\t\t\t\t\teventHandler: function eventHandler(e) {\n\t\t\t\t\t\tvar me = this;\n\t\t\t\t\t\tvar tooltip = me.tooltip;\n\n\t\t\t\t\t\tif (plugins.notify(me, 'beforeEvent', [e]) === false) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Buffer any update calls so that renders do not occur\n\t\t\t\t\t\tme._bufferedRender = true;\n\t\t\t\t\t\tme._bufferedRequest = null;\n\n\t\t\t\t\t\tvar changed = me.handleEvent(e);\n\t\t\t\t\t\tchanged |= tooltip && tooltip.handleEvent(e);\n\n\t\t\t\t\t\tplugins.notify(me, 'afterEvent', [e]);\n\n\t\t\t\t\t\tvar bufferedRequest = me._bufferedRequest;\n\t\t\t\t\t\tif (bufferedRequest) {\n\t\t\t\t\t\t\t// If we have an update that was triggered, we need to do a normal render\n\t\t\t\t\t\t\tme.render(bufferedRequest.duration, bufferedRequest.lazy);\n\t\t\t\t\t\t} else if (changed && !me.animating) {\n\t\t\t\t\t\t\t// If entering, leaving, or changing elements, animate the change via pivot\n\t\t\t\t\t\t\tme.stop();\n\n\t\t\t\t\t\t\t// We only need to render at this point. Updating will cause scales to be\n\t\t\t\t\t\t\t// recomputed generating flicker & using more memory than necessary.\n\t\t\t\t\t\t\tme.render(me.options.hover.animationDuration, true);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tme._bufferedRender = false;\n\t\t\t\t\t\tme._bufferedRequest = null;\n\n\t\t\t\t\t\treturn me;\n\t\t\t\t\t},\n\n\t\t\t\t\t/**\n      * Handle an event\n      * @private\n      * @param {IEvent} event the event to handle\n      * @return {Boolean} true if the chart needs to re-render\n      */\n\t\t\t\t\thandleEvent: function handleEvent(e) {\n\t\t\t\t\t\tvar me = this;\n\t\t\t\t\t\tvar options = me.options || {};\n\t\t\t\t\t\tvar hoverOptions = options.hover;\n\t\t\t\t\t\tvar changed = false;\n\n\t\t\t\t\t\tme.lastActive = me.lastActive || [];\n\n\t\t\t\t\t\t// Find Active Elements for hover and tooltips\n\t\t\t\t\t\tif (e.type === 'mouseout') {\n\t\t\t\t\t\t\tme.active = [];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tme.active = me.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// On Hover hook\n\t\t\t\t\t\tif (hoverOptions.onHover) {\n\t\t\t\t\t\t\t// Need to call with native event here to not break backwards compatibility\n\t\t\t\t\t\t\thoverOptions.onHover.call(me, e.native, me.active);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (e.type === 'mouseup' || e.type === 'click') {\n\t\t\t\t\t\t\tif (options.onClick) {\n\t\t\t\t\t\t\t\t// Use e.native here for backwards compatibility\n\t\t\t\t\t\t\t\toptions.onClick.call(me, e.native, me.active);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Remove styling for last active (even if it may still be active)\n\t\t\t\t\t\tif (me.lastActive.length) {\n\t\t\t\t\t\t\tme.updateHoverStyle(me.lastActive, hoverOptions.mode, false);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Built in hover styling\n\t\t\t\t\t\tif (me.active.length && hoverOptions.mode) {\n\t\t\t\t\t\t\tme.updateHoverStyle(me.active, hoverOptions.mode, true);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tchanged = !helpers.arrayEquals(me.active, me.lastActive);\n\n\t\t\t\t\t\t// Remember Last Actives\n\t\t\t\t\t\tme.lastActive = me.active;\n\n\t\t\t\t\t\treturn changed;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t};\n\t\t}, {}], 24: [function (require, module, exports) {\n\t\t\t'use strict';\n\n\t\t\tmodule.exports = function (Chart) {\n\n\t\t\t\tvar helpers = Chart.helpers;\n\n\t\t\t\tvar arrayEvents = ['push', 'pop', 'shift', 'splice', 'unshift'];\n\n\t\t\t\t/**\n     * Hooks the array methods that add or remove values ('push', pop', 'shift', 'splice',\n     * 'unshift') and notify the listener AFTER the array has been altered. Listeners are\n     * called on the 'onData*' callbacks (e.g. onDataPush, etc.) with same arguments.\n     */\n\t\t\t\tfunction listenArrayEvents(array, listener) {\n\t\t\t\t\tif (array._chartjs) {\n\t\t\t\t\t\tarray._chartjs.listeners.push(listener);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tObject.defineProperty(array, '_chartjs', {\n\t\t\t\t\t\tconfigurable: true,\n\t\t\t\t\t\tenumerable: false,\n\t\t\t\t\t\tvalue: {\n\t\t\t\t\t\t\tlisteners: [listener]\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t\tarrayEvents.forEach(function (key) {\n\t\t\t\t\t\tvar method = 'onData' + key.charAt(0).toUpperCase() + key.slice(1);\n\t\t\t\t\t\tvar base = array[key];\n\n\t\t\t\t\t\tObject.defineProperty(array, key, {\n\t\t\t\t\t\t\tconfigurable: true,\n\t\t\t\t\t\t\tenumerable: false,\n\t\t\t\t\t\t\tvalue: function value() {\n\t\t\t\t\t\t\t\tvar args = Array.prototype.slice.call(arguments);\n\t\t\t\t\t\t\t\tvar res = base.apply(this, args);\n\n\t\t\t\t\t\t\t\thelpers.each(array._chartjs.listeners, function (object) {\n\t\t\t\t\t\t\t\t\tif (typeof object[method] === 'function') {\n\t\t\t\t\t\t\t\t\t\tobject[method].apply(object, args);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t\treturn res;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t/**\n     * Removes the given array event listener and cleanup extra attached properties (such as\n     * the _chartjs stub and overridden methods) if array doesn't have any more listeners.\n     */\n\t\t\t\tfunction unlistenArrayEvents(array, listener) {\n\t\t\t\t\tvar stub = array._chartjs;\n\t\t\t\t\tif (!stub) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar listeners = stub.listeners;\n\t\t\t\t\tvar index = listeners.indexOf(listener);\n\t\t\t\t\tif (index !== -1) {\n\t\t\t\t\t\tlisteners.splice(index, 1);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (listeners.length > 0) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tarrayEvents.forEach(function (key) {\n\t\t\t\t\t\tdelete array[key];\n\t\t\t\t\t});\n\n\t\t\t\t\tdelete array._chartjs;\n\t\t\t\t}\n\n\t\t\t\t// Base class for all dataset controllers (line, bar, etc)\n\t\t\t\tChart.DatasetController = function (chart, datasetIndex) {\n\t\t\t\t\tthis.initialize(chart, datasetIndex);\n\t\t\t\t};\n\n\t\t\t\thelpers.extend(Chart.DatasetController.prototype, {\n\n\t\t\t\t\t/**\n      * Element type used to generate a meta dataset (e.g. Chart.element.Line).\n      * @type {Chart.core.element}\n      */\n\t\t\t\t\tdatasetElementType: null,\n\n\t\t\t\t\t/**\n      * Element type used to generate a meta data (e.g. Chart.element.Point).\n      * @type {Chart.core.element}\n      */\n\t\t\t\t\tdataElementType: null,\n\n\t\t\t\t\tinitialize: function initialize(chart, datasetIndex) {\n\t\t\t\t\t\tvar me = this;\n\t\t\t\t\t\tme.chart = chart;\n\t\t\t\t\t\tme.index = datasetIndex;\n\t\t\t\t\t\tme.linkScales();\n\t\t\t\t\t\tme.addElements();\n\t\t\t\t\t},\n\n\t\t\t\t\tupdateIndex: function updateIndex(datasetIndex) {\n\t\t\t\t\t\tthis.index = datasetIndex;\n\t\t\t\t\t},\n\n\t\t\t\t\tlinkScales: function linkScales() {\n\t\t\t\t\t\tvar me = this;\n\t\t\t\t\t\tvar meta = me.getMeta();\n\t\t\t\t\t\tvar dataset = me.getDataset();\n\n\t\t\t\t\t\tif (meta.xAxisID === null) {\n\t\t\t\t\t\t\tmeta.xAxisID = dataset.xAxisID || me.chart.options.scales.xAxes[0].id;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (meta.yAxisID === null) {\n\t\t\t\t\t\t\tmeta.yAxisID = dataset.yAxisID || me.chart.options.scales.yAxes[0].id;\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\n\t\t\t\t\tgetDataset: function getDataset() {\n\t\t\t\t\t\treturn this.chart.data.datasets[this.index];\n\t\t\t\t\t},\n\n\t\t\t\t\tgetMeta: function getMeta() {\n\t\t\t\t\t\treturn this.chart.getDatasetMeta(this.index);\n\t\t\t\t\t},\n\n\t\t\t\t\tgetScaleForId: function getScaleForId(scaleID) {\n\t\t\t\t\t\treturn this.chart.scales[scaleID];\n\t\t\t\t\t},\n\n\t\t\t\t\treset: function reset() {\n\t\t\t\t\t\tthis.update(true);\n\t\t\t\t\t},\n\n\t\t\t\t\t/**\n      * @private\n      */\n\t\t\t\t\tdestroy: function destroy() {\n\t\t\t\t\t\tif (this._data) {\n\t\t\t\t\t\t\tunlistenArrayEvents(this._data, this);\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\n\t\t\t\t\tcreateMetaDataset: function createMetaDataset() {\n\t\t\t\t\t\tvar me = this;\n\t\t\t\t\t\tvar type = me.datasetElementType;\n\t\t\t\t\t\treturn type && new type({\n\t\t\t\t\t\t\t_chart: me.chart.chart,\n\t\t\t\t\t\t\t_datasetIndex: me.index\n\t\t\t\t\t\t});\n\t\t\t\t\t},\n\n\t\t\t\t\tcreateMetaData: function createMetaData(index) {\n\t\t\t\t\t\tvar me = this;\n\t\t\t\t\t\tvar type = me.dataElementType;\n\t\t\t\t\t\treturn type && new type({\n\t\t\t\t\t\t\t_chart: me.chart.chart,\n\t\t\t\t\t\t\t_datasetIndex: me.index,\n\t\t\t\t\t\t\t_index: index\n\t\t\t\t\t\t});\n\t\t\t\t\t},\n\n\t\t\t\t\taddElements: function addElements() {\n\t\t\t\t\t\tvar me = this;\n\t\t\t\t\t\tvar meta = me.getMeta();\n\t\t\t\t\t\tvar data = me.getDataset().data || [];\n\t\t\t\t\t\tvar metaData = meta.data;\n\t\t\t\t\t\tvar i, ilen;\n\n\t\t\t\t\t\tfor (i = 0, ilen = data.length; i < ilen; ++i) {\n\t\t\t\t\t\t\tmetaData[i] = metaData[i] || me.createMetaData(i);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tmeta.dataset = meta.dataset || me.createMetaDataset();\n\t\t\t\t\t},\n\n\t\t\t\t\taddElementAndReset: function addElementAndReset(index) {\n\t\t\t\t\t\tvar element = this.createMetaData(index);\n\t\t\t\t\t\tthis.getMeta().data.splice(index, 0, element);\n\t\t\t\t\t\tthis.updateElement(element, index, true);\n\t\t\t\t\t},\n\n\t\t\t\t\tbuildOrUpdateElements: function buildOrUpdateElements() {\n\t\t\t\t\t\tvar me = this;\n\t\t\t\t\t\tvar dataset = me.getDataset();\n\t\t\t\t\t\tvar data = dataset.data || (dataset.data = []);\n\n\t\t\t\t\t\t// In order to correctly handle data addition/deletion animation (an thus simulate\n\t\t\t\t\t\t// real-time charts), we need to monitor these data modifications and synchronize\n\t\t\t\t\t\t// the internal meta data accordingly.\n\t\t\t\t\t\tif (me._data !== data) {\n\t\t\t\t\t\t\tif (me._data) {\n\t\t\t\t\t\t\t\t// This case happens when the user replaced the data array instance.\n\t\t\t\t\t\t\t\tunlistenArrayEvents(me._data, me);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tlistenArrayEvents(data, me);\n\t\t\t\t\t\t\tme._data = data;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Re-sync meta data in case the user replaced the data array or if we missed\n\t\t\t\t\t\t// any updates and so make sure that we handle number of datapoints changing.\n\t\t\t\t\t\tme.resyncElements();\n\t\t\t\t\t},\n\n\t\t\t\t\tupdate: helpers.noop,\n\n\t\t\t\t\tdraw: function draw(ease) {\n\t\t\t\t\t\tvar easingDecimal = ease || 1;\n\t\t\t\t\t\tvar i, len;\n\t\t\t\t\t\tvar metaData = this.getMeta().data;\n\t\t\t\t\t\tfor (i = 0, len = metaData.length; i < len; ++i) {\n\t\t\t\t\t\t\tmetaData[i].transition(easingDecimal).draw();\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\n\t\t\t\t\tremoveHoverStyle: function removeHoverStyle(element, elementOpts) {\n\t\t\t\t\t\tvar dataset = this.chart.data.datasets[element._datasetIndex],\n\t\t\t\t\t\t    index = element._index,\n\t\t\t\t\t\t    custom = element.custom || {},\n\t\t\t\t\t\t    valueOrDefault = helpers.getValueAtIndexOrDefault,\n\t\t\t\t\t\t    model = element._model;\n\n\t\t\t\t\t\tmodel.backgroundColor = custom.backgroundColor ? custom.backgroundColor : valueOrDefault(dataset.backgroundColor, index, elementOpts.backgroundColor);\n\t\t\t\t\t\tmodel.borderColor = custom.borderColor ? custom.borderColor : valueOrDefault(dataset.borderColor, index, elementOpts.borderColor);\n\t\t\t\t\t\tmodel.borderWidth = custom.borderWidth ? custom.borderWidth : valueOrDefault(dataset.borderWidth, index, elementOpts.borderWidth);\n\t\t\t\t\t},\n\n\t\t\t\t\tsetHoverStyle: function setHoverStyle(element) {\n\t\t\t\t\t\tvar dataset = this.chart.data.datasets[element._datasetIndex],\n\t\t\t\t\t\t    index = element._index,\n\t\t\t\t\t\t    custom = element.custom || {},\n\t\t\t\t\t\t    valueOrDefault = helpers.getValueAtIndexOrDefault,\n\t\t\t\t\t\t    getHoverColor = helpers.getHoverColor,\n\t\t\t\t\t\t    model = element._model;\n\n\t\t\t\t\t\tmodel.backgroundColor = custom.hoverBackgroundColor ? custom.hoverBackgroundColor : valueOrDefault(dataset.hoverBackgroundColor, index, getHoverColor(model.backgroundColor));\n\t\t\t\t\t\tmodel.borderColor = custom.hoverBorderColor ? custom.hoverBorderColor : valueOrDefault(dataset.hoverBorderColor, index, getHoverColor(model.borderColor));\n\t\t\t\t\t\tmodel.borderWidth = custom.hoverBorderWidth ? custom.hoverBorderWidth : valueOrDefault(dataset.hoverBorderWidth, index, model.borderWidth);\n\t\t\t\t\t},\n\n\t\t\t\t\t/**\n      * @private\n      */\n\t\t\t\t\tresyncElements: function resyncElements() {\n\t\t\t\t\t\tvar me = this;\n\t\t\t\t\t\tvar meta = me.getMeta();\n\t\t\t\t\t\tvar data = me.getDataset().data;\n\t\t\t\t\t\tvar numMeta = meta.data.length;\n\t\t\t\t\t\tvar numData = data.length;\n\n\t\t\t\t\t\tif (numData < numMeta) {\n\t\t\t\t\t\t\tmeta.data.splice(numData, numMeta - numData);\n\t\t\t\t\t\t} else if (numData > numMeta) {\n\t\t\t\t\t\t\tme.insertElements(numMeta, numData - numMeta);\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\n\t\t\t\t\t/**\n      * @private\n      */\n\t\t\t\t\tinsertElements: function insertElements(start, count) {\n\t\t\t\t\t\tfor (var i = 0; i < count; ++i) {\n\t\t\t\t\t\t\tthis.addElementAndReset(start + i);\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\n\t\t\t\t\t/**\n      * @private\n      */\n\t\t\t\t\tonDataPush: function onDataPush() {\n\t\t\t\t\t\tthis.insertElements(this.getDataset().data.length - 1, arguments.length);\n\t\t\t\t\t},\n\n\t\t\t\t\t/**\n      * @private\n      */\n\t\t\t\t\tonDataPop: function onDataPop() {\n\t\t\t\t\t\tthis.getMeta().data.pop();\n\t\t\t\t\t},\n\n\t\t\t\t\t/**\n      * @private\n      */\n\t\t\t\t\tonDataShift: function onDataShift() {\n\t\t\t\t\t\tthis.getMeta().data.shift();\n\t\t\t\t\t},\n\n\t\t\t\t\t/**\n      * @private\n      */\n\t\t\t\t\tonDataSplice: function onDataSplice(start, count) {\n\t\t\t\t\t\tthis.getMeta().data.splice(start, count);\n\t\t\t\t\t\tthis.insertElements(start, arguments.length - 2);\n\t\t\t\t\t},\n\n\t\t\t\t\t/**\n      * @private\n      */\n\t\t\t\t\tonDataUnshift: function onDataUnshift() {\n\t\t\t\t\t\tthis.insertElements(0, arguments.length);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tChart.DatasetController.extend = helpers.inherits;\n\t\t\t};\n\t\t}, {}], 25: [function (require, module, exports) {\n\t\t\t'use strict';\n\n\t\t\tmodule.exports = function (Chart) {\n\n\t\t\t\tvar helpers = Chart.helpers;\n\n\t\t\t\tChart.elements = {};\n\n\t\t\t\tChart.Element = function (configuration) {\n\t\t\t\t\thelpers.extend(this, configuration);\n\t\t\t\t\tthis.initialize.apply(this, arguments);\n\t\t\t\t};\n\n\t\t\t\thelpers.extend(Chart.Element.prototype, {\n\n\t\t\t\t\tinitialize: function initialize() {\n\t\t\t\t\t\tthis.hidden = false;\n\t\t\t\t\t},\n\n\t\t\t\t\tpivot: function pivot() {\n\t\t\t\t\t\tvar me = this;\n\t\t\t\t\t\tif (!me._view) {\n\t\t\t\t\t\t\tme._view = helpers.clone(me._model);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tme._start = helpers.clone(me._view);\n\t\t\t\t\t\treturn me;\n\t\t\t\t\t},\n\n\t\t\t\t\ttransition: function transition(ease) {\n\t\t\t\t\t\tvar me = this;\n\n\t\t\t\t\t\tif (!me._view) {\n\t\t\t\t\t\t\tme._view = helpers.clone(me._model);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// No animation -> No Transition\n\t\t\t\t\t\tif (ease === 1) {\n\t\t\t\t\t\t\tme._view = me._model;\n\t\t\t\t\t\t\tme._start = null;\n\t\t\t\t\t\t\treturn me;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (!me._start) {\n\t\t\t\t\t\t\tme.pivot();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\thelpers.each(me._model, function (value, key) {\n\n\t\t\t\t\t\t\tif (key[0] === '_') {\n\t\t\t\t\t\t\t\t// Only non-underscored properties\n\t\t\t\t\t\t\t\t// Init if doesn't exist\n\t\t\t\t\t\t\t} else if (!me._view.hasOwnProperty(key)) {\n\t\t\t\t\t\t\t\tif (typeof value === 'number' && !isNaN(me._view[key])) {\n\t\t\t\t\t\t\t\t\tme._view[key] = value * ease;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tme._view[key] = value;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// No unnecessary computations\n\t\t\t\t\t\t\t} else if (value === me._view[key]) {\n\t\t\t\t\t\t\t\t// It's the same! Woohoo!\n\t\t\t\t\t\t\t\t// Color transitions if possible\n\t\t\t\t\t\t\t} else if (typeof value === 'string') {\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tvar color = helpers.color(me._model[key]).mix(helpers.color(me._start[key]), ease);\n\t\t\t\t\t\t\t\t\tme._view[key] = color.rgbString();\n\t\t\t\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\t\t\t\tme._view[key] = value;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// Number transitions\n\t\t\t\t\t\t\t} else if (typeof value === 'number') {\n\t\t\t\t\t\t\t\tvar startVal = me._start[key] !== undefined && isNaN(me._start[key]) === false ? me._start[key] : 0;\n\t\t\t\t\t\t\t\tme._view[key] = (me._model[key] - startVal) * ease + startVal;\n\t\t\t\t\t\t\t\t// Everything else\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tme._view[key] = value;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}, me);\n\n\t\t\t\t\t\treturn me;\n\t\t\t\t\t},\n\n\t\t\t\t\ttooltipPosition: function tooltipPosition() {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tx: this._model.x,\n\t\t\t\t\t\t\ty: this._model.y\n\t\t\t\t\t\t};\n\t\t\t\t\t},\n\n\t\t\t\t\thasValue: function hasValue() {\n\t\t\t\t\t\treturn helpers.isNumber(this._model.x) && helpers.isNumber(this._model.y);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tChart.Element.extend = helpers.inherits;\n\t\t\t};\n\t\t}, {}], 26: [function (require, module, exports) {\n\t\t\t/* global window: false */\n\t\t\t/* global document: false */\n\t\t\t'use strict';\n\n\t\t\tvar color = require(3);\n\n\t\t\tmodule.exports = function (Chart) {\n\t\t\t\t// Global Chart helpers object for utility methods and classes\n\t\t\t\tvar helpers = Chart.helpers = {};\n\n\t\t\t\t// -- Basic js utility methods\n\t\t\t\thelpers.each = function (loopable, callback, self, reverse) {\n\t\t\t\t\t// Check to see if null or undefined firstly.\n\t\t\t\t\tvar i, len;\n\t\t\t\t\tif (helpers.isArray(loopable)) {\n\t\t\t\t\t\tlen = loopable.length;\n\t\t\t\t\t\tif (reverse) {\n\t\t\t\t\t\t\tfor (i = len - 1; i >= 0; i--) {\n\t\t\t\t\t\t\t\tcallback.call(self, loopable[i], i);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\t\t\t\t\tcallback.call(self, loopable[i], i);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if ((typeof loopable === \"undefined\" ? \"undefined\" : _typeof(loopable)) === 'object') {\n\t\t\t\t\t\tvar keys = Object.keys(loopable);\n\t\t\t\t\t\tlen = keys.length;\n\t\t\t\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\t\t\t\tcallback.call(self, loopable[keys[i]], keys[i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\thelpers.clone = function (obj) {\n\t\t\t\t\tvar objClone = {};\n\t\t\t\t\thelpers.each(obj, function (value, key) {\n\t\t\t\t\t\tif (helpers.isArray(value)) {\n\t\t\t\t\t\t\tobjClone[key] = value.slice(0);\n\t\t\t\t\t\t} else if ((typeof value === \"undefined\" ? \"undefined\" : _typeof(value)) === 'object' && value !== null) {\n\t\t\t\t\t\t\tobjClone[key] = helpers.clone(value);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tobjClone[key] = value;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\treturn objClone;\n\t\t\t\t};\n\t\t\t\thelpers.extend = function (base) {\n\t\t\t\t\tvar setFn = function setFn(value, key) {\n\t\t\t\t\t\tbase[key] = value;\n\t\t\t\t\t};\n\t\t\t\t\tfor (var i = 1, ilen = arguments.length; i < ilen; i++) {\n\t\t\t\t\t\thelpers.each(arguments[i], setFn);\n\t\t\t\t\t}\n\t\t\t\t\treturn base;\n\t\t\t\t};\n\t\t\t\t// Need a special merge function to chart configs since they are now grouped\n\t\t\t\thelpers.configMerge = function (_base) {\n\t\t\t\t\tvar base = helpers.clone(_base);\n\t\t\t\t\thelpers.each(Array.prototype.slice.call(arguments, 1), function (extension) {\n\t\t\t\t\t\thelpers.each(extension, function (value, key) {\n\t\t\t\t\t\t\tvar baseHasProperty = base.hasOwnProperty(key);\n\t\t\t\t\t\t\tvar baseVal = baseHasProperty ? base[key] : {};\n\n\t\t\t\t\t\t\tif (key === 'scales') {\n\t\t\t\t\t\t\t\t// Scale config merging is complex. Add our own function here for that\n\t\t\t\t\t\t\t\tbase[key] = helpers.scaleMerge(baseVal, value);\n\t\t\t\t\t\t\t} else if (key === 'scale') {\n\t\t\t\t\t\t\t\t// Used in polar area & radar charts since there is only one scale\n\t\t\t\t\t\t\t\tbase[key] = helpers.configMerge(baseVal, Chart.scaleService.getScaleDefaults(value.type), value);\n\t\t\t\t\t\t\t} else if (baseHasProperty && (typeof baseVal === \"undefined\" ? \"undefined\" : _typeof(baseVal)) === 'object' && !helpers.isArray(baseVal) && baseVal !== null && (typeof value === \"undefined\" ? \"undefined\" : _typeof(value)) === 'object' && !helpers.isArray(value)) {\n\t\t\t\t\t\t\t\t// If we are overwriting an object with an object, do a merge of the properties.\n\t\t\t\t\t\t\t\tbase[key] = helpers.configMerge(baseVal, value);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// can just overwrite the value in this case\n\t\t\t\t\t\t\t\tbase[key] = value;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\n\t\t\t\t\treturn base;\n\t\t\t\t};\n\t\t\t\thelpers.scaleMerge = function (_base, extension) {\n\t\t\t\t\tvar base = helpers.clone(_base);\n\n\t\t\t\t\thelpers.each(extension, function (value, key) {\n\t\t\t\t\t\tif (key === 'xAxes' || key === 'yAxes') {\n\t\t\t\t\t\t\t// These properties are arrays of items\n\t\t\t\t\t\t\tif (base.hasOwnProperty(key)) {\n\t\t\t\t\t\t\t\thelpers.each(value, function (valueObj, index) {\n\t\t\t\t\t\t\t\t\tvar axisType = helpers.getValueOrDefault(valueObj.type, key === 'xAxes' ? 'category' : 'linear');\n\t\t\t\t\t\t\t\t\tvar axisDefaults = Chart.scaleService.getScaleDefaults(axisType);\n\t\t\t\t\t\t\t\t\tif (index >= base[key].length || !base[key][index].type) {\n\t\t\t\t\t\t\t\t\t\tbase[key].push(helpers.configMerge(axisDefaults, valueObj));\n\t\t\t\t\t\t\t\t\t} else if (valueObj.type && valueObj.type !== base[key][index].type) {\n\t\t\t\t\t\t\t\t\t\t// Type changed. Bring in the new defaults before we bring in valueObj so that valueObj can override the correct scale defaults\n\t\t\t\t\t\t\t\t\t\tbase[key][index] = helpers.configMerge(base[key][index], axisDefaults, valueObj);\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t// Type is the same\n\t\t\t\t\t\t\t\t\t\tbase[key][index] = helpers.configMerge(base[key][index], valueObj);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tbase[key] = [];\n\t\t\t\t\t\t\t\thelpers.each(value, function (valueObj) {\n\t\t\t\t\t\t\t\t\tvar axisType = helpers.getValueOrDefault(valueObj.type, key === 'xAxes' ? 'category' : 'linear');\n\t\t\t\t\t\t\t\t\tbase[key].push(helpers.configMerge(Chart.scaleService.getScaleDefaults(axisType), valueObj));\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (base.hasOwnProperty(key) && _typeof(base[key]) === 'object' && base[key] !== null && (typeof value === \"undefined\" ? \"undefined\" : _typeof(value)) === 'object') {\n\t\t\t\t\t\t\t// If we are overwriting an object with an object, do a merge of the properties.\n\t\t\t\t\t\t\tbase[key] = helpers.configMerge(base[key], value);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// can just overwrite the value in this case\n\t\t\t\t\t\t\tbase[key] = value;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t\treturn base;\n\t\t\t\t};\n\t\t\t\thelpers.getValueAtIndexOrDefault = function (value, index, defaultValue) {\n\t\t\t\t\tif (value === undefined || value === null) {\n\t\t\t\t\t\treturn defaultValue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (helpers.isArray(value)) {\n\t\t\t\t\t\treturn index < value.length ? value[index] : defaultValue;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn value;\n\t\t\t\t};\n\t\t\t\thelpers.getValueOrDefault = function (value, defaultValue) {\n\t\t\t\t\treturn value === undefined ? defaultValue : value;\n\t\t\t\t};\n\t\t\t\thelpers.indexOf = Array.prototype.indexOf ? function (array, item) {\n\t\t\t\t\treturn array.indexOf(item);\n\t\t\t\t} : function (array, item) {\n\t\t\t\t\tfor (var i = 0, ilen = array.length; i < ilen; ++i) {\n\t\t\t\t\t\tif (array[i] === item) {\n\t\t\t\t\t\t\treturn i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn -1;\n\t\t\t\t};\n\t\t\t\thelpers.where = function (collection, filterCallback) {\n\t\t\t\t\tif (helpers.isArray(collection) && Array.prototype.filter) {\n\t\t\t\t\t\treturn collection.filter(filterCallback);\n\t\t\t\t\t}\n\t\t\t\t\tvar filtered = [];\n\n\t\t\t\t\thelpers.each(collection, function (item) {\n\t\t\t\t\t\tif (filterCallback(item)) {\n\t\t\t\t\t\t\tfiltered.push(item);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t\treturn filtered;\n\t\t\t\t};\n\t\t\t\thelpers.findIndex = Array.prototype.findIndex ? function (array, callback, scope) {\n\t\t\t\t\treturn array.findIndex(callback, scope);\n\t\t\t\t} : function (array, callback, scope) {\n\t\t\t\t\tscope = scope === undefined ? array : scope;\n\t\t\t\t\tfor (var i = 0, ilen = array.length; i < ilen; ++i) {\n\t\t\t\t\t\tif (callback.call(scope, array[i], i, array)) {\n\t\t\t\t\t\t\treturn i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn -1;\n\t\t\t\t};\n\t\t\t\thelpers.findNextWhere = function (arrayToSearch, filterCallback, startIndex) {\n\t\t\t\t\t// Default to start of the array\n\t\t\t\t\tif (startIndex === undefined || startIndex === null) {\n\t\t\t\t\t\tstartIndex = -1;\n\t\t\t\t\t}\n\t\t\t\t\tfor (var i = startIndex + 1; i < arrayToSearch.length; i++) {\n\t\t\t\t\t\tvar currentItem = arrayToSearch[i];\n\t\t\t\t\t\tif (filterCallback(currentItem)) {\n\t\t\t\t\t\t\treturn currentItem;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\thelpers.findPreviousWhere = function (arrayToSearch, filterCallback, startIndex) {\n\t\t\t\t\t// Default to end of the array\n\t\t\t\t\tif (startIndex === undefined || startIndex === null) {\n\t\t\t\t\t\tstartIndex = arrayToSearch.length;\n\t\t\t\t\t}\n\t\t\t\t\tfor (var i = startIndex - 1; i >= 0; i--) {\n\t\t\t\t\t\tvar currentItem = arrayToSearch[i];\n\t\t\t\t\t\tif (filterCallback(currentItem)) {\n\t\t\t\t\t\t\treturn currentItem;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\thelpers.inherits = function (extensions) {\n\t\t\t\t\t// Basic javascript inheritance based on the model created in Backbone.js\n\t\t\t\t\tvar me = this;\n\t\t\t\t\tvar ChartElement = extensions && extensions.hasOwnProperty('constructor') ? extensions.constructor : function () {\n\t\t\t\t\t\treturn me.apply(this, arguments);\n\t\t\t\t\t};\n\n\t\t\t\t\tvar Surrogate = function Surrogate() {\n\t\t\t\t\t\tthis.constructor = ChartElement;\n\t\t\t\t\t};\n\t\t\t\t\tSurrogate.prototype = me.prototype;\n\t\t\t\t\tChartElement.prototype = new Surrogate();\n\n\t\t\t\t\tChartElement.extend = helpers.inherits;\n\n\t\t\t\t\tif (extensions) {\n\t\t\t\t\t\thelpers.extend(ChartElement.prototype, extensions);\n\t\t\t\t\t}\n\n\t\t\t\t\tChartElement.__super__ = me.prototype;\n\n\t\t\t\t\treturn ChartElement;\n\t\t\t\t};\n\t\t\t\thelpers.noop = function () {};\n\t\t\t\thelpers.uid = function () {\n\t\t\t\t\tvar id = 0;\n\t\t\t\t\treturn function () {\n\t\t\t\t\t\treturn id++;\n\t\t\t\t\t};\n\t\t\t\t}();\n\t\t\t\t// -- Math methods\n\t\t\t\thelpers.isNumber = function (n) {\n\t\t\t\t\treturn !isNaN(parseFloat(n)) && isFinite(n);\n\t\t\t\t};\n\t\t\t\thelpers.almostEquals = function (x, y, epsilon) {\n\t\t\t\t\treturn Math.abs(x - y) < epsilon;\n\t\t\t\t};\n\t\t\t\thelpers.almostWhole = function (x, epsilon) {\n\t\t\t\t\tvar rounded = Math.round(x);\n\t\t\t\t\treturn rounded - epsilon < x && rounded + epsilon > x;\n\t\t\t\t};\n\t\t\t\thelpers.max = function (array) {\n\t\t\t\t\treturn array.reduce(function (max, value) {\n\t\t\t\t\t\tif (!isNaN(value)) {\n\t\t\t\t\t\t\treturn Math.max(max, value);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn max;\n\t\t\t\t\t}, Number.NEGATIVE_INFINITY);\n\t\t\t\t};\n\t\t\t\thelpers.min = function (array) {\n\t\t\t\t\treturn array.reduce(function (min, value) {\n\t\t\t\t\t\tif (!isNaN(value)) {\n\t\t\t\t\t\t\treturn Math.min(min, value);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn min;\n\t\t\t\t\t}, Number.POSITIVE_INFINITY);\n\t\t\t\t};\n\t\t\t\thelpers.sign = Math.sign ? function (x) {\n\t\t\t\t\treturn Math.sign(x);\n\t\t\t\t} : function (x) {\n\t\t\t\t\tx = +x; // convert to a number\n\t\t\t\t\tif (x === 0 || isNaN(x)) {\n\t\t\t\t\t\treturn x;\n\t\t\t\t\t}\n\t\t\t\t\treturn x > 0 ? 1 : -1;\n\t\t\t\t};\n\t\t\t\thelpers.log10 = Math.log10 ? function (x) {\n\t\t\t\t\treturn Math.log10(x);\n\t\t\t\t} : function (x) {\n\t\t\t\t\treturn Math.log(x) / Math.LN10;\n\t\t\t\t};\n\t\t\t\thelpers.toRadians = function (degrees) {\n\t\t\t\t\treturn degrees * (Math.PI / 180);\n\t\t\t\t};\n\t\t\t\thelpers.toDegrees = function (radians) {\n\t\t\t\t\treturn radians * (180 / Math.PI);\n\t\t\t\t};\n\t\t\t\t// Gets the angle from vertical upright to the point about a centre.\n\t\t\t\thelpers.getAngleFromPoint = function (centrePoint, anglePoint) {\n\t\t\t\t\tvar distanceFromXCenter = anglePoint.x - centrePoint.x,\n\t\t\t\t\t    distanceFromYCenter = anglePoint.y - centrePoint.y,\n\t\t\t\t\t    radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);\n\n\t\t\t\t\tvar angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);\n\n\t\t\t\t\tif (angle < -0.5 * Math.PI) {\n\t\t\t\t\t\tangle += 2.0 * Math.PI; // make sure the returned angle is in the range of (-PI/2, 3PI/2]\n\t\t\t\t\t}\n\n\t\t\t\t\treturn {\n\t\t\t\t\t\tangle: angle,\n\t\t\t\t\t\tdistance: radialDistanceFromCenter\n\t\t\t\t\t};\n\t\t\t\t};\n\t\t\t\thelpers.distanceBetweenPoints = function (pt1, pt2) {\n\t\t\t\t\treturn Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));\n\t\t\t\t};\n\t\t\t\thelpers.aliasPixel = function (pixelWidth) {\n\t\t\t\t\treturn pixelWidth % 2 === 0 ? 0 : 0.5;\n\t\t\t\t};\n\t\t\t\thelpers.splineCurve = function (firstPoint, middlePoint, afterPoint, t) {\n\t\t\t\t\t// Props to Rob Spencer at scaled innovation for his post on splining between points\n\t\t\t\t\t// http://scaledinnovation.com/analytics/splines/aboutSplines.html\n\n\t\t\t\t\t// This function must also respect \"skipped\" points\n\n\t\t\t\t\tvar previous = firstPoint.skip ? middlePoint : firstPoint,\n\t\t\t\t\t    current = middlePoint,\n\t\t\t\t\t    next = afterPoint.skip ? middlePoint : afterPoint;\n\n\t\t\t\t\tvar d01 = Math.sqrt(Math.pow(current.x - previous.x, 2) + Math.pow(current.y - previous.y, 2));\n\t\t\t\t\tvar d12 = Math.sqrt(Math.pow(next.x - current.x, 2) + Math.pow(next.y - current.y, 2));\n\n\t\t\t\t\tvar s01 = d01 / (d01 + d12);\n\t\t\t\t\tvar s12 = d12 / (d01 + d12);\n\n\t\t\t\t\t// If all points are the same, s01 & s02 will be inf\n\t\t\t\t\ts01 = isNaN(s01) ? 0 : s01;\n\t\t\t\t\ts12 = isNaN(s12) ? 0 : s12;\n\n\t\t\t\t\tvar fa = t * s01; // scaling factor for triangle Ta\n\t\t\t\t\tvar fb = t * s12;\n\n\t\t\t\t\treturn {\n\t\t\t\t\t\tprevious: {\n\t\t\t\t\t\t\tx: current.x - fa * (next.x - previous.x),\n\t\t\t\t\t\t\ty: current.y - fa * (next.y - previous.y)\n\t\t\t\t\t\t},\n\t\t\t\t\t\tnext: {\n\t\t\t\t\t\t\tx: current.x + fb * (next.x - previous.x),\n\t\t\t\t\t\t\ty: current.y + fb * (next.y - previous.y)\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t};\n\t\t\t\thelpers.EPSILON = Number.EPSILON || 1e-14;\n\t\t\t\thelpers.splineCurveMonotone = function (points) {\n\t\t\t\t\t// This function calculates Bézier control points in a similar way than |splineCurve|,\n\t\t\t\t\t// but preserves monotonicity of the provided data and ensures no local extremums are added\n\t\t\t\t\t// between the dataset discrete points due to the interpolation.\n\t\t\t\t\t// See : https://en.wikipedia.org/wiki/Monotone_cubic_interpolation\n\n\t\t\t\t\tvar pointsWithTangents = (points || []).map(function (point) {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tmodel: point._model,\n\t\t\t\t\t\t\tdeltaK: 0,\n\t\t\t\t\t\t\tmK: 0\n\t\t\t\t\t\t};\n\t\t\t\t\t});\n\n\t\t\t\t\t// Calculate slopes (deltaK) and initialize tangents (mK)\n\t\t\t\t\tvar pointsLen = pointsWithTangents.length;\n\t\t\t\t\tvar i, pointBefore, pointCurrent, pointAfter;\n\t\t\t\t\tfor (i = 0; i < pointsLen; ++i) {\n\t\t\t\t\t\tpointCurrent = pointsWithTangents[i];\n\t\t\t\t\t\tif (pointCurrent.model.skip) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tpointBefore = i > 0 ? pointsWithTangents[i - 1] : null;\n\t\t\t\t\t\tpointAfter = i < pointsLen - 1 ? pointsWithTangents[i + 1] : null;\n\t\t\t\t\t\tif (pointAfter && !pointAfter.model.skip) {\n\t\t\t\t\t\t\tvar slopeDeltaX = pointAfter.model.x - pointCurrent.model.x;\n\n\t\t\t\t\t\t\t// In the case of two points that appear at the same x pixel, slopeDeltaX is 0\n\t\t\t\t\t\t\tpointCurrent.deltaK = slopeDeltaX !== 0 ? (pointAfter.model.y - pointCurrent.model.y) / slopeDeltaX : 0;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (!pointBefore || pointBefore.model.skip) {\n\t\t\t\t\t\t\tpointCurrent.mK = pointCurrent.deltaK;\n\t\t\t\t\t\t} else if (!pointAfter || pointAfter.model.skip) {\n\t\t\t\t\t\t\tpointCurrent.mK = pointBefore.deltaK;\n\t\t\t\t\t\t} else if (this.sign(pointBefore.deltaK) !== this.sign(pointCurrent.deltaK)) {\n\t\t\t\t\t\t\tpointCurrent.mK = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tpointCurrent.mK = (pointBefore.deltaK + pointCurrent.deltaK) / 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Adjust tangents to ensure monotonic properties\n\t\t\t\t\tvar alphaK, betaK, tauK, squaredMagnitude;\n\t\t\t\t\tfor (i = 0; i < pointsLen - 1; ++i) {\n\t\t\t\t\t\tpointCurrent = pointsWithTangents[i];\n\t\t\t\t\t\tpointAfter = pointsWithTangents[i + 1];\n\t\t\t\t\t\tif (pointCurrent.model.skip || pointAfter.model.skip) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (helpers.almostEquals(pointCurrent.deltaK, 0, this.EPSILON)) {\n\t\t\t\t\t\t\tpointCurrent.mK = pointAfter.mK = 0;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\talphaK = pointCurrent.mK / pointCurrent.deltaK;\n\t\t\t\t\t\tbetaK = pointAfter.mK / pointCurrent.deltaK;\n\t\t\t\t\t\tsquaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);\n\t\t\t\t\t\tif (squaredMagnitude <= 9) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttauK = 3 / Math.sqrt(squaredMagnitude);\n\t\t\t\t\t\tpointCurrent.mK = alphaK * tauK * pointCurrent.deltaK;\n\t\t\t\t\t\tpointAfter.mK = betaK * tauK * pointCurrent.deltaK;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Compute control points\n\t\t\t\t\tvar deltaX;\n\t\t\t\t\tfor (i = 0; i < pointsLen; ++i) {\n\t\t\t\t\t\tpointCurrent = pointsWithTangents[i];\n\t\t\t\t\t\tif (pointCurrent.model.skip) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tpointBefore = i > 0 ? pointsWithTangents[i - 1] : null;\n\t\t\t\t\t\tpointAfter = i < pointsLen - 1 ? pointsWithTangents[i + 1] : null;\n\t\t\t\t\t\tif (pointBefore && !pointBefore.model.skip) {\n\t\t\t\t\t\t\tdeltaX = (pointCurrent.model.x - pointBefore.model.x) / 3;\n\t\t\t\t\t\t\tpointCurrent.model.controlPointPreviousX = pointCurrent.model.x - deltaX;\n\t\t\t\t\t\t\tpointCurrent.model.controlPointPreviousY = pointCurrent.model.y - deltaX * pointCurrent.mK;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (pointAfter && !pointAfter.model.skip) {\n\t\t\t\t\t\t\tdeltaX = (pointAfter.model.x - pointCurrent.model.x) / 3;\n\t\t\t\t\t\t\tpointCurrent.model.controlPointNextX = pointCurrent.model.x + deltaX;\n\t\t\t\t\t\t\tpointCurrent.model.controlPointNextY = pointCurrent.model.y + deltaX * pointCurrent.mK;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\thelpers.nextItem = function (collection, index, loop) {\n\t\t\t\t\tif (loop) {\n\t\t\t\t\t\treturn index >= collection.length - 1 ? collection[0] : collection[index + 1];\n\t\t\t\t\t}\n\t\t\t\t\treturn index >= collection.length - 1 ? collection[collection.length - 1] : collection[index + 1];\n\t\t\t\t};\n\t\t\t\thelpers.previousItem = function (collection, index, loop) {\n\t\t\t\t\tif (loop) {\n\t\t\t\t\t\treturn index <= 0 ? collection[collection.length - 1] : collection[index - 1];\n\t\t\t\t\t}\n\t\t\t\t\treturn index <= 0 ? collection[0] : collection[index - 1];\n\t\t\t\t};\n\t\t\t\t// Implementation of the nice number algorithm used in determining where axis labels will go\n\t\t\t\thelpers.niceNum = function (range, round) {\n\t\t\t\t\tvar exponent = Math.floor(helpers.log10(range));\n\t\t\t\t\tvar fraction = range / Math.pow(10, exponent);\n\t\t\t\t\tvar niceFraction;\n\n\t\t\t\t\tif (round) {\n\t\t\t\t\t\tif (fraction < 1.5) {\n\t\t\t\t\t\t\tniceFraction = 1;\n\t\t\t\t\t\t} else if (fraction < 3) {\n\t\t\t\t\t\t\tniceFraction = 2;\n\t\t\t\t\t\t} else if (fraction < 7) {\n\t\t\t\t\t\t\tniceFraction = 5;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tniceFraction = 10;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (fraction <= 1.0) {\n\t\t\t\t\t\tniceFraction = 1;\n\t\t\t\t\t} else if (fraction <= 2) {\n\t\t\t\t\t\tniceFraction = 2;\n\t\t\t\t\t} else if (fraction <= 5) {\n\t\t\t\t\t\tniceFraction = 5;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tniceFraction = 10;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn niceFraction * Math.pow(10, exponent);\n\t\t\t\t};\n\t\t\t\t// Easing functions adapted from Robert Penner's easing equations\n\t\t\t\t// http://www.robertpenner.com/easing/\n\t\t\t\tvar easingEffects = helpers.easingEffects = {\n\t\t\t\t\tlinear: function linear(t) {\n\t\t\t\t\t\treturn t;\n\t\t\t\t\t},\n\t\t\t\t\teaseInQuad: function easeInQuad(t) {\n\t\t\t\t\t\treturn t * t;\n\t\t\t\t\t},\n\t\t\t\t\teaseOutQuad: function easeOutQuad(t) {\n\t\t\t\t\t\treturn -1 * t * (t - 2);\n\t\t\t\t\t},\n\t\t\t\t\teaseInOutQuad: function easeInOutQuad(t) {\n\t\t\t\t\t\tif ((t /= 1 / 2) < 1) {\n\t\t\t\t\t\t\treturn 1 / 2 * t * t;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn -1 / 2 * (--t * (t - 2) - 1);\n\t\t\t\t\t},\n\t\t\t\t\teaseInCubic: function easeInCubic(t) {\n\t\t\t\t\t\treturn t * t * t;\n\t\t\t\t\t},\n\t\t\t\t\teaseOutCubic: function easeOutCubic(t) {\n\t\t\t\t\t\treturn 1 * ((t = t / 1 - 1) * t * t + 1);\n\t\t\t\t\t},\n\t\t\t\t\teaseInOutCubic: function easeInOutCubic(t) {\n\t\t\t\t\t\tif ((t /= 1 / 2) < 1) {\n\t\t\t\t\t\t\treturn 1 / 2 * t * t * t;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn 1 / 2 * ((t -= 2) * t * t + 2);\n\t\t\t\t\t},\n\t\t\t\t\teaseInQuart: function easeInQuart(t) {\n\t\t\t\t\t\treturn t * t * t * t;\n\t\t\t\t\t},\n\t\t\t\t\teaseOutQuart: function easeOutQuart(t) {\n\t\t\t\t\t\treturn -1 * ((t = t / 1 - 1) * t * t * t - 1);\n\t\t\t\t\t},\n\t\t\t\t\teaseInOutQuart: function easeInOutQuart(t) {\n\t\t\t\t\t\tif ((t /= 1 / 2) < 1) {\n\t\t\t\t\t\t\treturn 1 / 2 * t * t * t * t;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn -1 / 2 * ((t -= 2) * t * t * t - 2);\n\t\t\t\t\t},\n\t\t\t\t\teaseInQuint: function easeInQuint(t) {\n\t\t\t\t\t\treturn 1 * (t /= 1) * t * t * t * t;\n\t\t\t\t\t},\n\t\t\t\t\teaseOutQuint: function easeOutQuint(t) {\n\t\t\t\t\t\treturn 1 * ((t = t / 1 - 1) * t * t * t * t + 1);\n\t\t\t\t\t},\n\t\t\t\t\teaseInOutQuint: function easeInOutQuint(t) {\n\t\t\t\t\t\tif ((t /= 1 / 2) < 1) {\n\t\t\t\t\t\t\treturn 1 / 2 * t * t * t * t * t;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn 1 / 2 * ((t -= 2) * t * t * t * t + 2);\n\t\t\t\t\t},\n\t\t\t\t\teaseInSine: function easeInSine(t) {\n\t\t\t\t\t\treturn -1 * Math.cos(t / 1 * (Math.PI / 2)) + 1;\n\t\t\t\t\t},\n\t\t\t\t\teaseOutSine: function easeOutSine(t) {\n\t\t\t\t\t\treturn 1 * Math.sin(t / 1 * (Math.PI / 2));\n\t\t\t\t\t},\n\t\t\t\t\teaseInOutSine: function easeInOutSine(t) {\n\t\t\t\t\t\treturn -1 / 2 * (Math.cos(Math.PI * t / 1) - 1);\n\t\t\t\t\t},\n\t\t\t\t\teaseInExpo: function easeInExpo(t) {\n\t\t\t\t\t\treturn t === 0 ? 1 : 1 * Math.pow(2, 10 * (t / 1 - 1));\n\t\t\t\t\t},\n\t\t\t\t\teaseOutExpo: function easeOutExpo(t) {\n\t\t\t\t\t\treturn t === 1 ? 1 : 1 * (-Math.pow(2, -10 * t / 1) + 1);\n\t\t\t\t\t},\n\t\t\t\t\teaseInOutExpo: function easeInOutExpo(t) {\n\t\t\t\t\t\tif (t === 0) {\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (t === 1) {\n\t\t\t\t\t\t\treturn 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ((t /= 1 / 2) < 1) {\n\t\t\t\t\t\t\treturn 1 / 2 * Math.pow(2, 10 * (t - 1));\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn 1 / 2 * (-Math.pow(2, -10 * --t) + 2);\n\t\t\t\t\t},\n\t\t\t\t\teaseInCirc: function easeInCirc(t) {\n\t\t\t\t\t\tif (t >= 1) {\n\t\t\t\t\t\t\treturn t;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn -1 * (Math.sqrt(1 - (t /= 1) * t) - 1);\n\t\t\t\t\t},\n\t\t\t\t\teaseOutCirc: function easeOutCirc(t) {\n\t\t\t\t\t\treturn 1 * Math.sqrt(1 - (t = t / 1 - 1) * t);\n\t\t\t\t\t},\n\t\t\t\t\teaseInOutCirc: function easeInOutCirc(t) {\n\t\t\t\t\t\tif ((t /= 1 / 2) < 1) {\n\t\t\t\t\t\t\treturn -1 / 2 * (Math.sqrt(1 - t * t) - 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn 1 / 2 * (Math.sqrt(1 - (t -= 2) * t) + 1);\n\t\t\t\t\t},\n\t\t\t\t\teaseInElastic: function easeInElastic(t) {\n\t\t\t\t\t\tvar s = 1.70158;\n\t\t\t\t\t\tvar p = 0;\n\t\t\t\t\t\tvar a = 1;\n\t\t\t\t\t\tif (t === 0) {\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ((t /= 1) === 1) {\n\t\t\t\t\t\t\treturn 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!p) {\n\t\t\t\t\t\t\tp = 1 * 0.3;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (a < Math.abs(1)) {\n\t\t\t\t\t\t\ta = 1;\n\t\t\t\t\t\t\ts = p / 4;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ts = p / (2 * Math.PI) * Math.asin(1 / a);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * 1 - s) * (2 * Math.PI) / p));\n\t\t\t\t\t},\n\t\t\t\t\teaseOutElastic: function easeOutElastic(t) {\n\t\t\t\t\t\tvar s = 1.70158;\n\t\t\t\t\t\tvar p = 0;\n\t\t\t\t\t\tvar a = 1;\n\t\t\t\t\t\tif (t === 0) {\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ((t /= 1) === 1) {\n\t\t\t\t\t\t\treturn 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!p) {\n\t\t\t\t\t\t\tp = 1 * 0.3;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (a < Math.abs(1)) {\n\t\t\t\t\t\t\ta = 1;\n\t\t\t\t\t\t\ts = p / 4;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ts = p / (2 * Math.PI) * Math.asin(1 / a);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn a * Math.pow(2, -10 * t) * Math.sin((t * 1 - s) * (2 * Math.PI) / p) + 1;\n\t\t\t\t\t},\n\t\t\t\t\teaseInOutElastic: function easeInOutElastic(t) {\n\t\t\t\t\t\tvar s = 1.70158;\n\t\t\t\t\t\tvar p = 0;\n\t\t\t\t\t\tvar a = 1;\n\t\t\t\t\t\tif (t === 0) {\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ((t /= 1 / 2) === 2) {\n\t\t\t\t\t\t\treturn 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!p) {\n\t\t\t\t\t\t\tp = 1 * (0.3 * 1.5);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (a < Math.abs(1)) {\n\t\t\t\t\t\t\ta = 1;\n\t\t\t\t\t\t\ts = p / 4;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ts = p / (2 * Math.PI) * Math.asin(1 / a);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (t < 1) {\n\t\t\t\t\t\t\treturn -0.5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * 1 - s) * (2 * Math.PI) / p));\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t * 1 - s) * (2 * Math.PI) / p) * 0.5 + 1;\n\t\t\t\t\t},\n\t\t\t\t\teaseInBack: function easeInBack(t) {\n\t\t\t\t\t\tvar s = 1.70158;\n\t\t\t\t\t\treturn 1 * (t /= 1) * t * ((s + 1) * t - s);\n\t\t\t\t\t},\n\t\t\t\t\teaseOutBack: function easeOutBack(t) {\n\t\t\t\t\t\tvar s = 1.70158;\n\t\t\t\t\t\treturn 1 * ((t = t / 1 - 1) * t * ((s + 1) * t + s) + 1);\n\t\t\t\t\t},\n\t\t\t\t\teaseInOutBack: function easeInOutBack(t) {\n\t\t\t\t\t\tvar s = 1.70158;\n\t\t\t\t\t\tif ((t /= 1 / 2) < 1) {\n\t\t\t\t\t\t\treturn 1 / 2 * (t * t * (((s *= 1.525) + 1) * t - s));\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn 1 / 2 * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2);\n\t\t\t\t\t},\n\t\t\t\t\teaseInBounce: function easeInBounce(t) {\n\t\t\t\t\t\treturn 1 - easingEffects.easeOutBounce(1 - t);\n\t\t\t\t\t},\n\t\t\t\t\teaseOutBounce: function easeOutBounce(t) {\n\t\t\t\t\t\tif ((t /= 1) < 1 / 2.75) {\n\t\t\t\t\t\t\treturn 1 * (7.5625 * t * t);\n\t\t\t\t\t\t} else if (t < 2 / 2.75) {\n\t\t\t\t\t\t\treturn 1 * (7.5625 * (t -= 1.5 / 2.75) * t + 0.75);\n\t\t\t\t\t\t} else if (t < 2.5 / 2.75) {\n\t\t\t\t\t\t\treturn 1 * (7.5625 * (t -= 2.25 / 2.75) * t + 0.9375);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn 1 * (7.5625 * (t -= 2.625 / 2.75) * t + 0.984375);\n\t\t\t\t\t},\n\t\t\t\t\teaseInOutBounce: function easeInOutBounce(t) {\n\t\t\t\t\t\tif (t < 1 / 2) {\n\t\t\t\t\t\t\treturn easingEffects.easeInBounce(t * 2) * 0.5;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn easingEffects.easeOutBounce(t * 2 - 1) * 0.5 + 1 * 0.5;\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\t// Request animation polyfill - http://www.paulirish.com/2011/requestanimationframe-for-smart-animating/\n\t\t\t\thelpers.requestAnimFrame = function () {\n\t\t\t\t\treturn window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (callback) {\n\t\t\t\t\t\treturn window.setTimeout(callback, 1000 / 60);\n\t\t\t\t\t};\n\t\t\t\t}();\n\t\t\t\t// -- DOM methods\n\t\t\t\thelpers.getRelativePosition = function (evt, chart) {\n\t\t\t\t\tvar mouseX, mouseY;\n\t\t\t\t\tvar e = evt.originalEvent || evt,\n\t\t\t\t\t    canvas = evt.currentTarget || evt.srcElement,\n\t\t\t\t\t    boundingRect = canvas.getBoundingClientRect();\n\n\t\t\t\t\tvar touches = e.touches;\n\t\t\t\t\tif (touches && touches.length > 0) {\n\t\t\t\t\t\tmouseX = touches[0].clientX;\n\t\t\t\t\t\tmouseY = touches[0].clientY;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmouseX = e.clientX;\n\t\t\t\t\t\tmouseY = e.clientY;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Scale mouse coordinates into canvas coordinates\n\t\t\t\t\t// by following the pattern laid out by 'jerryj' in the comments of\n\t\t\t\t\t// http://www.html5canvastutorials.com/advanced/html5-canvas-mouse-coordinates/\n\t\t\t\t\tvar paddingLeft = parseFloat(helpers.getStyle(canvas, 'padding-left'));\n\t\t\t\t\tvar paddingTop = parseFloat(helpers.getStyle(canvas, 'padding-top'));\n\t\t\t\t\tvar paddingRight = parseFloat(helpers.getStyle(canvas, 'padding-right'));\n\t\t\t\t\tvar paddingBottom = parseFloat(helpers.getStyle(canvas, 'padding-bottom'));\n\t\t\t\t\tvar width = boundingRect.right - boundingRect.left - paddingLeft - paddingRight;\n\t\t\t\t\tvar height = boundingRect.bottom - boundingRect.top - paddingTop - paddingBottom;\n\n\t\t\t\t\t// We divide by the current device pixel ratio, because the canvas is scaled up by that amount in each direction. However\n\t\t\t\t\t// the backend model is in unscaled coordinates. Since we are going to deal with our model coordinates, we go back here\n\t\t\t\t\tmouseX = Math.round((mouseX - boundingRect.left - paddingLeft) / width * canvas.width / chart.currentDevicePixelRatio);\n\t\t\t\t\tmouseY = Math.round((mouseY - boundingRect.top - paddingTop) / height * canvas.height / chart.currentDevicePixelRatio);\n\n\t\t\t\t\treturn {\n\t\t\t\t\t\tx: mouseX,\n\t\t\t\t\t\ty: mouseY\n\t\t\t\t\t};\n\t\t\t\t};\n\t\t\t\thelpers.addEvent = function (node, eventType, method) {\n\t\t\t\t\tif (node.addEventListener) {\n\t\t\t\t\t\tnode.addEventListener(eventType, method);\n\t\t\t\t\t} else if (node.attachEvent) {\n\t\t\t\t\t\tnode.attachEvent('on' + eventType, method);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnode['on' + eventType] = method;\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\thelpers.removeEvent = function (node, eventType, handler) {\n\t\t\t\t\tif (node.removeEventListener) {\n\t\t\t\t\t\tnode.removeEventListener(eventType, handler, false);\n\t\t\t\t\t} else if (node.detachEvent) {\n\t\t\t\t\t\tnode.detachEvent('on' + eventType, handler);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnode['on' + eventType] = helpers.noop;\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\t// Private helper function to convert max-width/max-height values that may be percentages into a number\n\t\t\t\tfunction parseMaxStyle(styleValue, node, parentProperty) {\n\t\t\t\t\tvar valueInPixels;\n\t\t\t\t\tif (typeof styleValue === 'string') {\n\t\t\t\t\t\tvalueInPixels = parseInt(styleValue, 10);\n\n\t\t\t\t\t\tif (styleValue.indexOf('%') !== -1) {\n\t\t\t\t\t\t\t// percentage * size in dimension\n\t\t\t\t\t\t\tvalueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvalueInPixels = styleValue;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn valueInPixels;\n\t\t\t\t}\n\n\t\t\t\t/**\n     * Returns if the given value contains an effective constraint.\n     * @private\n     */\n\t\t\t\tfunction isConstrainedValue(value) {\n\t\t\t\t\treturn value !== undefined && value !== null && value !== 'none';\n\t\t\t\t}\n\n\t\t\t\t// Private helper to get a constraint dimension\n\t\t\t\t// @param domNode : the node to check the constraint on\n\t\t\t\t// @param maxStyle : the style that defines the maximum for the direction we are using (maxWidth / maxHeight)\n\t\t\t\t// @param percentageProperty : property of parent to use when calculating width as a percentage\n\t\t\t\t// @see http://www.nathanaeljones.com/blog/2013/reading-max-width-cross-browser\n\t\t\t\tfunction getConstraintDimension(domNode, maxStyle, percentageProperty) {\n\t\t\t\t\tvar view = document.defaultView;\n\t\t\t\t\tvar parentNode = domNode.parentNode;\n\t\t\t\t\tvar constrainedNode = view.getComputedStyle(domNode)[maxStyle];\n\t\t\t\t\tvar constrainedContainer = view.getComputedStyle(parentNode)[maxStyle];\n\t\t\t\t\tvar hasCNode = isConstrainedValue(constrainedNode);\n\t\t\t\t\tvar hasCContainer = isConstrainedValue(constrainedContainer);\n\t\t\t\t\tvar infinity = Number.POSITIVE_INFINITY;\n\n\t\t\t\t\tif (hasCNode || hasCContainer) {\n\t\t\t\t\t\treturn Math.min(hasCNode ? parseMaxStyle(constrainedNode, domNode, percentageProperty) : infinity, hasCContainer ? parseMaxStyle(constrainedContainer, parentNode, percentageProperty) : infinity);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn 'none';\n\t\t\t\t}\n\t\t\t\t// returns Number or undefined if no constraint\n\t\t\t\thelpers.getConstraintWidth = function (domNode) {\n\t\t\t\t\treturn getConstraintDimension(domNode, 'max-width', 'clientWidth');\n\t\t\t\t};\n\t\t\t\t// returns Number or undefined if no constraint\n\t\t\t\thelpers.getConstraintHeight = function (domNode) {\n\t\t\t\t\treturn getConstraintDimension(domNode, 'max-height', 'clientHeight');\n\t\t\t\t};\n\t\t\t\thelpers.getMaximumWidth = function (domNode) {\n\t\t\t\t\tvar container = domNode.parentNode;\n\t\t\t\t\tvar paddingLeft = parseInt(helpers.getStyle(container, 'padding-left'), 10);\n\t\t\t\t\tvar paddingRight = parseInt(helpers.getStyle(container, 'padding-right'), 10);\n\t\t\t\t\tvar w = container.clientWidth - paddingLeft - paddingRight;\n\t\t\t\t\tvar cw = helpers.getConstraintWidth(domNode);\n\t\t\t\t\treturn isNaN(cw) ? w : Math.min(w, cw);\n\t\t\t\t};\n\t\t\t\thelpers.getMaximumHeight = function (domNode) {\n\t\t\t\t\tvar container = domNode.parentNode;\n\t\t\t\t\tvar paddingTop = parseInt(helpers.getStyle(container, 'padding-top'), 10);\n\t\t\t\t\tvar paddingBottom = parseInt(helpers.getStyle(container, 'padding-bottom'), 10);\n\t\t\t\t\tvar h = container.clientHeight - paddingTop - paddingBottom;\n\t\t\t\t\tvar ch = helpers.getConstraintHeight(domNode);\n\t\t\t\t\treturn isNaN(ch) ? h : Math.min(h, ch);\n\t\t\t\t};\n\t\t\t\thelpers.getStyle = function (el, property) {\n\t\t\t\t\treturn el.currentStyle ? el.currentStyle[property] : document.defaultView.getComputedStyle(el, null).getPropertyValue(property);\n\t\t\t\t};\n\t\t\t\thelpers.retinaScale = function (chart) {\n\t\t\t\t\tvar pixelRatio = chart.currentDevicePixelRatio = window.devicePixelRatio || 1;\n\t\t\t\t\tif (pixelRatio === 1) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar canvas = chart.canvas;\n\t\t\t\t\tvar height = chart.height;\n\t\t\t\t\tvar width = chart.width;\n\n\t\t\t\t\tcanvas.height = height * pixelRatio;\n\t\t\t\t\tcanvas.width = width * pixelRatio;\n\t\t\t\t\tchart.ctx.scale(pixelRatio, pixelRatio);\n\n\t\t\t\t\t// If no style has been set on the canvas, the render size is used as display size,\n\t\t\t\t\t// making the chart visually bigger, so let's enforce it to the \"correct\" values.\n\t\t\t\t\t// See https://github.com/chartjs/Chart.js/issues/3575\n\t\t\t\t\tcanvas.style.height = height + 'px';\n\t\t\t\t\tcanvas.style.width = width + 'px';\n\t\t\t\t};\n\t\t\t\t// -- Canvas methods\n\t\t\t\thelpers.clear = function (chart) {\n\t\t\t\t\tchart.ctx.clearRect(0, 0, chart.width, chart.height);\n\t\t\t\t};\n\t\t\t\thelpers.fontString = function (pixelSize, fontStyle, fontFamily) {\n\t\t\t\t\treturn fontStyle + ' ' + pixelSize + 'px ' + fontFamily;\n\t\t\t\t};\n\t\t\t\thelpers.longestText = function (ctx, font, arrayOfThings, cache) {\n\t\t\t\t\tcache = cache || {};\n\t\t\t\t\tvar data = cache.data = cache.data || {};\n\t\t\t\t\tvar gc = cache.garbageCollect = cache.garbageCollect || [];\n\n\t\t\t\t\tif (cache.font !== font) {\n\t\t\t\t\t\tdata = cache.data = {};\n\t\t\t\t\t\tgc = cache.garbageCollect = [];\n\t\t\t\t\t\tcache.font = font;\n\t\t\t\t\t}\n\n\t\t\t\t\tctx.font = font;\n\t\t\t\t\tvar longest = 0;\n\t\t\t\t\thelpers.each(arrayOfThings, function (thing) {\n\t\t\t\t\t\t// Undefined strings and arrays should not be measured\n\t\t\t\t\t\tif (thing !== undefined && thing !== null && helpers.isArray(thing) !== true) {\n\t\t\t\t\t\t\tlongest = helpers.measureText(ctx, data, gc, longest, thing);\n\t\t\t\t\t\t} else if (helpers.isArray(thing)) {\n\t\t\t\t\t\t\t// if it is an array lets measure each element\n\t\t\t\t\t\t\t// to do maybe simplify this function a bit so we can do this more recursively?\n\t\t\t\t\t\t\thelpers.each(thing, function (nestedThing) {\n\t\t\t\t\t\t\t\t// Undefined strings and arrays should not be measured\n\t\t\t\t\t\t\t\tif (nestedThing !== undefined && nestedThing !== null && !helpers.isArray(nestedThing)) {\n\t\t\t\t\t\t\t\t\tlongest = helpers.measureText(ctx, data, gc, longest, nestedThing);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t\tvar gcLen = gc.length / 2;\n\t\t\t\t\tif (gcLen > arrayOfThings.length) {\n\t\t\t\t\t\tfor (var i = 0; i < gcLen; i++) {\n\t\t\t\t\t\t\tdelete data[gc[i]];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgc.splice(0, gcLen);\n\t\t\t\t\t}\n\t\t\t\t\treturn longest;\n\t\t\t\t};\n\t\t\t\thelpers.measureText = function (ctx, data, gc, longest, string) {\n\t\t\t\t\tvar textWidth = data[string];\n\t\t\t\t\tif (!textWidth) {\n\t\t\t\t\t\ttextWidth = data[string] = ctx.measureText(string).width;\n\t\t\t\t\t\tgc.push(string);\n\t\t\t\t\t}\n\t\t\t\t\tif (textWidth > longest) {\n\t\t\t\t\t\tlongest = textWidth;\n\t\t\t\t\t}\n\t\t\t\t\treturn longest;\n\t\t\t\t};\n\t\t\t\thelpers.numberOfLabelLines = function (arrayOfThings) {\n\t\t\t\t\tvar numberOfLines = 1;\n\t\t\t\t\thelpers.each(arrayOfThings, function (thing) {\n\t\t\t\t\t\tif (helpers.isArray(thing)) {\n\t\t\t\t\t\t\tif (thing.length > numberOfLines) {\n\t\t\t\t\t\t\t\tnumberOfLines = thing.length;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\treturn numberOfLines;\n\t\t\t\t};\n\t\t\t\thelpers.drawRoundedRectangle = function (ctx, x, y, width, height, radius) {\n\t\t\t\t\tctx.beginPath();\n\t\t\t\t\tctx.moveTo(x + radius, y);\n\t\t\t\t\tctx.lineTo(x + width - radius, y);\n\t\t\t\t\tctx.quadraticCurveTo(x + width, y, x + width, y + radius);\n\t\t\t\t\tctx.lineTo(x + width, y + height - radius);\n\t\t\t\t\tctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);\n\t\t\t\t\tctx.lineTo(x + radius, y + height);\n\t\t\t\t\tctx.quadraticCurveTo(x, y + height, x, y + height - radius);\n\t\t\t\t\tctx.lineTo(x, y + radius);\n\t\t\t\t\tctx.quadraticCurveTo(x, y, x + radius, y);\n\t\t\t\t\tctx.closePath();\n\t\t\t\t};\n\t\t\t\thelpers.color = function (c) {\n\t\t\t\t\tif (!color) {\n\t\t\t\t\t\tconsole.error('Color.js not found!');\n\t\t\t\t\t\treturn c;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* global CanvasGradient */\n\t\t\t\t\tif (c instanceof CanvasGradient) {\n\t\t\t\t\t\treturn color(Chart.defaults.global.defaultColor);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn color(c);\n\t\t\t\t};\n\t\t\t\thelpers.isArray = Array.isArray ? function (obj) {\n\t\t\t\t\treturn Array.isArray(obj);\n\t\t\t\t} : function (obj) {\n\t\t\t\t\treturn Object.prototype.toString.call(obj) === '[object Array]';\n\t\t\t\t};\n\t\t\t\t// ! @see http://stackoverflow.com/a/14853974\n\t\t\t\thelpers.arrayEquals = function (a0, a1) {\n\t\t\t\t\tvar i, ilen, v0, v1;\n\n\t\t\t\t\tif (!a0 || !a1 || a0.length !== a1.length) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (i = 0, ilen = a0.length; i < ilen; ++i) {\n\t\t\t\t\t\tv0 = a0[i];\n\t\t\t\t\t\tv1 = a1[i];\n\n\t\t\t\t\t\tif (v0 instanceof Array && v1 instanceof Array) {\n\t\t\t\t\t\t\tif (!helpers.arrayEquals(v0, v1)) {\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (v0 !== v1) {\n\t\t\t\t\t\t\t// NOTE: two different object instances will never be equal: {x:20} != {x:20}\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn true;\n\t\t\t\t};\n\t\t\t\thelpers.callCallback = function (fn, args, _tArg) {\n\t\t\t\t\tif (fn && typeof fn.call === 'function') {\n\t\t\t\t\t\tfn.apply(_tArg, args);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\thelpers.getHoverColor = function (colorValue) {\n\t\t\t\t\t/* global CanvasPattern */\n\t\t\t\t\treturn colorValue instanceof CanvasPattern ? colorValue : helpers.color(colorValue).saturate(0.5).darken(0.1).rgbString();\n\t\t\t\t};\n\t\t\t};\n\t\t}, { \"3\": 3 }], 27: [function (require, module, exports) {\n\t\t\t'use strict';\n\n\t\t\tmodule.exports = function (Chart) {\n\t\t\t\tvar helpers = Chart.helpers;\n\n\t\t\t\t/**\n     * Helper function to get relative position for an event\n     * @param {Event|IEvent} event - The event to get the position for\n     * @param {Chart} chart - The chart\n     * @returns {Point} the event position\n     */\n\t\t\t\tfunction getRelativePosition(e, chart) {\n\t\t\t\t\tif (e.native) {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tx: e.x,\n\t\t\t\t\t\t\ty: e.y\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t\treturn helpers.getRelativePosition(e, chart);\n\t\t\t\t}\n\n\t\t\t\t/**\n     * Helper function to traverse all of the visible elements in the chart\n     * @param chart {chart} the chart\n     * @param handler {Function} the callback to execute for each visible item\n     */\n\t\t\t\tfunction parseVisibleItems(chart, handler) {\n\t\t\t\t\tvar datasets = chart.data.datasets;\n\t\t\t\t\tvar meta, i, j, ilen, jlen;\n\n\t\t\t\t\tfor (i = 0, ilen = datasets.length; i < ilen; ++i) {\n\t\t\t\t\t\tif (!chart.isDatasetVisible(i)) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tmeta = chart.getDatasetMeta(i);\n\t\t\t\t\t\tfor (j = 0, jlen = meta.data.length; j < jlen; ++j) {\n\t\t\t\t\t\t\tvar element = meta.data[j];\n\t\t\t\t\t\t\tif (!element._view.skip) {\n\t\t\t\t\t\t\t\thandler(element);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/**\n     * Helper function to get the items that intersect the event position\n     * @param items {ChartElement[]} elements to filter\n     * @param position {Point} the point to be nearest to\n     * @return {ChartElement[]} the nearest items\n     */\n\t\t\t\tfunction getIntersectItems(chart, position) {\n\t\t\t\t\tvar elements = [];\n\n\t\t\t\t\tparseVisibleItems(chart, function (element) {\n\t\t\t\t\t\tif (element.inRange(position.x, position.y)) {\n\t\t\t\t\t\t\telements.push(element);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t\treturn elements;\n\t\t\t\t}\n\n\t\t\t\t/**\n     * Helper function to get the items nearest to the event position considering all visible items in teh chart\n     * @param chart {Chart} the chart to look at elements from\n     * @param position {Point} the point to be nearest to\n     * @param intersect {Boolean} if true, only consider items that intersect the position\n     * @param distanceMetric {Function} Optional function to provide the distance between\n     * @return {ChartElement[]} the nearest items\n     */\n\t\t\t\tfunction getNearestItems(chart, position, intersect, distanceMetric) {\n\t\t\t\t\tvar minDistance = Number.POSITIVE_INFINITY;\n\t\t\t\t\tvar nearestItems = [];\n\n\t\t\t\t\tif (!distanceMetric) {\n\t\t\t\t\t\tdistanceMetric = helpers.distanceBetweenPoints;\n\t\t\t\t\t}\n\n\t\t\t\t\tparseVisibleItems(chart, function (element) {\n\t\t\t\t\t\tif (intersect && !element.inRange(position.x, position.y)) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar center = element.getCenterPoint();\n\t\t\t\t\t\tvar distance = distanceMetric(position, center);\n\n\t\t\t\t\t\tif (distance < minDistance) {\n\t\t\t\t\t\t\tnearestItems = [element];\n\t\t\t\t\t\t\tminDistance = distance;\n\t\t\t\t\t\t} else if (distance === minDistance) {\n\t\t\t\t\t\t\t// Can have multiple items at the same distance in which case we sort by size\n\t\t\t\t\t\t\tnearestItems.push(element);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t\treturn nearestItems;\n\t\t\t\t}\n\n\t\t\t\tfunction indexMode(chart, e, options) {\n\t\t\t\t\tvar position = getRelativePosition(e, chart.chart);\n\t\t\t\t\tvar distanceMetric = function distanceMetric(pt1, pt2) {\n\t\t\t\t\t\treturn Math.abs(pt1.x - pt2.x);\n\t\t\t\t\t};\n\t\t\t\t\tvar items = options.intersect ? getIntersectItems(chart, position) : getNearestItems(chart, position, false, distanceMetric);\n\t\t\t\t\tvar elements = [];\n\n\t\t\t\t\tif (!items.length) {\n\t\t\t\t\t\treturn [];\n\t\t\t\t\t}\n\n\t\t\t\t\tchart.data.datasets.forEach(function (dataset, datasetIndex) {\n\t\t\t\t\t\tif (chart.isDatasetVisible(datasetIndex)) {\n\t\t\t\t\t\t\tvar meta = chart.getDatasetMeta(datasetIndex),\n\t\t\t\t\t\t\t    element = meta.data[items[0]._index];\n\n\t\t\t\t\t\t\t// don't count items that are skipped (null data)\n\t\t\t\t\t\t\tif (element && !element._view.skip) {\n\t\t\t\t\t\t\t\telements.push(element);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t\treturn elements;\n\t\t\t\t}\n\n\t\t\t\t/**\n     * @interface IInteractionOptions\n     */\n\t\t\t\t/**\n     * If true, only consider items that intersect the point\n     * @name IInterfaceOptions#boolean\n     * @type Boolean\n     */\n\n\t\t\t\t/**\n     * Contains interaction related functions\n     * @namespace Chart.Interaction\n     */\n\t\t\t\tChart.Interaction = {\n\t\t\t\t\t// Helper function for different modes\n\t\t\t\t\tmodes: {\n\t\t\t\t\t\tsingle: function single(chart, e) {\n\t\t\t\t\t\t\tvar position = getRelativePosition(e, chart.chart);\n\t\t\t\t\t\t\tvar elements = [];\n\n\t\t\t\t\t\t\tparseVisibleItems(chart, function (element) {\n\t\t\t\t\t\t\t\tif (element.inRange(position.x, position.y)) {\n\t\t\t\t\t\t\t\t\telements.push(element);\n\t\t\t\t\t\t\t\t\treturn elements;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\treturn elements.slice(0, 1);\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\t/**\n       * @function Chart.Interaction.modes.label\n       * @deprecated since version 2.4.0\n       */\n\t\t\t\t\t\tlabel: indexMode,\n\n\t\t\t\t\t\t/**\n       * Returns items at the same index. If the options.intersect parameter is true, we only return items if we intersect something\n       * If the options.intersect mode is false, we find the nearest item and return the items at the same index as that item\n       * @function Chart.Interaction.modes.index\n       * @since v2.4.0\n       * @param chart {chart} the chart we are returning items from\n       * @param e {Event} the event we are find things at\n       * @param options {IInteractionOptions} options to use during interaction\n       * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\n       */\n\t\t\t\t\t\tindex: indexMode,\n\n\t\t\t\t\t\t/**\n       * Returns items in the same dataset. If the options.intersect parameter is true, we only return items if we intersect something\n       * If the options.intersect is false, we find the nearest item and return the items in that dataset\n       * @function Chart.Interaction.modes.dataset\n       * @param chart {chart} the chart we are returning items from\n       * @param e {Event} the event we are find things at\n       * @param options {IInteractionOptions} options to use during interaction\n       * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\n       */\n\t\t\t\t\t\tdataset: function dataset(chart, e, options) {\n\t\t\t\t\t\t\tvar position = getRelativePosition(e, chart.chart);\n\t\t\t\t\t\t\tvar items = options.intersect ? getIntersectItems(chart, position) : getNearestItems(chart, position, false);\n\n\t\t\t\t\t\t\tif (items.length > 0) {\n\t\t\t\t\t\t\t\titems = chart.getDatasetMeta(items[0]._datasetIndex).data;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treturn items;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\t/**\n       * @function Chart.Interaction.modes.x-axis\n       * @deprecated since version 2.4.0. Use index mode and intersect == true\n       */\n\t\t\t\t\t\t'x-axis': function xAxis(chart, e) {\n\t\t\t\t\t\t\treturn indexMode(chart, e, true);\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\t/**\n       * Point mode returns all elements that hit test based on the event position\n       * of the event\n       * @function Chart.Interaction.modes.intersect\n       * @param chart {chart} the chart we are returning items from\n       * @param e {Event} the event we are find things at\n       * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\n       */\n\t\t\t\t\t\tpoint: function point(chart, e) {\n\t\t\t\t\t\t\tvar position = getRelativePosition(e, chart.chart);\n\t\t\t\t\t\t\treturn getIntersectItems(chart, position);\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\t/**\n       * nearest mode returns the element closest to the point\n       * @function Chart.Interaction.modes.intersect\n       * @param chart {chart} the chart we are returning items from\n       * @param e {Event} the event we are find things at\n       * @param options {IInteractionOptions} options to use\n       * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\n       */\n\t\t\t\t\t\tnearest: function nearest(chart, e, options) {\n\t\t\t\t\t\t\tvar position = getRelativePosition(e, chart.chart);\n\t\t\t\t\t\t\tvar nearestItems = getNearestItems(chart, position, options.intersect);\n\n\t\t\t\t\t\t\t// We have multiple items at the same distance from the event. Now sort by smallest\n\t\t\t\t\t\t\tif (nearestItems.length > 1) {\n\t\t\t\t\t\t\t\tnearestItems.sort(function (a, b) {\n\t\t\t\t\t\t\t\t\tvar sizeA = a.getArea();\n\t\t\t\t\t\t\t\t\tvar sizeB = b.getArea();\n\t\t\t\t\t\t\t\t\tvar ret = sizeA - sizeB;\n\n\t\t\t\t\t\t\t\t\tif (ret === 0) {\n\t\t\t\t\t\t\t\t\t\t// if equal sort by dataset index\n\t\t\t\t\t\t\t\t\t\tret = a._datasetIndex - b._datasetIndex;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturn ret;\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Return only 1 item\n\t\t\t\t\t\t\treturn nearestItems.slice(0, 1);\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\t/**\n       * x mode returns the elements that hit-test at the current x coordinate\n       * @function Chart.Interaction.modes.x\n       * @param chart {chart} the chart we are returning items from\n       * @param e {Event} the event we are find things at\n       * @param options {IInteractionOptions} options to use\n       * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\n       */\n\t\t\t\t\t\tx: function x(chart, e, options) {\n\t\t\t\t\t\t\tvar position = getRelativePosition(e, chart.chart);\n\t\t\t\t\t\t\tvar items = [];\n\t\t\t\t\t\t\tvar intersectsItem = false;\n\n\t\t\t\t\t\t\tparseVisibleItems(chart, function (element) {\n\t\t\t\t\t\t\t\tif (element.inXRange(position.x)) {\n\t\t\t\t\t\t\t\t\titems.push(element);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (element.inRange(position.x, position.y)) {\n\t\t\t\t\t\t\t\t\tintersectsItem = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t// If we want to trigger on an intersect and we don't have any items\n\t\t\t\t\t\t\t// that intersect the position, return nothing\n\t\t\t\t\t\t\tif (options.intersect && !intersectsItem) {\n\t\t\t\t\t\t\t\titems = [];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn items;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\t/**\n       * y mode returns the elements that hit-test at the current y coordinate\n       * @function Chart.Interaction.modes.y\n       * @param chart {chart} the chart we are returning items from\n       * @param e {Event} the event we are find things at\n       * @param options {IInteractionOptions} options to use\n       * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\n       */\n\t\t\t\t\t\ty: function y(chart, e, options) {\n\t\t\t\t\t\t\tvar position = getRelativePosition(e, chart.chart);\n\t\t\t\t\t\t\tvar items = [];\n\t\t\t\t\t\t\tvar intersectsItem = false;\n\n\t\t\t\t\t\t\tparseVisibleItems(chart, function (element) {\n\t\t\t\t\t\t\t\tif (element.inYRange(position.y)) {\n\t\t\t\t\t\t\t\t\titems.push(element);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (element.inRange(position.x, position.y)) {\n\t\t\t\t\t\t\t\t\tintersectsItem = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t// If we want to trigger on an intersect and we don't have any items\n\t\t\t\t\t\t\t// that intersect the position, return nothing\n\t\t\t\t\t\t\tif (options.intersect && !intersectsItem) {\n\t\t\t\t\t\t\t\titems = [];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn items;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t};\n\t\t}, {}], 28: [function (require, module, exports) {\n\t\t\t'use strict';\n\n\t\t\tmodule.exports = function () {\n\n\t\t\t\t// Occupy the global variable of Chart, and create a simple base class\n\t\t\t\tvar Chart = function Chart(item, config) {\n\t\t\t\t\tthis.controller = new Chart.Controller(item, config, this);\n\t\t\t\t\treturn this.controller;\n\t\t\t\t};\n\n\t\t\t\t// Globally expose the defaults to allow for user updating/changing\n\t\t\t\tChart.defaults = {\n\t\t\t\t\tglobal: {\n\t\t\t\t\t\tresponsive: true,\n\t\t\t\t\t\tresponsiveAnimationDuration: 0,\n\t\t\t\t\t\tmaintainAspectRatio: true,\n\t\t\t\t\t\tevents: ['mousemove', 'mouseout', 'click', 'touchstart', 'touchmove'],\n\t\t\t\t\t\thover: {\n\t\t\t\t\t\t\tonHover: null,\n\t\t\t\t\t\t\tmode: 'nearest',\n\t\t\t\t\t\t\tintersect: true,\n\t\t\t\t\t\t\tanimationDuration: 400\n\t\t\t\t\t\t},\n\t\t\t\t\t\tonClick: null,\n\t\t\t\t\t\tdefaultColor: 'rgba(0,0,0,0.1)',\n\t\t\t\t\t\tdefaultFontColor: '#666',\n\t\t\t\t\t\tdefaultFontFamily: \"'Helvetica Neue', 'Helvetica', 'Arial', sans-serif\",\n\t\t\t\t\t\tdefaultFontSize: 12,\n\t\t\t\t\t\tdefaultFontStyle: 'normal',\n\t\t\t\t\t\tshowLines: true,\n\n\t\t\t\t\t\t// Element defaults defined in element extensions\n\t\t\t\t\t\telements: {},\n\n\t\t\t\t\t\t// Legend callback string\n\t\t\t\t\t\tlegendCallback: function legendCallback(chart) {\n\t\t\t\t\t\t\tvar text = [];\n\t\t\t\t\t\t\ttext.push('<ul class=\"' + chart.id + '-legend\">');\n\t\t\t\t\t\t\tfor (var i = 0; i < chart.data.datasets.length; i++) {\n\t\t\t\t\t\t\t\ttext.push('<li><span style=\"background-color:' + chart.data.datasets[i].backgroundColor + '\"></span>');\n\t\t\t\t\t\t\t\tif (chart.data.datasets[i].label) {\n\t\t\t\t\t\t\t\t\ttext.push(chart.data.datasets[i].label);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\ttext.push('</li>');\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttext.push('</ul>');\n\n\t\t\t\t\t\t\treturn text.join('');\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\tChart.Chart = Chart;\n\n\t\t\t\treturn Chart;\n\t\t\t};\n\t\t}, {}], 29: [function (require, module, exports) {\n\t\t\t'use strict';\n\n\t\t\tmodule.exports = function (Chart) {\n\n\t\t\t\tvar helpers = Chart.helpers;\n\n\t\t\t\t// The layout service is very self explanatory.  It's responsible for the layout within a chart.\n\t\t\t\t// Scales, Legends and Plugins all rely on the layout service and can easily register to be placed anywhere they need\n\t\t\t\t// It is this service's responsibility of carrying out that layout.\n\t\t\t\tChart.layoutService = {\n\t\t\t\t\tdefaults: {},\n\n\t\t\t\t\t// Register a box to a chartInstance. A box is simply a reference to an object that requires layout. eg. Scales, Legend, Plugins.\n\t\t\t\t\taddBox: function addBox(chartInstance, box) {\n\t\t\t\t\t\tif (!chartInstance.boxes) {\n\t\t\t\t\t\t\tchartInstance.boxes = [];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tchartInstance.boxes.push(box);\n\t\t\t\t\t},\n\n\t\t\t\t\tremoveBox: function removeBox(chartInstance, box) {\n\t\t\t\t\t\tif (!chartInstance.boxes) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tchartInstance.boxes.splice(chartInstance.boxes.indexOf(box), 1);\n\t\t\t\t\t},\n\n\t\t\t\t\t// The most important function\n\t\t\t\t\tupdate: function update(chartInstance, width, height) {\n\n\t\t\t\t\t\tif (!chartInstance) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar layoutOptions = chartInstance.options.layout;\n\t\t\t\t\t\tvar padding = layoutOptions ? layoutOptions.padding : null;\n\n\t\t\t\t\t\tvar leftPadding = 0;\n\t\t\t\t\t\tvar rightPadding = 0;\n\t\t\t\t\t\tvar topPadding = 0;\n\t\t\t\t\t\tvar bottomPadding = 0;\n\n\t\t\t\t\t\tif (!isNaN(padding)) {\n\t\t\t\t\t\t\t// options.layout.padding is a number. assign to all\n\t\t\t\t\t\t\tleftPadding = padding;\n\t\t\t\t\t\t\trightPadding = padding;\n\t\t\t\t\t\t\ttopPadding = padding;\n\t\t\t\t\t\t\tbottomPadding = padding;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tleftPadding = padding.left || 0;\n\t\t\t\t\t\t\trightPadding = padding.right || 0;\n\t\t\t\t\t\t\ttopPadding = padding.top || 0;\n\t\t\t\t\t\t\tbottomPadding = padding.bottom || 0;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar leftBoxes = helpers.where(chartInstance.boxes, function (box) {\n\t\t\t\t\t\t\treturn box.options.position === 'left';\n\t\t\t\t\t\t});\n\t\t\t\t\t\tvar rightBoxes = helpers.where(chartInstance.boxes, function (box) {\n\t\t\t\t\t\t\treturn box.options.position === 'right';\n\t\t\t\t\t\t});\n\t\t\t\t\t\tvar topBoxes = helpers.where(chartInstance.boxes, function (box) {\n\t\t\t\t\t\t\treturn box.options.position === 'top';\n\t\t\t\t\t\t});\n\t\t\t\t\t\tvar bottomBoxes = helpers.where(chartInstance.boxes, function (box) {\n\t\t\t\t\t\t\treturn box.options.position === 'bottom';\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\t// Boxes that overlay the chartarea such as the radialLinear scale\n\t\t\t\t\t\tvar chartAreaBoxes = helpers.where(chartInstance.boxes, function (box) {\n\t\t\t\t\t\t\treturn box.options.position === 'chartArea';\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\t// Ensure that full width boxes are at the very top / bottom\n\t\t\t\t\t\ttopBoxes.sort(function (a, b) {\n\t\t\t\t\t\t\treturn (b.options.fullWidth ? 1 : 0) - (a.options.fullWidth ? 1 : 0);\n\t\t\t\t\t\t});\n\t\t\t\t\t\tbottomBoxes.sort(function (a, b) {\n\t\t\t\t\t\t\treturn (a.options.fullWidth ? 1 : 0) - (b.options.fullWidth ? 1 : 0);\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\t// Essentially we now have any number of boxes on each of the 4 sides.\n\t\t\t\t\t\t// Our canvas looks like the following.\n\t\t\t\t\t\t// The areas L1 and L2 are the left axes. R1 is the right axis, T1 is the top axis and\n\t\t\t\t\t\t// B1 is the bottom axis\n\t\t\t\t\t\t// There are also 4 quadrant-like locations (left to right instead of clockwise) reserved for chart overlays\n\t\t\t\t\t\t// These locations are single-box locations only, when trying to register a chartArea location that is already taken,\n\t\t\t\t\t\t// an error will be thrown.\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// |----------------------------------------------------|\n\t\t\t\t\t\t// |                  T1 (Full Width)                   |\n\t\t\t\t\t\t// |----------------------------------------------------|\n\t\t\t\t\t\t// |    |    |                 T2                  |    |\n\t\t\t\t\t\t// |    |----|-------------------------------------|----|\n\t\t\t\t\t\t// |    |    | C1 |                           | C2 |    |\n\t\t\t\t\t\t// |    |    |----|                           |----|    |\n\t\t\t\t\t\t// |    |    |                                     |    |\n\t\t\t\t\t\t// | L1 | L2 |           ChartArea (C0)            | R1 |\n\t\t\t\t\t\t// |    |    |                                     |    |\n\t\t\t\t\t\t// |    |    |----|                           |----|    |\n\t\t\t\t\t\t// |    |    | C3 |                           | C4 |    |\n\t\t\t\t\t\t// |    |----|-------------------------------------|----|\n\t\t\t\t\t\t// |    |    |                 B1                  |    |\n\t\t\t\t\t\t// |----------------------------------------------------|\n\t\t\t\t\t\t// |                  B2 (Full Width)                   |\n\t\t\t\t\t\t// |----------------------------------------------------|\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// What we do to find the best sizing, we do the following\n\t\t\t\t\t\t// 1. Determine the minimum size of the chart area.\n\t\t\t\t\t\t// 2. Split the remaining width equally between each vertical axis\n\t\t\t\t\t\t// 3. Split the remaining height equally between each horizontal axis\n\t\t\t\t\t\t// 4. Give each layout the maximum size it can be. The layout will return it's minimum size\n\t\t\t\t\t\t// 5. Adjust the sizes of each axis based on it's minimum reported size.\n\t\t\t\t\t\t// 6. Refit each axis\n\t\t\t\t\t\t// 7. Position each axis in the final location\n\t\t\t\t\t\t// 8. Tell the chart the final location of the chart area\n\t\t\t\t\t\t// 9. Tell any axes that overlay the chart area the positions of the chart area\n\n\t\t\t\t\t\t// Step 1\n\t\t\t\t\t\tvar chartWidth = width - leftPadding - rightPadding;\n\t\t\t\t\t\tvar chartHeight = height - topPadding - bottomPadding;\n\t\t\t\t\t\tvar chartAreaWidth = chartWidth / 2; // min 50%\n\t\t\t\t\t\tvar chartAreaHeight = chartHeight / 2; // min 50%\n\n\t\t\t\t\t\t// Step 2\n\t\t\t\t\t\tvar verticalBoxWidth = (width - chartAreaWidth) / (leftBoxes.length + rightBoxes.length);\n\n\t\t\t\t\t\t// Step 3\n\t\t\t\t\t\tvar horizontalBoxHeight = (height - chartAreaHeight) / (topBoxes.length + bottomBoxes.length);\n\n\t\t\t\t\t\t// Step 4\n\t\t\t\t\t\tvar maxChartAreaWidth = chartWidth;\n\t\t\t\t\t\tvar maxChartAreaHeight = chartHeight;\n\t\t\t\t\t\tvar minBoxSizes = [];\n\n\t\t\t\t\t\tfunction getMinimumBoxSize(box) {\n\t\t\t\t\t\t\tvar minSize;\n\t\t\t\t\t\t\tvar isHorizontal = box.isHorizontal();\n\n\t\t\t\t\t\t\tif (isHorizontal) {\n\t\t\t\t\t\t\t\tminSize = box.update(box.options.fullWidth ? chartWidth : maxChartAreaWidth, horizontalBoxHeight);\n\t\t\t\t\t\t\t\tmaxChartAreaHeight -= minSize.height;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tminSize = box.update(verticalBoxWidth, chartAreaHeight);\n\t\t\t\t\t\t\t\tmaxChartAreaWidth -= minSize.width;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tminBoxSizes.push({\n\t\t\t\t\t\t\t\thorizontal: isHorizontal,\n\t\t\t\t\t\t\t\tminSize: minSize,\n\t\t\t\t\t\t\t\tbox: box\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\thelpers.each(leftBoxes.concat(rightBoxes, topBoxes, bottomBoxes), getMinimumBoxSize);\n\n\t\t\t\t\t\t// If a horizontal box has padding, we move the left boxes over to avoid ugly charts (see issue #2478)\n\t\t\t\t\t\tvar maxHorizontalLeftPadding = 0;\n\t\t\t\t\t\tvar maxHorizontalRightPadding = 0;\n\t\t\t\t\t\tvar maxVerticalTopPadding = 0;\n\t\t\t\t\t\tvar maxVerticalBottomPadding = 0;\n\n\t\t\t\t\t\thelpers.each(topBoxes.concat(bottomBoxes), function (horizontalBox) {\n\t\t\t\t\t\t\tif (horizontalBox.getPadding) {\n\t\t\t\t\t\t\t\tvar boxPadding = horizontalBox.getPadding();\n\t\t\t\t\t\t\t\tmaxHorizontalLeftPadding = Math.max(maxHorizontalLeftPadding, boxPadding.left);\n\t\t\t\t\t\t\t\tmaxHorizontalRightPadding = Math.max(maxHorizontalRightPadding, boxPadding.right);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\thelpers.each(leftBoxes.concat(rightBoxes), function (verticalBox) {\n\t\t\t\t\t\t\tif (verticalBox.getPadding) {\n\t\t\t\t\t\t\t\tvar boxPadding = verticalBox.getPadding();\n\t\t\t\t\t\t\t\tmaxVerticalTopPadding = Math.max(maxVerticalTopPadding, boxPadding.top);\n\t\t\t\t\t\t\t\tmaxVerticalBottomPadding = Math.max(maxVerticalBottomPadding, boxPadding.bottom);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\t// At this point, maxChartAreaHeight and maxChartAreaWidth are the size the chart area could\n\t\t\t\t\t\t// be if the axes are drawn at their minimum sizes.\n\t\t\t\t\t\t// Steps 5 & 6\n\t\t\t\t\t\tvar totalLeftBoxesWidth = leftPadding;\n\t\t\t\t\t\tvar totalRightBoxesWidth = rightPadding;\n\t\t\t\t\t\tvar totalTopBoxesHeight = topPadding;\n\t\t\t\t\t\tvar totalBottomBoxesHeight = bottomPadding;\n\n\t\t\t\t\t\t// Function to fit a box\n\t\t\t\t\t\tfunction fitBox(box) {\n\t\t\t\t\t\t\tvar minBoxSize = helpers.findNextWhere(minBoxSizes, function (minBox) {\n\t\t\t\t\t\t\t\treturn minBox.box === box;\n\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\tif (minBoxSize) {\n\t\t\t\t\t\t\t\tif (box.isHorizontal()) {\n\t\t\t\t\t\t\t\t\tvar scaleMargin = {\n\t\t\t\t\t\t\t\t\t\tleft: Math.max(totalLeftBoxesWidth, maxHorizontalLeftPadding),\n\t\t\t\t\t\t\t\t\t\tright: Math.max(totalRightBoxesWidth, maxHorizontalRightPadding),\n\t\t\t\t\t\t\t\t\t\ttop: 0,\n\t\t\t\t\t\t\t\t\t\tbottom: 0\n\t\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t\t\t// Don't use min size here because of label rotation. When the labels are rotated, their rotation highly depends\n\t\t\t\t\t\t\t\t\t// on the margin. Sometimes they need to increase in size slightly\n\t\t\t\t\t\t\t\t\tbox.update(box.options.fullWidth ? chartWidth : maxChartAreaWidth, chartHeight / 2, scaleMargin);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tbox.update(minBoxSize.minSize.width, maxChartAreaHeight);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Update, and calculate the left and right margins for the horizontal boxes\n\t\t\t\t\t\thelpers.each(leftBoxes.concat(rightBoxes), fitBox);\n\n\t\t\t\t\t\thelpers.each(leftBoxes, function (box) {\n\t\t\t\t\t\t\ttotalLeftBoxesWidth += box.width;\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\thelpers.each(rightBoxes, function (box) {\n\t\t\t\t\t\t\ttotalRightBoxesWidth += box.width;\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\t// Set the Left and Right margins for the horizontal boxes\n\t\t\t\t\t\thelpers.each(topBoxes.concat(bottomBoxes), fitBox);\n\n\t\t\t\t\t\t// Figure out how much margin is on the top and bottom of the vertical boxes\n\t\t\t\t\t\thelpers.each(topBoxes, function (box) {\n\t\t\t\t\t\t\ttotalTopBoxesHeight += box.height;\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\thelpers.each(bottomBoxes, function (box) {\n\t\t\t\t\t\t\ttotalBottomBoxesHeight += box.height;\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tfunction finalFitVerticalBox(box) {\n\t\t\t\t\t\t\tvar minBoxSize = helpers.findNextWhere(minBoxSizes, function (minSize) {\n\t\t\t\t\t\t\t\treturn minSize.box === box;\n\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\tvar scaleMargin = {\n\t\t\t\t\t\t\t\tleft: 0,\n\t\t\t\t\t\t\t\tright: 0,\n\t\t\t\t\t\t\t\ttop: totalTopBoxesHeight,\n\t\t\t\t\t\t\t\tbottom: totalBottomBoxesHeight\n\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\tif (minBoxSize) {\n\t\t\t\t\t\t\t\tbox.update(minBoxSize.minSize.width, maxChartAreaHeight, scaleMargin);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Let the left layout know the final margin\n\t\t\t\t\t\thelpers.each(leftBoxes.concat(rightBoxes), finalFitVerticalBox);\n\n\t\t\t\t\t\t// Recalculate because the size of each layout might have changed slightly due to the margins (label rotation for instance)\n\t\t\t\t\t\ttotalLeftBoxesWidth = leftPadding;\n\t\t\t\t\t\ttotalRightBoxesWidth = rightPadding;\n\t\t\t\t\t\ttotalTopBoxesHeight = topPadding;\n\t\t\t\t\t\ttotalBottomBoxesHeight = bottomPadding;\n\n\t\t\t\t\t\thelpers.each(leftBoxes, function (box) {\n\t\t\t\t\t\t\ttotalLeftBoxesWidth += box.width;\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\thelpers.each(rightBoxes, function (box) {\n\t\t\t\t\t\t\ttotalRightBoxesWidth += box.width;\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\thelpers.each(topBoxes, function (box) {\n\t\t\t\t\t\t\ttotalTopBoxesHeight += box.height;\n\t\t\t\t\t\t});\n\t\t\t\t\t\thelpers.each(bottomBoxes, function (box) {\n\t\t\t\t\t\t\ttotalBottomBoxesHeight += box.height;\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\t// We may be adding some padding to account for rotated x axis labels\n\t\t\t\t\t\tvar leftPaddingAddition = Math.max(maxHorizontalLeftPadding - totalLeftBoxesWidth, 0);\n\t\t\t\t\t\ttotalLeftBoxesWidth += leftPaddingAddition;\n\t\t\t\t\t\ttotalRightBoxesWidth += Math.max(maxHorizontalRightPadding - totalRightBoxesWidth, 0);\n\n\t\t\t\t\t\tvar topPaddingAddition = Math.max(maxVerticalTopPadding - totalTopBoxesHeight, 0);\n\t\t\t\t\t\ttotalTopBoxesHeight += topPaddingAddition;\n\t\t\t\t\t\ttotalBottomBoxesHeight += Math.max(maxVerticalBottomPadding - totalBottomBoxesHeight, 0);\n\n\t\t\t\t\t\t// Figure out if our chart area changed. This would occur if the dataset layout label rotation\n\t\t\t\t\t\t// changed due to the application of the margins in step 6. Since we can only get bigger, this is safe to do\n\t\t\t\t\t\t// without calling `fit` again\n\t\t\t\t\t\tvar newMaxChartAreaHeight = height - totalTopBoxesHeight - totalBottomBoxesHeight;\n\t\t\t\t\t\tvar newMaxChartAreaWidth = width - totalLeftBoxesWidth - totalRightBoxesWidth;\n\n\t\t\t\t\t\tif (newMaxChartAreaWidth !== maxChartAreaWidth || newMaxChartAreaHeight !== maxChartAreaHeight) {\n\t\t\t\t\t\t\thelpers.each(leftBoxes, function (box) {\n\t\t\t\t\t\t\t\tbox.height = newMaxChartAreaHeight;\n\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\thelpers.each(rightBoxes, function (box) {\n\t\t\t\t\t\t\t\tbox.height = newMaxChartAreaHeight;\n\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\thelpers.each(topBoxes, function (box) {\n\t\t\t\t\t\t\t\tif (!box.options.fullWidth) {\n\t\t\t\t\t\t\t\t\tbox.width = newMaxChartAreaWidth;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\thelpers.each(bottomBoxes, function (box) {\n\t\t\t\t\t\t\t\tif (!box.options.fullWidth) {\n\t\t\t\t\t\t\t\t\tbox.width = newMaxChartAreaWidth;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\tmaxChartAreaHeight = newMaxChartAreaHeight;\n\t\t\t\t\t\t\tmaxChartAreaWidth = newMaxChartAreaWidth;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Step 7 - Position the boxes\n\t\t\t\t\t\tvar left = leftPadding + leftPaddingAddition;\n\t\t\t\t\t\tvar top = topPadding + topPaddingAddition;\n\n\t\t\t\t\t\tfunction placeBox(box) {\n\t\t\t\t\t\t\tif (box.isHorizontal()) {\n\t\t\t\t\t\t\t\tbox.left = box.options.fullWidth ? leftPadding : totalLeftBoxesWidth;\n\t\t\t\t\t\t\t\tbox.right = box.options.fullWidth ? width - rightPadding : totalLeftBoxesWidth + maxChartAreaWidth;\n\t\t\t\t\t\t\t\tbox.top = top;\n\t\t\t\t\t\t\t\tbox.bottom = top + box.height;\n\n\t\t\t\t\t\t\t\t// Move to next point\n\t\t\t\t\t\t\t\ttop = box.bottom;\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tbox.left = left;\n\t\t\t\t\t\t\t\tbox.right = left + box.width;\n\t\t\t\t\t\t\t\tbox.top = totalTopBoxesHeight;\n\t\t\t\t\t\t\t\tbox.bottom = totalTopBoxesHeight + maxChartAreaHeight;\n\n\t\t\t\t\t\t\t\t// Move to next point\n\t\t\t\t\t\t\t\tleft = box.right;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\thelpers.each(leftBoxes.concat(topBoxes), placeBox);\n\n\t\t\t\t\t\t// Account for chart width and height\n\t\t\t\t\t\tleft += maxChartAreaWidth;\n\t\t\t\t\t\ttop += maxChartAreaHeight;\n\n\t\t\t\t\t\thelpers.each(rightBoxes, placeBox);\n\t\t\t\t\t\thelpers.each(bottomBoxes, placeBox);\n\n\t\t\t\t\t\t// Step 8\n\t\t\t\t\t\tchartInstance.chartArea = {\n\t\t\t\t\t\t\tleft: totalLeftBoxesWidth,\n\t\t\t\t\t\t\ttop: totalTopBoxesHeight,\n\t\t\t\t\t\t\tright: totalLeftBoxesWidth + maxChartAreaWidth,\n\t\t\t\t\t\t\tbottom: totalTopBoxesHeight + maxChartAreaHeight\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\t// Step 9\n\t\t\t\t\t\thelpers.each(chartAreaBoxes, function (box) {\n\t\t\t\t\t\t\tbox.left = chartInstance.chartArea.left;\n\t\t\t\t\t\t\tbox.top = chartInstance.chartArea.top;\n\t\t\t\t\t\t\tbox.right = chartInstance.chartArea.right;\n\t\t\t\t\t\t\tbox.bottom = chartInstance.chartArea.bottom;\n\n\t\t\t\t\t\t\tbox.update(maxChartAreaWidth, maxChartAreaHeight);\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t};\n\t\t}, {}], 30: [function (require, module, exports) {\n\t\t\t'use strict';\n\n\t\t\tmodule.exports = function (Chart) {\n\n\t\t\t\tvar helpers = Chart.helpers;\n\t\t\t\tvar noop = helpers.noop;\n\n\t\t\t\tChart.defaults.global.legend = {\n\n\t\t\t\t\tdisplay: true,\n\t\t\t\t\tposition: 'top',\n\t\t\t\t\tfullWidth: true, // marks that this box should take the full width of the canvas (pushing down other boxes)\n\t\t\t\t\treverse: false,\n\n\t\t\t\t\t// a callback that will handle\n\t\t\t\t\tonClick: function onClick(e, legendItem) {\n\t\t\t\t\t\tvar index = legendItem.datasetIndex;\n\t\t\t\t\t\tvar ci = this.chart;\n\t\t\t\t\t\tvar meta = ci.getDatasetMeta(index);\n\n\t\t\t\t\t\t// See controller.isDatasetVisible comment\n\t\t\t\t\t\tmeta.hidden = meta.hidden === null ? !ci.data.datasets[index].hidden : null;\n\n\t\t\t\t\t\t// We hid a dataset ... rerender the chart\n\t\t\t\t\t\tci.update();\n\t\t\t\t\t},\n\n\t\t\t\t\tonHover: null,\n\n\t\t\t\t\tlabels: {\n\t\t\t\t\t\tboxWidth: 40,\n\t\t\t\t\t\tpadding: 10,\n\t\t\t\t\t\t// Generates labels shown in the legend\n\t\t\t\t\t\t// Valid properties to return:\n\t\t\t\t\t\t// text : text to display\n\t\t\t\t\t\t// fillStyle : fill of coloured box\n\t\t\t\t\t\t// strokeStyle: stroke of coloured box\n\t\t\t\t\t\t// hidden : if this legend item refers to a hidden item\n\t\t\t\t\t\t// lineCap : cap style for line\n\t\t\t\t\t\t// lineDash\n\t\t\t\t\t\t// lineDashOffset :\n\t\t\t\t\t\t// lineJoin :\n\t\t\t\t\t\t// lineWidth :\n\t\t\t\t\t\tgenerateLabels: function generateLabels(chart) {\n\t\t\t\t\t\t\tvar data = chart.data;\n\t\t\t\t\t\t\treturn helpers.isArray(data.datasets) ? data.datasets.map(function (dataset, i) {\n\t\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\t\ttext: dataset.label,\n\t\t\t\t\t\t\t\t\tfillStyle: !helpers.isArray(dataset.backgroundColor) ? dataset.backgroundColor : dataset.backgroundColor[0],\n\t\t\t\t\t\t\t\t\thidden: !chart.isDatasetVisible(i),\n\t\t\t\t\t\t\t\t\tlineCap: dataset.borderCapStyle,\n\t\t\t\t\t\t\t\t\tlineDash: dataset.borderDash,\n\t\t\t\t\t\t\t\t\tlineDashOffset: dataset.borderDashOffset,\n\t\t\t\t\t\t\t\t\tlineJoin: dataset.borderJoinStyle,\n\t\t\t\t\t\t\t\t\tlineWidth: dataset.borderWidth,\n\t\t\t\t\t\t\t\t\tstrokeStyle: dataset.borderColor,\n\t\t\t\t\t\t\t\t\tpointStyle: dataset.pointStyle,\n\n\t\t\t\t\t\t\t\t\t// Below is extra data used for toggling the datasets\n\t\t\t\t\t\t\t\t\tdatasetIndex: i\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t}, this) : [];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\t/**\n     * Helper function to get the box width based on the usePointStyle option\n     * @param labelopts {Object} the label options on the legend\n     * @param fontSize {Number} the label font size\n     * @return {Number} width of the color box area\n     */\n\t\t\t\tfunction getBoxWidth(labelOpts, fontSize) {\n\t\t\t\t\treturn labelOpts.usePointStyle ? fontSize * Math.SQRT2 : labelOpts.boxWidth;\n\t\t\t\t}\n\n\t\t\t\tChart.Legend = Chart.Element.extend({\n\n\t\t\t\t\tinitialize: function initialize(config) {\n\t\t\t\t\t\thelpers.extend(this, config);\n\n\t\t\t\t\t\t// Contains hit boxes for each dataset (in dataset order)\n\t\t\t\t\t\tthis.legendHitBoxes = [];\n\n\t\t\t\t\t\t// Are we in doughnut mode which has a different data type\n\t\t\t\t\t\tthis.doughnutMode = false;\n\t\t\t\t\t},\n\n\t\t\t\t\t// These methods are ordered by lifecycle. Utilities then follow.\n\t\t\t\t\t// Any function defined here is inherited by all legend types.\n\t\t\t\t\t// Any function can be extended by the legend type\n\n\t\t\t\t\tbeforeUpdate: noop,\n\t\t\t\t\tupdate: function update(maxWidth, maxHeight, margins) {\n\t\t\t\t\t\tvar me = this;\n\n\t\t\t\t\t\t// Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)\n\t\t\t\t\t\tme.beforeUpdate();\n\n\t\t\t\t\t\t// Absorb the master measurements\n\t\t\t\t\t\tme.maxWidth = maxWidth;\n\t\t\t\t\t\tme.maxHeight = maxHeight;\n\t\t\t\t\t\tme.margins = margins;\n\n\t\t\t\t\t\t// Dimensions\n\t\t\t\t\t\tme.beforeSetDimensions();\n\t\t\t\t\t\tme.setDimensions();\n\t\t\t\t\t\tme.afterSetDimensions();\n\t\t\t\t\t\t// Labels\n\t\t\t\t\t\tme.beforeBuildLabels();\n\t\t\t\t\t\tme.buildLabels();\n\t\t\t\t\t\tme.afterBuildLabels();\n\n\t\t\t\t\t\t// Fit\n\t\t\t\t\t\tme.beforeFit();\n\t\t\t\t\t\tme.fit();\n\t\t\t\t\t\tme.afterFit();\n\t\t\t\t\t\t//\n\t\t\t\t\t\tme.afterUpdate();\n\n\t\t\t\t\t\treturn me.minSize;\n\t\t\t\t\t},\n\t\t\t\t\tafterUpdate: noop,\n\n\t\t\t\t\t//\n\n\t\t\t\t\tbeforeSetDimensions: noop,\n\t\t\t\t\tsetDimensions: function setDimensions() {\n\t\t\t\t\t\tvar me = this;\n\t\t\t\t\t\t// Set the unconstrained dimension before label rotation\n\t\t\t\t\t\tif (me.isHorizontal()) {\n\t\t\t\t\t\t\t// Reset position before calculating rotation\n\t\t\t\t\t\t\tme.width = me.maxWidth;\n\t\t\t\t\t\t\tme.left = 0;\n\t\t\t\t\t\t\tme.right = me.width;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tme.height = me.maxHeight;\n\n\t\t\t\t\t\t\t// Reset position before calculating rotation\n\t\t\t\t\t\t\tme.top = 0;\n\t\t\t\t\t\t\tme.bottom = me.height;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Reset padding\n\t\t\t\t\t\tme.paddingLeft = 0;\n\t\t\t\t\t\tme.paddingTop = 0;\n\t\t\t\t\t\tme.paddingRight = 0;\n\t\t\t\t\t\tme.paddingBottom = 0;\n\n\t\t\t\t\t\t// Reset minSize\n\t\t\t\t\t\tme.minSize = {\n\t\t\t\t\t\t\twidth: 0,\n\t\t\t\t\t\t\theight: 0\n\t\t\t\t\t\t};\n\t\t\t\t\t},\n\t\t\t\t\tafterSetDimensions: noop,\n\n\t\t\t\t\t//\n\n\t\t\t\t\tbeforeBuildLabels: noop,\n\t\t\t\t\tbuildLabels: function buildLabels() {\n\t\t\t\t\t\tvar me = this;\n\t\t\t\t\t\tvar labelOpts = me.options.labels;\n\t\t\t\t\t\tvar legendItems = labelOpts.generateLabels.call(me, me.chart);\n\n\t\t\t\t\t\tif (labelOpts.filter) {\n\t\t\t\t\t\t\tlegendItems = legendItems.filter(function (item) {\n\t\t\t\t\t\t\t\treturn labelOpts.filter(item, me.chart.data);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (me.options.reverse) {\n\t\t\t\t\t\t\tlegendItems.reverse();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tme.legendItems = legendItems;\n\t\t\t\t\t},\n\t\t\t\t\tafterBuildLabels: noop,\n\n\t\t\t\t\t//\n\n\t\t\t\t\tbeforeFit: noop,\n\t\t\t\t\tfit: function fit() {\n\t\t\t\t\t\tvar me = this;\n\t\t\t\t\t\tvar opts = me.options;\n\t\t\t\t\t\tvar labelOpts = opts.labels;\n\t\t\t\t\t\tvar display = opts.display;\n\n\t\t\t\t\t\tvar ctx = me.ctx;\n\n\t\t\t\t\t\tvar globalDefault = Chart.defaults.global,\n\t\t\t\t\t\t    itemOrDefault = helpers.getValueOrDefault,\n\t\t\t\t\t\t    fontSize = itemOrDefault(labelOpts.fontSize, globalDefault.defaultFontSize),\n\t\t\t\t\t\t    fontStyle = itemOrDefault(labelOpts.fontStyle, globalDefault.defaultFontStyle),\n\t\t\t\t\t\t    fontFamily = itemOrDefault(labelOpts.fontFamily, globalDefault.defaultFontFamily),\n\t\t\t\t\t\t    labelFont = helpers.fontString(fontSize, fontStyle, fontFamily);\n\n\t\t\t\t\t\t// Reset hit boxes\n\t\t\t\t\t\tvar hitboxes = me.legendHitBoxes = [];\n\n\t\t\t\t\t\tvar minSize = me.minSize;\n\t\t\t\t\t\tvar isHorizontal = me.isHorizontal();\n\n\t\t\t\t\t\tif (isHorizontal) {\n\t\t\t\t\t\t\tminSize.width = me.maxWidth; // fill all the width\n\t\t\t\t\t\t\tminSize.height = display ? 10 : 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tminSize.width = display ? 10 : 0;\n\t\t\t\t\t\t\tminSize.height = me.maxHeight; // fill all the height\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Increase sizes here\n\t\t\t\t\t\tif (display) {\n\t\t\t\t\t\t\tctx.font = labelFont;\n\n\t\t\t\t\t\t\tif (isHorizontal) {\n\t\t\t\t\t\t\t\t// Labels\n\n\t\t\t\t\t\t\t\t// Width of each line of legend boxes. Labels wrap onto multiple lines when there are too many to fit on one\n\t\t\t\t\t\t\t\tvar lineWidths = me.lineWidths = [0];\n\t\t\t\t\t\t\t\tvar totalHeight = me.legendItems.length ? fontSize + labelOpts.padding : 0;\n\n\t\t\t\t\t\t\t\tctx.textAlign = 'left';\n\t\t\t\t\t\t\t\tctx.textBaseline = 'top';\n\n\t\t\t\t\t\t\t\thelpers.each(me.legendItems, function (legendItem, i) {\n\t\t\t\t\t\t\t\t\tvar boxWidth = getBoxWidth(labelOpts, fontSize);\n\t\t\t\t\t\t\t\t\tvar width = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;\n\n\t\t\t\t\t\t\t\t\tif (lineWidths[lineWidths.length - 1] + width + labelOpts.padding >= me.width) {\n\t\t\t\t\t\t\t\t\t\ttotalHeight += fontSize + labelOpts.padding;\n\t\t\t\t\t\t\t\t\t\tlineWidths[lineWidths.length] = me.left;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// Store the hitbox width and height here. Final position will be updated in `draw`\n\t\t\t\t\t\t\t\t\thitboxes[i] = {\n\t\t\t\t\t\t\t\t\t\tleft: 0,\n\t\t\t\t\t\t\t\t\t\ttop: 0,\n\t\t\t\t\t\t\t\t\t\twidth: width,\n\t\t\t\t\t\t\t\t\t\theight: fontSize\n\t\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t\t\tlineWidths[lineWidths.length - 1] += width + labelOpts.padding;\n\t\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t\tminSize.height += totalHeight;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tvar vPadding = labelOpts.padding;\n\t\t\t\t\t\t\t\tvar columnWidths = me.columnWidths = [];\n\t\t\t\t\t\t\t\tvar totalWidth = labelOpts.padding;\n\t\t\t\t\t\t\t\tvar currentColWidth = 0;\n\t\t\t\t\t\t\t\tvar currentColHeight = 0;\n\t\t\t\t\t\t\t\tvar itemHeight = fontSize + vPadding;\n\n\t\t\t\t\t\t\t\thelpers.each(me.legendItems, function (legendItem, i) {\n\t\t\t\t\t\t\t\t\tvar boxWidth = getBoxWidth(labelOpts, fontSize);\n\t\t\t\t\t\t\t\t\tvar itemWidth = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;\n\n\t\t\t\t\t\t\t\t\t// If too tall, go to new column\n\t\t\t\t\t\t\t\t\tif (currentColHeight + itemHeight > minSize.height) {\n\t\t\t\t\t\t\t\t\t\ttotalWidth += currentColWidth + labelOpts.padding;\n\t\t\t\t\t\t\t\t\t\tcolumnWidths.push(currentColWidth); // previous column width\n\n\t\t\t\t\t\t\t\t\t\tcurrentColWidth = 0;\n\t\t\t\t\t\t\t\t\t\tcurrentColHeight = 0;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// Get max width\n\t\t\t\t\t\t\t\t\tcurrentColWidth = Math.max(currentColWidth, itemWidth);\n\t\t\t\t\t\t\t\t\tcurrentColHeight += itemHeight;\n\n\t\t\t\t\t\t\t\t\t// Store the hitbox width and height here. Final position will be updated in `draw`\n\t\t\t\t\t\t\t\t\thitboxes[i] = {\n\t\t\t\t\t\t\t\t\t\tleft: 0,\n\t\t\t\t\t\t\t\t\t\ttop: 0,\n\t\t\t\t\t\t\t\t\t\twidth: itemWidth,\n\t\t\t\t\t\t\t\t\t\theight: fontSize\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t\ttotalWidth += currentColWidth;\n\t\t\t\t\t\t\t\tcolumnWidths.push(currentColWidth);\n\t\t\t\t\t\t\t\tminSize.width += totalWidth;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tme.width = minSize.width;\n\t\t\t\t\t\tme.height = minSize.height;\n\t\t\t\t\t},\n\t\t\t\t\tafterFit: noop,\n\n\t\t\t\t\t// Shared Methods\n\t\t\t\t\tisHorizontal: function isHorizontal() {\n\t\t\t\t\t\treturn this.options.position === 'top' || this.options.position === 'bottom';\n\t\t\t\t\t},\n\n\t\t\t\t\t// Actually draw the legend on the canvas\n\t\t\t\t\tdraw: function draw() {\n\t\t\t\t\t\tvar me = this;\n\t\t\t\t\t\tvar opts = me.options;\n\t\t\t\t\t\tvar labelOpts = opts.labels;\n\t\t\t\t\t\tvar globalDefault = Chart.defaults.global,\n\t\t\t\t\t\t    lineDefault = globalDefault.elements.line,\n\t\t\t\t\t\t    legendWidth = me.width,\n\t\t\t\t\t\t    lineWidths = me.lineWidths;\n\n\t\t\t\t\t\tif (opts.display) {\n\t\t\t\t\t\t\tvar ctx = me.ctx,\n\t\t\t\t\t\t\t    cursor,\n\t\t\t\t\t\t\t    itemOrDefault = helpers.getValueOrDefault,\n\t\t\t\t\t\t\t    fontColor = itemOrDefault(labelOpts.fontColor, globalDefault.defaultFontColor),\n\t\t\t\t\t\t\t    fontSize = itemOrDefault(labelOpts.fontSize, globalDefault.defaultFontSize),\n\t\t\t\t\t\t\t    fontStyle = itemOrDefault(labelOpts.fontStyle, globalDefault.defaultFontStyle),\n\t\t\t\t\t\t\t    fontFamily = itemOrDefault(labelOpts.fontFamily, globalDefault.defaultFontFamily),\n\t\t\t\t\t\t\t    labelFont = helpers.fontString(fontSize, fontStyle, fontFamily);\n\n\t\t\t\t\t\t\t// Canvas setup\n\t\t\t\t\t\t\tctx.textAlign = 'left';\n\t\t\t\t\t\t\tctx.textBaseline = 'top';\n\t\t\t\t\t\t\tctx.lineWidth = 0.5;\n\t\t\t\t\t\t\tctx.strokeStyle = fontColor; // for strikethrough effect\n\t\t\t\t\t\t\tctx.fillStyle = fontColor; // render in correct colour\n\t\t\t\t\t\t\tctx.font = labelFont;\n\n\t\t\t\t\t\t\tvar boxWidth = getBoxWidth(labelOpts, fontSize),\n\t\t\t\t\t\t\t    hitboxes = me.legendHitBoxes;\n\n\t\t\t\t\t\t\t// current position\n\t\t\t\t\t\t\tvar drawLegendBox = function drawLegendBox(x, y, legendItem) {\n\t\t\t\t\t\t\t\tif (isNaN(boxWidth) || boxWidth <= 0) {\n\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// Set the ctx for the box\n\t\t\t\t\t\t\t\tctx.save();\n\n\t\t\t\t\t\t\t\tctx.fillStyle = itemOrDefault(legendItem.fillStyle, globalDefault.defaultColor);\n\t\t\t\t\t\t\t\tctx.lineCap = itemOrDefault(legendItem.lineCap, lineDefault.borderCapStyle);\n\t\t\t\t\t\t\t\tctx.lineDashOffset = itemOrDefault(legendItem.lineDashOffset, lineDefault.borderDashOffset);\n\t\t\t\t\t\t\t\tctx.lineJoin = itemOrDefault(legendItem.lineJoin, lineDefault.borderJoinStyle);\n\t\t\t\t\t\t\t\tctx.lineWidth = itemOrDefault(legendItem.lineWidth, lineDefault.borderWidth);\n\t\t\t\t\t\t\t\tctx.strokeStyle = itemOrDefault(legendItem.strokeStyle, globalDefault.defaultColor);\n\t\t\t\t\t\t\t\tvar isLineWidthZero = itemOrDefault(legendItem.lineWidth, lineDefault.borderWidth) === 0;\n\n\t\t\t\t\t\t\t\tif (ctx.setLineDash) {\n\t\t\t\t\t\t\t\t\t// IE 9 and 10 do not support line dash\n\t\t\t\t\t\t\t\t\tctx.setLineDash(itemOrDefault(legendItem.lineDash, lineDefault.borderDash));\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (opts.labels && opts.labels.usePointStyle) {\n\t\t\t\t\t\t\t\t\t// Recalculate x and y for drawPoint() because its expecting\n\t\t\t\t\t\t\t\t\t// x and y to be center of figure (instead of top left)\n\t\t\t\t\t\t\t\t\tvar radius = fontSize * Math.SQRT2 / 2;\n\t\t\t\t\t\t\t\t\tvar offSet = radius / Math.SQRT2;\n\t\t\t\t\t\t\t\t\tvar centerX = x + offSet;\n\t\t\t\t\t\t\t\t\tvar centerY = y + offSet;\n\n\t\t\t\t\t\t\t\t\t// Draw pointStyle as legend symbol\n\t\t\t\t\t\t\t\t\tChart.canvasHelpers.drawPoint(ctx, legendItem.pointStyle, radius, centerX, centerY);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t// Draw box as legend symbol\n\t\t\t\t\t\t\t\t\tif (!isLineWidthZero) {\n\t\t\t\t\t\t\t\t\t\tctx.strokeRect(x, y, boxWidth, fontSize);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tctx.fillRect(x, y, boxWidth, fontSize);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tctx.restore();\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tvar fillText = function fillText(x, y, legendItem, textWidth) {\n\t\t\t\t\t\t\t\tctx.fillText(legendItem.text, boxWidth + fontSize / 2 + x, y);\n\n\t\t\t\t\t\t\t\tif (legendItem.hidden) {\n\t\t\t\t\t\t\t\t\t// Strikethrough the text if hidden\n\t\t\t\t\t\t\t\t\tctx.beginPath();\n\t\t\t\t\t\t\t\t\tctx.lineWidth = 2;\n\t\t\t\t\t\t\t\t\tctx.moveTo(boxWidth + fontSize / 2 + x, y + fontSize / 2);\n\t\t\t\t\t\t\t\t\tctx.lineTo(boxWidth + fontSize / 2 + x + textWidth, y + fontSize / 2);\n\t\t\t\t\t\t\t\t\tctx.stroke();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t// Horizontal\n\t\t\t\t\t\t\tvar isHorizontal = me.isHorizontal();\n\t\t\t\t\t\t\tif (isHorizontal) {\n\t\t\t\t\t\t\t\tcursor = {\n\t\t\t\t\t\t\t\t\tx: me.left + (legendWidth - lineWidths[0]) / 2,\n\t\t\t\t\t\t\t\t\ty: me.top + labelOpts.padding,\n\t\t\t\t\t\t\t\t\tline: 0\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tcursor = {\n\t\t\t\t\t\t\t\t\tx: me.left + labelOpts.padding,\n\t\t\t\t\t\t\t\t\ty: me.top + labelOpts.padding,\n\t\t\t\t\t\t\t\t\tline: 0\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tvar itemHeight = fontSize + labelOpts.padding;\n\t\t\t\t\t\t\thelpers.each(me.legendItems, function (legendItem, i) {\n\t\t\t\t\t\t\t\tvar textWidth = ctx.measureText(legendItem.text).width,\n\t\t\t\t\t\t\t\t    width = boxWidth + fontSize / 2 + textWidth,\n\t\t\t\t\t\t\t\t    x = cursor.x,\n\t\t\t\t\t\t\t\t    y = cursor.y;\n\n\t\t\t\t\t\t\t\tif (isHorizontal) {\n\t\t\t\t\t\t\t\t\tif (x + width >= legendWidth) {\n\t\t\t\t\t\t\t\t\t\ty = cursor.y += itemHeight;\n\t\t\t\t\t\t\t\t\t\tcursor.line++;\n\t\t\t\t\t\t\t\t\t\tx = cursor.x = me.left + (legendWidth - lineWidths[cursor.line]) / 2;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else if (y + itemHeight > me.bottom) {\n\t\t\t\t\t\t\t\t\tx = cursor.x = x + me.columnWidths[cursor.line] + labelOpts.padding;\n\t\t\t\t\t\t\t\t\ty = cursor.y = me.top + labelOpts.padding;\n\t\t\t\t\t\t\t\t\tcursor.line++;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tdrawLegendBox(x, y, legendItem);\n\n\t\t\t\t\t\t\t\thitboxes[i].left = x;\n\t\t\t\t\t\t\t\thitboxes[i].top = y;\n\n\t\t\t\t\t\t\t\t// Fill the actual label\n\t\t\t\t\t\t\t\tfillText(x, y, legendItem, textWidth);\n\n\t\t\t\t\t\t\t\tif (isHorizontal) {\n\t\t\t\t\t\t\t\t\tcursor.x += width + labelOpts.padding;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tcursor.y += itemHeight;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\n\t\t\t\t\t/**\n      * Handle an event\n      * @private\n      * @param {IEvent} event - The event to handle\n      * @return {Boolean} true if a change occured\n      */\n\t\t\t\t\thandleEvent: function handleEvent(e) {\n\t\t\t\t\t\tvar me = this;\n\t\t\t\t\t\tvar opts = me.options;\n\t\t\t\t\t\tvar type = e.type === 'mouseup' ? 'click' : e.type;\n\t\t\t\t\t\tvar changed = false;\n\n\t\t\t\t\t\tif (type === 'mousemove') {\n\t\t\t\t\t\t\tif (!opts.onHover) {\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (type === 'click') {\n\t\t\t\t\t\t\tif (!opts.onClick) {\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Chart event already has relative position in it\n\t\t\t\t\t\tvar x = e.x,\n\t\t\t\t\t\t    y = e.y;\n\n\t\t\t\t\t\tif (x >= me.left && x <= me.right && y >= me.top && y <= me.bottom) {\n\t\t\t\t\t\t\t// See if we are touching one of the dataset boxes\n\t\t\t\t\t\t\tvar lh = me.legendHitBoxes;\n\t\t\t\t\t\t\tfor (var i = 0; i < lh.length; ++i) {\n\t\t\t\t\t\t\t\tvar hitBox = lh[i];\n\n\t\t\t\t\t\t\t\tif (x >= hitBox.left && x <= hitBox.left + hitBox.width && y >= hitBox.top && y <= hitBox.top + hitBox.height) {\n\t\t\t\t\t\t\t\t\t// Touching an element\n\t\t\t\t\t\t\t\t\tif (type === 'click') {\n\t\t\t\t\t\t\t\t\t\t// use e.native for backwards compatibility\n\t\t\t\t\t\t\t\t\t\topts.onClick.call(me, e.native, me.legendItems[i]);\n\t\t\t\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t} else if (type === 'mousemove') {\n\t\t\t\t\t\t\t\t\t\t// use e.native for backwards compatibility\n\t\t\t\t\t\t\t\t\t\topts.onHover.call(me, e.native, me.legendItems[i]);\n\t\t\t\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn changed;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tfunction createNewLegendAndAttach(chartInstance, legendOpts) {\n\t\t\t\t\tvar legend = new Chart.Legend({\n\t\t\t\t\t\tctx: chartInstance.chart.ctx,\n\t\t\t\t\t\toptions: legendOpts,\n\t\t\t\t\t\tchart: chartInstance\n\t\t\t\t\t});\n\t\t\t\t\tchartInstance.legend = legend;\n\t\t\t\t\tChart.layoutService.addBox(chartInstance, legend);\n\t\t\t\t}\n\n\t\t\t\t// Register the legend plugin\n\t\t\t\tChart.plugins.register({\n\t\t\t\t\tbeforeInit: function beforeInit(chartInstance) {\n\t\t\t\t\t\tvar legendOpts = chartInstance.options.legend;\n\n\t\t\t\t\t\tif (legendOpts) {\n\t\t\t\t\t\t\tcreateNewLegendAndAttach(chartInstance, legendOpts);\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tbeforeUpdate: function beforeUpdate(chartInstance) {\n\t\t\t\t\t\tvar legendOpts = chartInstance.options.legend;\n\n\t\t\t\t\t\tif (legendOpts) {\n\t\t\t\t\t\t\tlegendOpts = helpers.configMerge(Chart.defaults.global.legend, legendOpts);\n\n\t\t\t\t\t\t\tif (chartInstance.legend) {\n\t\t\t\t\t\t\t\tchartInstance.legend.options = legendOpts;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tcreateNewLegendAndAttach(chartInstance, legendOpts);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tChart.layoutService.removeBox(chartInstance, chartInstance.legend);\n\t\t\t\t\t\t\tdelete chartInstance.legend;\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tafterEvent: function afterEvent(chartInstance, e) {\n\t\t\t\t\t\tvar legend = chartInstance.legend;\n\t\t\t\t\t\tif (legend) {\n\t\t\t\t\t\t\tlegend.handleEvent(e);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t};\n\t\t}, {}], 31: [function (require, module, exports) {\n\t\t\t'use strict';\n\n\t\t\tmodule.exports = function (Chart) {\n\n\t\t\t\tvar helpers = Chart.helpers;\n\n\t\t\t\tChart.defaults.global.plugins = {};\n\n\t\t\t\t/**\n     * The plugin service singleton\n     * @namespace Chart.plugins\n     * @since 2.1.0\n     */\n\t\t\t\tChart.plugins = {\n\t\t\t\t\t/**\n      * Globally registered plugins.\n      * @private\n      */\n\t\t\t\t\t_plugins: [],\n\n\t\t\t\t\t/**\n      * This identifier is used to invalidate the descriptors cache attached to each chart\n      * when a global plugin is registered or unregistered. In this case, the cache ID is\n      * incremented and descriptors are regenerated during following API calls.\n      * @private\n      */\n\t\t\t\t\t_cacheId: 0,\n\n\t\t\t\t\t/**\n      * Registers the given plugin(s) if not already registered.\n      * @param {Array|Object} plugins plugin instance(s).\n      */\n\t\t\t\t\tregister: function register(plugins) {\n\t\t\t\t\t\tvar p = this._plugins;\n\t\t\t\t\t\t[].concat(plugins).forEach(function (plugin) {\n\t\t\t\t\t\t\tif (p.indexOf(plugin) === -1) {\n\t\t\t\t\t\t\t\tp.push(plugin);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tthis._cacheId++;\n\t\t\t\t\t},\n\n\t\t\t\t\t/**\n      * Unregisters the given plugin(s) only if registered.\n      * @param {Array|Object} plugins plugin instance(s).\n      */\n\t\t\t\t\tunregister: function unregister(plugins) {\n\t\t\t\t\t\tvar p = this._plugins;\n\t\t\t\t\t\t[].concat(plugins).forEach(function (plugin) {\n\t\t\t\t\t\t\tvar idx = p.indexOf(plugin);\n\t\t\t\t\t\t\tif (idx !== -1) {\n\t\t\t\t\t\t\t\tp.splice(idx, 1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tthis._cacheId++;\n\t\t\t\t\t},\n\n\t\t\t\t\t/**\n      * Remove all registered plugins.\n      * @since 2.1.5\n      */\n\t\t\t\t\tclear: function clear() {\n\t\t\t\t\t\tthis._plugins = [];\n\t\t\t\t\t\tthis._cacheId++;\n\t\t\t\t\t},\n\n\t\t\t\t\t/**\n      * Returns the number of registered plugins?\n      * @returns {Number}\n      * @since 2.1.5\n      */\n\t\t\t\t\tcount: function count() {\n\t\t\t\t\t\treturn this._plugins.length;\n\t\t\t\t\t},\n\n\t\t\t\t\t/**\n      * Returns all registered plugin instances.\n      * @returns {Array} array of plugin objects.\n      * @since 2.1.5\n      */\n\t\t\t\t\tgetAll: function getAll() {\n\t\t\t\t\t\treturn this._plugins;\n\t\t\t\t\t},\n\n\t\t\t\t\t/**\n      * Calls enabled plugins for `chart` on the specified hook and with the given args.\n      * This method immediately returns as soon as a plugin explicitly returns false. The\n      * returned value can be used, for instance, to interrupt the current action.\n      * @param {Object} chart - The chart instance for which plugins should be called.\n      * @param {String} hook - The name of the plugin method to call (e.g. 'beforeUpdate').\n      * @param {Array} [args] - Extra arguments to apply to the hook call.\n      * @returns {Boolean} false if any of the plugins return false, else returns true.\n      */\n\t\t\t\t\tnotify: function notify(chart, hook, args) {\n\t\t\t\t\t\tvar descriptors = this.descriptors(chart);\n\t\t\t\t\t\tvar ilen = descriptors.length;\n\t\t\t\t\t\tvar i, descriptor, plugin, params, method;\n\n\t\t\t\t\t\tfor (i = 0; i < ilen; ++i) {\n\t\t\t\t\t\t\tdescriptor = descriptors[i];\n\t\t\t\t\t\t\tplugin = descriptor.plugin;\n\t\t\t\t\t\t\tmethod = plugin[hook];\n\t\t\t\t\t\t\tif (typeof method === 'function') {\n\t\t\t\t\t\t\t\tparams = [chart].concat(args || []);\n\t\t\t\t\t\t\t\tparams.push(descriptor.options);\n\t\t\t\t\t\t\t\tif (method.apply(plugin, params) === false) {\n\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t},\n\n\t\t\t\t\t/**\n      * Returns descriptors of enabled plugins for the given chart.\n      * @returns {Array} [{ plugin, options }]\n      * @private\n      */\n\t\t\t\t\tdescriptors: function descriptors(chart) {\n\t\t\t\t\t\tvar cache = chart._plugins || (chart._plugins = {});\n\t\t\t\t\t\tif (cache.id === this._cacheId) {\n\t\t\t\t\t\t\treturn cache.descriptors;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar plugins = [];\n\t\t\t\t\t\tvar descriptors = [];\n\t\t\t\t\t\tvar config = chart && chart.config || {};\n\t\t\t\t\t\tvar defaults = Chart.defaults.global.plugins;\n\t\t\t\t\t\tvar options = config.options && config.options.plugins || {};\n\n\t\t\t\t\t\tthis._plugins.concat(config.plugins || []).forEach(function (plugin) {\n\t\t\t\t\t\t\tvar idx = plugins.indexOf(plugin);\n\t\t\t\t\t\t\tif (idx !== -1) {\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tvar id = plugin.id;\n\t\t\t\t\t\t\tvar opts = options[id];\n\t\t\t\t\t\t\tif (opts === false) {\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (opts === true) {\n\t\t\t\t\t\t\t\topts = helpers.clone(defaults[id]);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tplugins.push(plugin);\n\t\t\t\t\t\t\tdescriptors.push({\n\t\t\t\t\t\t\t\tplugin: plugin,\n\t\t\t\t\t\t\t\toptions: opts || {}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tcache.descriptors = descriptors;\n\t\t\t\t\t\tcache.id = this._cacheId;\n\t\t\t\t\t\treturn descriptors;\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\t/**\n     * Plugin extension hooks.\n     * @interface IPlugin\n     * @since 2.1.0\n     */\n\t\t\t\t/**\n     * @method IPlugin#beforeInit\n     * @desc Called before initializing `chart`.\n     * @param {Chart.Controller} chart - The chart instance.\n     * @param {Object} options - The plugin options.\n     */\n\t\t\t\t/**\n     * @method IPlugin#afterInit\n     * @desc Called after `chart` has been initialized and before the first update.\n     * @param {Chart.Controller} chart - The chart instance.\n     * @param {Object} options - The plugin options.\n     */\n\t\t\t\t/**\n     * @method IPlugin#beforeUpdate\n     * @desc Called before updating `chart`. If any plugin returns `false`, the update\n     * is cancelled (and thus subsequent render(s)) until another `update` is triggered.\n     * @param {Chart.Controller} chart - The chart instance.\n     * @param {Object} options - The plugin options.\n     * @returns {Boolean} `false` to cancel the chart update.\n     */\n\t\t\t\t/**\n     * @method IPlugin#afterUpdate\n     * @desc Called after `chart` has been updated and before rendering. Note that this\n     * hook will not be called if the chart update has been previously cancelled.\n     * @param {Chart.Controller} chart - The chart instance.\n     * @param {Object} options - The plugin options.\n     */\n\t\t\t\t/**\n     * @method IPlugin#beforeDatasetsUpdate\n    \t * @desc Called before updating the `chart` datasets. If any plugin returns `false`,\n     * the datasets update is cancelled until another `update` is triggered.\n     * @param {Chart.Controller} chart - The chart instance.\n     * @param {Object} options - The plugin options.\n     * @returns {Boolean} false to cancel the datasets update.\n     * @since version 2.1.5\n     */\n\t\t\t\t/**\n     * @method IPlugin#afterDatasetsUpdate\n     * @desc Called after the `chart` datasets have been updated. Note that this hook\n     * will not be called if the datasets update has been previously cancelled.\n     * @param {Chart.Controller} chart - The chart instance.\n     * @param {Object} options - The plugin options.\n     * @since version 2.1.5\n     */\n\t\t\t\t/**\n     * @method IPlugin#beforeLayout\n     * @desc Called before laying out `chart`. If any plugin returns `false`,\n     * the layout update is cancelled until another `update` is triggered.\n     * @param {Chart.Controller} chart - The chart instance.\n     * @param {Object} options - The plugin options.\n     * @returns {Boolean} `false` to cancel the chart layout.\n     */\n\t\t\t\t/**\n     * @method IPlugin#afterLayout\n     * @desc Called after the `chart` has been layed out. Note that this hook will not\n     * be called if the layout update has been previously cancelled.\n     * @param {Chart.Controller} chart - The chart instance.\n     * @param {Object} options - The plugin options.\n     */\n\t\t\t\t/**\n     * @method IPlugin#beforeRender\n     * @desc Called before rendering `chart`. If any plugin returns `false`,\n     * the rendering is cancelled until another `render` is triggered.\n     * @param {Chart.Controller} chart - The chart instance.\n     * @param {Object} options - The plugin options.\n     * @returns {Boolean} `false` to cancel the chart rendering.\n     */\n\t\t\t\t/**\n     * @method IPlugin#afterRender\n     * @desc Called after the `chart` has been fully rendered (and animation completed). Note\n     * that this hook will not be called if the rendering has been previously cancelled.\n     * @param {Chart.Controller} chart - The chart instance.\n     * @param {Object} options - The plugin options.\n     */\n\t\t\t\t/**\n     * @method IPlugin#beforeDraw\n     * @desc Called before drawing `chart` at every animation frame specified by the given\n     * easing value. If any plugin returns `false`, the frame drawing is cancelled until\n     * another `render` is triggered.\n     * @param {Chart.Controller} chart - The chart instance.\n     * @param {Number} easingValue - The current animation value, between 0.0 and 1.0.\n     * @param {Object} options - The plugin options.\n     * @returns {Boolean} `false` to cancel the chart drawing.\n     */\n\t\t\t\t/**\n     * @method IPlugin#afterDraw\n     * @desc Called after the `chart` has been drawn for the specific easing value. Note\n     * that this hook will not be called if the drawing has been previously cancelled.\n     * @param {Chart.Controller} chart - The chart instance.\n     * @param {Number} easingValue - The current animation value, between 0.0 and 1.0.\n     * @param {Object} options - The plugin options.\n     */\n\t\t\t\t/**\n     * @method IPlugin#beforeDatasetsDraw\n    \t * @desc Called before drawing the `chart` datasets. If any plugin returns `false`,\n     * the datasets drawing is cancelled until another `render` is triggered.\n     * @param {Chart.Controller} chart - The chart instance.\n     * @param {Number} easingValue - The current animation value, between 0.0 and 1.0.\n     * @param {Object} options - The plugin options.\n     * @returns {Boolean} `false` to cancel the chart datasets drawing.\n     */\n\t\t\t\t/**\n     * @method IPlugin#afterDatasetsDraw\n     * @desc Called after the `chart` datasets have been drawn. Note that this hook\n     * will not be called if the datasets drawing has been previously cancelled.\n     * @param {Chart.Controller} chart - The chart instance.\n     * @param {Number} easingValue - The current animation value, between 0.0 and 1.0.\n     * @param {Object} options - The plugin options.\n     */\n\t\t\t\t/**\n     * @method IPlugin#beforeEvent\n    \t * @desc Called before processing the specified `event`. If any plugin returns `false`,\n     * the event will be discarded.\n     * @param {Chart.Controller} chart - The chart instance.\n     * @param {IEvent} event - The event object.\n     * @param {Object} options - The plugin options.\n     */\n\t\t\t\t/**\n     * @method IPlugin#afterEvent\n     * @desc Called after the `event` has been consumed. Note that this hook\n     * will not be called if the `event` has been previously discarded.\n     * @param {Chart.Controller} chart - The chart instance.\n     * @param {IEvent} event - The event object.\n     * @param {Object} options - The plugin options.\n     */\n\t\t\t\t/**\n     * @method IPlugin#resize\n     * @desc Called after the chart as been resized.\n     * @param {Chart.Controller} chart - The chart instance.\n     * @param {Number} size - The new canvas display size (eq. canvas.style width & height).\n     * @param {Object} options - The plugin options.\n     */\n\t\t\t\t/**\n     * @method IPlugin#destroy\n     * @desc Called after the chart as been destroyed.\n     * @param {Chart.Controller} chart - The chart instance.\n     * @param {Object} options - The plugin options.\n     */\n\n\t\t\t\t/**\n     * Provided for backward compatibility, use Chart.plugins instead\n     * @namespace Chart.pluginService\n     * @deprecated since version 2.1.5\n     * @todo remove at version 3\n     * @private\n     */\n\t\t\t\tChart.pluginService = Chart.plugins;\n\n\t\t\t\t/**\n     * Provided for backward compatibility, inheriting from Chart.PlugingBase has no\n     * effect, instead simply create/register plugins via plain JavaScript objects.\n     * @interface Chart.PluginBase\n     * @deprecated since version 2.5.0\n     * @todo remove at version 3\n     * @private\n     */\n\t\t\t\tChart.PluginBase = helpers.inherits({});\n\t\t\t};\n\t\t}, {}], 32: [function (require, module, exports) {\n\t\t\t'use strict';\n\n\t\t\tmodule.exports = function (Chart) {\n\n\t\t\t\tvar helpers = Chart.helpers;\n\n\t\t\t\tChart.defaults.scale = {\n\t\t\t\t\tdisplay: true,\n\t\t\t\t\tposition: 'left',\n\n\t\t\t\t\t// grid line settings\n\t\t\t\t\tgridLines: {\n\t\t\t\t\t\tdisplay: true,\n\t\t\t\t\t\tcolor: 'rgba(0, 0, 0, 0.1)',\n\t\t\t\t\t\tlineWidth: 1,\n\t\t\t\t\t\tdrawBorder: true,\n\t\t\t\t\t\tdrawOnChartArea: true,\n\t\t\t\t\t\tdrawTicks: true,\n\t\t\t\t\t\ttickMarkLength: 10,\n\t\t\t\t\t\tzeroLineWidth: 1,\n\t\t\t\t\t\tzeroLineColor: 'rgba(0,0,0,0.25)',\n\t\t\t\t\t\toffsetGridLines: false,\n\t\t\t\t\t\tborderDash: [],\n\t\t\t\t\t\tborderDashOffset: 0.0\n\t\t\t\t\t},\n\n\t\t\t\t\t// scale label\n\t\t\t\t\tscaleLabel: {\n\t\t\t\t\t\t// actual label\n\t\t\t\t\t\tlabelString: '',\n\n\t\t\t\t\t\t// display property\n\t\t\t\t\t\tdisplay: false\n\t\t\t\t\t},\n\n\t\t\t\t\t// label settings\n\t\t\t\t\tticks: {\n\t\t\t\t\t\tbeginAtZero: false,\n\t\t\t\t\t\tminRotation: 0,\n\t\t\t\t\t\tmaxRotation: 50,\n\t\t\t\t\t\tmirror: false,\n\t\t\t\t\t\tpadding: 0,\n\t\t\t\t\t\treverse: false,\n\t\t\t\t\t\tdisplay: true,\n\t\t\t\t\t\tautoSkip: true,\n\t\t\t\t\t\tautoSkipPadding: 0,\n\t\t\t\t\t\tlabelOffset: 0,\n\t\t\t\t\t\t// We pass through arrays to be rendered as multiline labels, we convert Others to strings here.\n\t\t\t\t\t\tcallback: Chart.Ticks.formatters.values\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\tfunction computeTextSize(context, tick, font) {\n\t\t\t\t\treturn helpers.isArray(tick) ? helpers.longestText(context, font, tick) : context.measureText(tick).width;\n\t\t\t\t}\n\n\t\t\t\tfunction parseFontOptions(options) {\n\t\t\t\t\tvar getValueOrDefault = helpers.getValueOrDefault;\n\t\t\t\t\tvar globalDefaults = Chart.defaults.global;\n\t\t\t\t\tvar size = getValueOrDefault(options.fontSize, globalDefaults.defaultFontSize);\n\t\t\t\t\tvar style = getValueOrDefault(options.fontStyle, globalDefaults.defaultFontStyle);\n\t\t\t\t\tvar family = getValueOrDefault(options.fontFamily, globalDefaults.defaultFontFamily);\n\n\t\t\t\t\treturn {\n\t\t\t\t\t\tsize: size,\n\t\t\t\t\t\tstyle: style,\n\t\t\t\t\t\tfamily: family,\n\t\t\t\t\t\tfont: helpers.fontString(size, style, family)\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\tChart.Scale = Chart.Element.extend({\n\t\t\t\t\t/**\n      * Get the padding needed for the scale\n      * @method getPadding\n      * @private\n      * @returns {Padding} the necessary padding\n      */\n\t\t\t\t\tgetPadding: function getPadding() {\n\t\t\t\t\t\tvar me = this;\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tleft: me.paddingLeft || 0,\n\t\t\t\t\t\t\ttop: me.paddingTop || 0,\n\t\t\t\t\t\t\tright: me.paddingRight || 0,\n\t\t\t\t\t\t\tbottom: me.paddingBottom || 0\n\t\t\t\t\t\t};\n\t\t\t\t\t},\n\n\t\t\t\t\t// These methods are ordered by lifecyle. Utilities then follow.\n\t\t\t\t\t// Any function defined here is inherited by all scale types.\n\t\t\t\t\t// Any function can be extended by the scale type\n\n\t\t\t\t\tbeforeUpdate: function beforeUpdate() {\n\t\t\t\t\t\thelpers.callCallback(this.options.beforeUpdate, [this]);\n\t\t\t\t\t},\n\t\t\t\t\tupdate: function update(maxWidth, maxHeight, margins) {\n\t\t\t\t\t\tvar me = this;\n\n\t\t\t\t\t\t// Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)\n\t\t\t\t\t\tme.beforeUpdate();\n\n\t\t\t\t\t\t// Absorb the master measurements\n\t\t\t\t\t\tme.maxWidth = maxWidth;\n\t\t\t\t\t\tme.maxHeight = maxHeight;\n\t\t\t\t\t\tme.margins = helpers.extend({\n\t\t\t\t\t\t\tleft: 0,\n\t\t\t\t\t\t\tright: 0,\n\t\t\t\t\t\t\ttop: 0,\n\t\t\t\t\t\t\tbottom: 0\n\t\t\t\t\t\t}, margins);\n\t\t\t\t\t\tme.longestTextCache = me.longestTextCache || {};\n\n\t\t\t\t\t\t// Dimensions\n\t\t\t\t\t\tme.beforeSetDimensions();\n\t\t\t\t\t\tme.setDimensions();\n\t\t\t\t\t\tme.afterSetDimensions();\n\n\t\t\t\t\t\t// Data min/max\n\t\t\t\t\t\tme.beforeDataLimits();\n\t\t\t\t\t\tme.determineDataLimits();\n\t\t\t\t\t\tme.afterDataLimits();\n\n\t\t\t\t\t\t// Ticks\n\t\t\t\t\t\tme.beforeBuildTicks();\n\t\t\t\t\t\tme.buildTicks();\n\t\t\t\t\t\tme.afterBuildTicks();\n\n\t\t\t\t\t\tme.beforeTickToLabelConversion();\n\t\t\t\t\t\tme.convertTicksToLabels();\n\t\t\t\t\t\tme.afterTickToLabelConversion();\n\n\t\t\t\t\t\t// Tick Rotation\n\t\t\t\t\t\tme.beforeCalculateTickRotation();\n\t\t\t\t\t\tme.calculateTickRotation();\n\t\t\t\t\t\tme.afterCalculateTickRotation();\n\t\t\t\t\t\t// Fit\n\t\t\t\t\t\tme.beforeFit();\n\t\t\t\t\t\tme.fit();\n\t\t\t\t\t\tme.afterFit();\n\t\t\t\t\t\t//\n\t\t\t\t\t\tme.afterUpdate();\n\n\t\t\t\t\t\treturn me.minSize;\n\t\t\t\t\t},\n\t\t\t\t\tafterUpdate: function afterUpdate() {\n\t\t\t\t\t\thelpers.callCallback(this.options.afterUpdate, [this]);\n\t\t\t\t\t},\n\n\t\t\t\t\t//\n\n\t\t\t\t\tbeforeSetDimensions: function beforeSetDimensions() {\n\t\t\t\t\t\thelpers.callCallback(this.options.beforeSetDimensions, [this]);\n\t\t\t\t\t},\n\t\t\t\t\tsetDimensions: function setDimensions() {\n\t\t\t\t\t\tvar me = this;\n\t\t\t\t\t\t// Set the unconstrained dimension before label rotation\n\t\t\t\t\t\tif (me.isHorizontal()) {\n\t\t\t\t\t\t\t// Reset position before calculating rotation\n\t\t\t\t\t\t\tme.width = me.maxWidth;\n\t\t\t\t\t\t\tme.left = 0;\n\t\t\t\t\t\t\tme.right = me.width;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tme.height = me.maxHeight;\n\n\t\t\t\t\t\t\t// Reset position before calculating rotation\n\t\t\t\t\t\t\tme.top = 0;\n\t\t\t\t\t\t\tme.bottom = me.height;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Reset padding\n\t\t\t\t\t\tme.paddingLeft = 0;\n\t\t\t\t\t\tme.paddingTop = 0;\n\t\t\t\t\t\tme.paddingRight = 0;\n\t\t\t\t\t\tme.paddingBottom = 0;\n\t\t\t\t\t},\n\t\t\t\t\tafterSetDimensions: function afterSetDimensions() {\n\t\t\t\t\t\thelpers.callCallback(this.options.afterSetDimensions, [this]);\n\t\t\t\t\t},\n\n\t\t\t\t\t// Data limits\n\t\t\t\t\tbeforeDataLimits: function beforeDataLimits() {\n\t\t\t\t\t\thelpers.callCallback(this.options.beforeDataLimits, [this]);\n\t\t\t\t\t},\n\t\t\t\t\tdetermineDataLimits: helpers.noop,\n\t\t\t\t\tafterDataLimits: function afterDataLimits() {\n\t\t\t\t\t\thelpers.callCallback(this.options.afterDataLimits, [this]);\n\t\t\t\t\t},\n\n\t\t\t\t\t//\n\t\t\t\t\tbeforeBuildTicks: function beforeBuildTicks() {\n\t\t\t\t\t\thelpers.callCallback(this.options.beforeBuildTicks, [this]);\n\t\t\t\t\t},\n\t\t\t\t\tbuildTicks: helpers.noop,\n\t\t\t\t\tafterBuildTicks: function afterBuildTicks() {\n\t\t\t\t\t\thelpers.callCallback(this.options.afterBuildTicks, [this]);\n\t\t\t\t\t},\n\n\t\t\t\t\tbeforeTickToLabelConversion: function beforeTickToLabelConversion() {\n\t\t\t\t\t\thelpers.callCallback(this.options.beforeTickToLabelConversion, [this]);\n\t\t\t\t\t},\n\t\t\t\t\tconvertTicksToLabels: function convertTicksToLabels() {\n\t\t\t\t\t\tvar me = this;\n\t\t\t\t\t\t// Convert ticks to strings\n\t\t\t\t\t\tvar tickOpts = me.options.ticks;\n\t\t\t\t\t\tme.ticks = me.ticks.map(tickOpts.userCallback || tickOpts.callback);\n\t\t\t\t\t},\n\t\t\t\t\tafterTickToLabelConversion: function afterTickToLabelConversion() {\n\t\t\t\t\t\thelpers.callCallback(this.options.afterTickToLabelConversion, [this]);\n\t\t\t\t\t},\n\n\t\t\t\t\t//\n\n\t\t\t\t\tbeforeCalculateTickRotation: function beforeCalculateTickRotation() {\n\t\t\t\t\t\thelpers.callCallback(this.options.beforeCalculateTickRotation, [this]);\n\t\t\t\t\t},\n\t\t\t\t\tcalculateTickRotation: function calculateTickRotation() {\n\t\t\t\t\t\tvar me = this;\n\t\t\t\t\t\tvar context = me.ctx;\n\t\t\t\t\t\tvar tickOpts = me.options.ticks;\n\n\t\t\t\t\t\t// Get the width of each grid by calculating the difference\n\t\t\t\t\t\t// between x offsets between 0 and 1.\n\t\t\t\t\t\tvar tickFont = parseFontOptions(tickOpts);\n\t\t\t\t\t\tcontext.font = tickFont.font;\n\n\t\t\t\t\t\tvar labelRotation = tickOpts.minRotation || 0;\n\n\t\t\t\t\t\tif (me.options.display && me.isHorizontal()) {\n\t\t\t\t\t\t\tvar originalLabelWidth = helpers.longestText(context, tickFont.font, me.ticks, me.longestTextCache);\n\t\t\t\t\t\t\tvar labelWidth = originalLabelWidth;\n\t\t\t\t\t\t\tvar cosRotation;\n\t\t\t\t\t\t\tvar sinRotation;\n\n\t\t\t\t\t\t\t// Allow 3 pixels x2 padding either side for label readability\n\t\t\t\t\t\t\tvar tickWidth = me.getPixelForTick(1) - me.getPixelForTick(0) - 6;\n\n\t\t\t\t\t\t\t// Max label rotation can be set or default to 90 - also act as a loop counter\n\t\t\t\t\t\t\twhile (labelWidth > tickWidth && labelRotation < tickOpts.maxRotation) {\n\t\t\t\t\t\t\t\tvar angleRadians = helpers.toRadians(labelRotation);\n\t\t\t\t\t\t\t\tcosRotation = Math.cos(angleRadians);\n\t\t\t\t\t\t\t\tsinRotation = Math.sin(angleRadians);\n\n\t\t\t\t\t\t\t\tif (sinRotation * originalLabelWidth > me.maxHeight) {\n\t\t\t\t\t\t\t\t\t// go back one step\n\t\t\t\t\t\t\t\t\tlabelRotation--;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tlabelRotation++;\n\t\t\t\t\t\t\t\tlabelWidth = cosRotation * originalLabelWidth;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tme.labelRotation = labelRotation;\n\t\t\t\t\t},\n\t\t\t\t\tafterCalculateTickRotation: function afterCalculateTickRotation() {\n\t\t\t\t\t\thelpers.callCallback(this.options.afterCalculateTickRotation, [this]);\n\t\t\t\t\t},\n\n\t\t\t\t\t//\n\n\t\t\t\t\tbeforeFit: function beforeFit() {\n\t\t\t\t\t\thelpers.callCallback(this.options.beforeFit, [this]);\n\t\t\t\t\t},\n\t\t\t\t\tfit: function fit() {\n\t\t\t\t\t\tvar me = this;\n\t\t\t\t\t\t// Reset\n\t\t\t\t\t\tvar minSize = me.minSize = {\n\t\t\t\t\t\t\twidth: 0,\n\t\t\t\t\t\t\theight: 0\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tvar opts = me.options;\n\t\t\t\t\t\tvar tickOpts = opts.ticks;\n\t\t\t\t\t\tvar scaleLabelOpts = opts.scaleLabel;\n\t\t\t\t\t\tvar gridLineOpts = opts.gridLines;\n\t\t\t\t\t\tvar display = opts.display;\n\t\t\t\t\t\tvar isHorizontal = me.isHorizontal();\n\n\t\t\t\t\t\tvar tickFont = parseFontOptions(tickOpts);\n\t\t\t\t\t\tvar scaleLabelFontSize = parseFontOptions(scaleLabelOpts).size * 1.5;\n\t\t\t\t\t\tvar tickMarkLength = opts.gridLines.tickMarkLength;\n\n\t\t\t\t\t\t// Width\n\t\t\t\t\t\tif (isHorizontal) {\n\t\t\t\t\t\t\t// subtract the margins to line up with the chartArea if we are a full width scale\n\t\t\t\t\t\t\tminSize.width = me.isFullWidth() ? me.maxWidth - me.margins.left - me.margins.right : me.maxWidth;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tminSize.width = display && gridLineOpts.drawTicks ? tickMarkLength : 0;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// height\n\t\t\t\t\t\tif (isHorizontal) {\n\t\t\t\t\t\t\tminSize.height = display && gridLineOpts.drawTicks ? tickMarkLength : 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tminSize.height = me.maxHeight; // fill all the height\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Are we showing a title for the scale?\n\t\t\t\t\t\tif (scaleLabelOpts.display && display) {\n\t\t\t\t\t\t\tif (isHorizontal) {\n\t\t\t\t\t\t\t\tminSize.height += scaleLabelFontSize;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tminSize.width += scaleLabelFontSize;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Don't bother fitting the ticks if we are not showing them\n\t\t\t\t\t\tif (tickOpts.display && display) {\n\t\t\t\t\t\t\tvar largestTextWidth = helpers.longestText(me.ctx, tickFont.font, me.ticks, me.longestTextCache);\n\t\t\t\t\t\t\tvar tallestLabelHeightInLines = helpers.numberOfLabelLines(me.ticks);\n\t\t\t\t\t\t\tvar lineSpace = tickFont.size * 0.5;\n\n\t\t\t\t\t\t\tif (isHorizontal) {\n\t\t\t\t\t\t\t\t// A horizontal axis is more constrained by the height.\n\t\t\t\t\t\t\t\tme.longestLabelWidth = largestTextWidth;\n\n\t\t\t\t\t\t\t\tvar angleRadians = helpers.toRadians(me.labelRotation);\n\t\t\t\t\t\t\t\tvar cosRotation = Math.cos(angleRadians);\n\t\t\t\t\t\t\t\tvar sinRotation = Math.sin(angleRadians);\n\n\t\t\t\t\t\t\t\t// TODO - improve this calculation\n\t\t\t\t\t\t\t\tvar labelHeight = sinRotation * largestTextWidth + tickFont.size * tallestLabelHeightInLines + lineSpace * tallestLabelHeightInLines;\n\n\t\t\t\t\t\t\t\tminSize.height = Math.min(me.maxHeight, minSize.height + labelHeight);\n\t\t\t\t\t\t\t\tme.ctx.font = tickFont.font;\n\n\t\t\t\t\t\t\t\tvar firstTick = me.ticks[0];\n\t\t\t\t\t\t\t\tvar firstLabelWidth = computeTextSize(me.ctx, firstTick, tickFont.font);\n\n\t\t\t\t\t\t\t\tvar lastTick = me.ticks[me.ticks.length - 1];\n\t\t\t\t\t\t\t\tvar lastLabelWidth = computeTextSize(me.ctx, lastTick, tickFont.font);\n\n\t\t\t\t\t\t\t\t// Ensure that our ticks are always inside the canvas. When rotated, ticks are right aligned which means that the right padding is dominated\n\t\t\t\t\t\t\t\t// by the font height\n\t\t\t\t\t\t\t\tif (me.labelRotation !== 0) {\n\t\t\t\t\t\t\t\t\tme.paddingLeft = opts.position === 'bottom' ? cosRotation * firstLabelWidth + 3 : cosRotation * lineSpace + 3; // add 3 px to move away from canvas edges\n\t\t\t\t\t\t\t\t\tme.paddingRight = opts.position === 'bottom' ? cosRotation * lineSpace + 3 : cosRotation * lastLabelWidth + 3;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tme.paddingLeft = firstLabelWidth / 2 + 3; // add 3 px to move away from canvas edges\n\t\t\t\t\t\t\t\t\tme.paddingRight = lastLabelWidth / 2 + 3;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// A vertical axis is more constrained by the width. Labels are the dominant factor here, so get that length first\n\t\t\t\t\t\t\t\t// Account for padding\n\n\t\t\t\t\t\t\t\tif (tickOpts.mirror) {\n\t\t\t\t\t\t\t\t\tlargestTextWidth = 0;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tlargestTextWidth += me.options.ticks.padding;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tminSize.width += largestTextWidth;\n\t\t\t\t\t\t\t\tme.paddingTop = tickFont.size / 2;\n\t\t\t\t\t\t\t\tme.paddingBottom = tickFont.size / 2;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tme.handleMargins();\n\n\t\t\t\t\t\tme.width = minSize.width;\n\t\t\t\t\t\tme.height = minSize.height;\n\t\t\t\t\t},\n\n\t\t\t\t\t/**\n      * Handle margins and padding interactions\n      * @private\n      */\n\t\t\t\t\thandleMargins: function handleMargins() {\n\t\t\t\t\t\tvar me = this;\n\t\t\t\t\t\tif (me.margins) {\n\t\t\t\t\t\t\tme.paddingLeft = Math.max(me.paddingLeft - me.margins.left, 0);\n\t\t\t\t\t\t\tme.paddingTop = Math.max(me.paddingTop - me.margins.top, 0);\n\t\t\t\t\t\t\tme.paddingRight = Math.max(me.paddingRight - me.margins.right, 0);\n\t\t\t\t\t\t\tme.paddingBottom = Math.max(me.paddingBottom - me.margins.bottom, 0);\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\n\t\t\t\t\tafterFit: function afterFit() {\n\t\t\t\t\t\thelpers.callCallback(this.options.afterFit, [this]);\n\t\t\t\t\t},\n\n\t\t\t\t\t// Shared Methods\n\t\t\t\t\tisHorizontal: function isHorizontal() {\n\t\t\t\t\t\treturn this.options.position === 'top' || this.options.position === 'bottom';\n\t\t\t\t\t},\n\t\t\t\t\tisFullWidth: function isFullWidth() {\n\t\t\t\t\t\treturn this.options.fullWidth;\n\t\t\t\t\t},\n\n\t\t\t\t\t// Get the correct value. NaN bad inputs, If the value type is object get the x or y based on whether we are horizontal or not\n\t\t\t\t\tgetRightValue: function getRightValue(rawValue) {\n\t\t\t\t\t\t// Null and undefined values first\n\t\t\t\t\t\tif (rawValue === null || typeof rawValue === 'undefined') {\n\t\t\t\t\t\t\treturn NaN;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// isNaN(object) returns true, so make sure NaN is checking for a number; Discard Infinite values\n\t\t\t\t\t\tif (typeof rawValue === 'number' && !isFinite(rawValue)) {\n\t\t\t\t\t\t\treturn NaN;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// If it is in fact an object, dive in one more level\n\t\t\t\t\t\tif ((typeof rawValue === \"undefined\" ? \"undefined\" : _typeof(rawValue)) === 'object') {\n\t\t\t\t\t\t\tif (rawValue instanceof Date || rawValue.isValid) {\n\t\t\t\t\t\t\t\treturn rawValue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn this.getRightValue(this.isHorizontal() ? rawValue.x : rawValue.y);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Value is good, return it\n\t\t\t\t\t\treturn rawValue;\n\t\t\t\t\t},\n\n\t\t\t\t\t// Used to get the value to display in the tooltip for the data at the given index\n\t\t\t\t\t// function getLabelForIndex(index, datasetIndex)\n\t\t\t\t\tgetLabelForIndex: helpers.noop,\n\n\t\t\t\t\t// Used to get data value locations.  Value can either be an index or a numerical value\n\t\t\t\t\tgetPixelForValue: helpers.noop,\n\n\t\t\t\t\t// Used to get the data value from a given pixel. This is the inverse of getPixelForValue\n\t\t\t\t\tgetValueForPixel: helpers.noop,\n\n\t\t\t\t\t// Used for tick location, should\n\t\t\t\t\tgetPixelForTick: function getPixelForTick(index, includeOffset) {\n\t\t\t\t\t\tvar me = this;\n\t\t\t\t\t\tif (me.isHorizontal()) {\n\t\t\t\t\t\t\tvar innerWidth = me.width - (me.paddingLeft + me.paddingRight);\n\t\t\t\t\t\t\tvar tickWidth = innerWidth / Math.max(me.ticks.length - (me.options.gridLines.offsetGridLines ? 0 : 1), 1);\n\t\t\t\t\t\t\tvar pixel = tickWidth * index + me.paddingLeft;\n\n\t\t\t\t\t\t\tif (includeOffset) {\n\t\t\t\t\t\t\t\tpixel += tickWidth / 2;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tvar finalVal = me.left + Math.round(pixel);\n\t\t\t\t\t\t\tfinalVal += me.isFullWidth() ? me.margins.left : 0;\n\t\t\t\t\t\t\treturn finalVal;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvar innerHeight = me.height - (me.paddingTop + me.paddingBottom);\n\t\t\t\t\t\treturn me.top + index * (innerHeight / (me.ticks.length - 1));\n\t\t\t\t\t},\n\n\t\t\t\t\t// Utility for getting the pixel location of a percentage of scale\n\t\t\t\t\tgetPixelForDecimal: function getPixelForDecimal(decimal /* , includeOffset*/) {\n\t\t\t\t\t\tvar me = this;\n\t\t\t\t\t\tif (me.isHorizontal()) {\n\t\t\t\t\t\t\tvar innerWidth = me.width - (me.paddingLeft + me.paddingRight);\n\t\t\t\t\t\t\tvar valueOffset = innerWidth * decimal + me.paddingLeft;\n\n\t\t\t\t\t\t\tvar finalVal = me.left + Math.round(valueOffset);\n\t\t\t\t\t\t\tfinalVal += me.isFullWidth() ? me.margins.left : 0;\n\t\t\t\t\t\t\treturn finalVal;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn me.top + decimal * me.height;\n\t\t\t\t\t},\n\n\t\t\t\t\tgetBasePixel: function getBasePixel() {\n\t\t\t\t\t\treturn this.getPixelForValue(this.getBaseValue());\n\t\t\t\t\t},\n\n\t\t\t\t\tgetBaseValue: function getBaseValue() {\n\t\t\t\t\t\tvar me = this;\n\t\t\t\t\t\tvar min = me.min;\n\t\t\t\t\t\tvar max = me.max;\n\n\t\t\t\t\t\treturn me.beginAtZero ? 0 : min < 0 && max < 0 ? max : min > 0 && max > 0 ? min : 0;\n\t\t\t\t\t},\n\n\t\t\t\t\t// Actually draw the scale on the canvas\n\t\t\t\t\t// @param {rectangle} chartArea : the area of the chart to draw full grid lines on\n\t\t\t\t\tdraw: function draw(chartArea) {\n\t\t\t\t\t\tvar me = this;\n\t\t\t\t\t\tvar options = me.options;\n\t\t\t\t\t\tif (!options.display) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar context = me.ctx;\n\t\t\t\t\t\tvar globalDefaults = Chart.defaults.global;\n\t\t\t\t\t\tvar optionTicks = options.ticks;\n\t\t\t\t\t\tvar gridLines = options.gridLines;\n\t\t\t\t\t\tvar scaleLabel = options.scaleLabel;\n\n\t\t\t\t\t\tvar isRotated = me.labelRotation !== 0;\n\t\t\t\t\t\tvar skipRatio;\n\t\t\t\t\t\tvar useAutoskipper = optionTicks.autoSkip;\n\t\t\t\t\t\tvar isHorizontal = me.isHorizontal();\n\n\t\t\t\t\t\t// figure out the maximum number of gridlines to show\n\t\t\t\t\t\tvar maxTicks;\n\t\t\t\t\t\tif (optionTicks.maxTicksLimit) {\n\t\t\t\t\t\t\tmaxTicks = optionTicks.maxTicksLimit;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar tickFontColor = helpers.getValueOrDefault(optionTicks.fontColor, globalDefaults.defaultFontColor);\n\t\t\t\t\t\tvar tickFont = parseFontOptions(optionTicks);\n\n\t\t\t\t\t\tvar tl = gridLines.drawTicks ? gridLines.tickMarkLength : 0;\n\t\t\t\t\t\tvar borderDash = helpers.getValueOrDefault(gridLines.borderDash, globalDefaults.borderDash);\n\t\t\t\t\t\tvar borderDashOffset = helpers.getValueOrDefault(gridLines.borderDashOffset, globalDefaults.borderDashOffset);\n\n\t\t\t\t\t\tvar scaleLabelFontColor = helpers.getValueOrDefault(scaleLabel.fontColor, globalDefaults.defaultFontColor);\n\t\t\t\t\t\tvar scaleLabelFont = parseFontOptions(scaleLabel);\n\n\t\t\t\t\t\tvar labelRotationRadians = helpers.toRadians(me.labelRotation);\n\t\t\t\t\t\tvar cosRotation = Math.cos(labelRotationRadians);\n\t\t\t\t\t\tvar longestRotatedLabel = me.longestLabelWidth * cosRotation;\n\n\t\t\t\t\t\t// Make sure we draw text in the correct color and font\n\t\t\t\t\t\tcontext.fillStyle = tickFontColor;\n\n\t\t\t\t\t\tvar itemsToDraw = [];\n\n\t\t\t\t\t\tif (isHorizontal) {\n\t\t\t\t\t\t\tskipRatio = false;\n\n\t\t\t\t\t\t\t// Only calculate the skip ratio with the half width of longestRotateLabel if we got an actual rotation\n\t\t\t\t\t\t\t// See #2584\n\t\t\t\t\t\t\tif (isRotated) {\n\t\t\t\t\t\t\t\tlongestRotatedLabel /= 2;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ((longestRotatedLabel + optionTicks.autoSkipPadding) * me.ticks.length > me.width - (me.paddingLeft + me.paddingRight)) {\n\t\t\t\t\t\t\t\tskipRatio = 1 + Math.floor((longestRotatedLabel + optionTicks.autoSkipPadding) * me.ticks.length / (me.width - (me.paddingLeft + me.paddingRight)));\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// if they defined a max number of optionTicks,\n\t\t\t\t\t\t\t// increase skipRatio until that number is met\n\t\t\t\t\t\t\tif (maxTicks && me.ticks.length > maxTicks) {\n\t\t\t\t\t\t\t\twhile (!skipRatio || me.ticks.length / (skipRatio || 1) > maxTicks) {\n\t\t\t\t\t\t\t\t\tif (!skipRatio) {\n\t\t\t\t\t\t\t\t\t\tskipRatio = 1;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tskipRatio += 1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (!useAutoskipper) {\n\t\t\t\t\t\t\t\tskipRatio = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar xTickStart = options.position === 'right' ? me.left : me.right - tl;\n\t\t\t\t\t\tvar xTickEnd = options.position === 'right' ? me.left + tl : me.right;\n\t\t\t\t\t\tvar yTickStart = options.position === 'bottom' ? me.top : me.bottom - tl;\n\t\t\t\t\t\tvar yTickEnd = options.position === 'bottom' ? me.top + tl : me.bottom;\n\n\t\t\t\t\t\thelpers.each(me.ticks, function (label, index) {\n\t\t\t\t\t\t\t// If the callback returned a null or undefined value, do not draw this line\n\t\t\t\t\t\t\tif (label === undefined || label === null) {\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tvar isLastTick = me.ticks.length === index + 1;\n\n\t\t\t\t\t\t\t// Since we always show the last tick,we need may need to hide the last shown one before\n\t\t\t\t\t\t\tvar shouldSkip = skipRatio > 1 && index % skipRatio > 0 || index % skipRatio === 0 && index + skipRatio >= me.ticks.length;\n\t\t\t\t\t\t\tif (shouldSkip && !isLastTick || label === undefined || label === null) {\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tvar lineWidth, lineColor;\n\t\t\t\t\t\t\tif (index === (typeof me.zeroLineIndex !== 'undefined' ? me.zeroLineIndex : 0)) {\n\t\t\t\t\t\t\t\t// Draw the first index specially\n\t\t\t\t\t\t\t\tlineWidth = gridLines.zeroLineWidth;\n\t\t\t\t\t\t\t\tlineColor = gridLines.zeroLineColor;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tlineWidth = helpers.getValueAtIndexOrDefault(gridLines.lineWidth, index);\n\t\t\t\t\t\t\t\tlineColor = helpers.getValueAtIndexOrDefault(gridLines.color, index);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Common properties\n\t\t\t\t\t\t\tvar tx1, ty1, tx2, ty2, x1, y1, x2, y2, labelX, labelY;\n\t\t\t\t\t\t\tvar textAlign = 'middle';\n\t\t\t\t\t\t\tvar textBaseline = 'middle';\n\n\t\t\t\t\t\t\tif (isHorizontal) {\n\n\t\t\t\t\t\t\t\tif (options.position === 'bottom') {\n\t\t\t\t\t\t\t\t\t// bottom\n\t\t\t\t\t\t\t\t\ttextBaseline = !isRotated ? 'top' : 'middle';\n\t\t\t\t\t\t\t\t\ttextAlign = !isRotated ? 'center' : 'right';\n\t\t\t\t\t\t\t\t\tlabelY = me.top + tl;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t// top\n\t\t\t\t\t\t\t\t\ttextBaseline = !isRotated ? 'bottom' : 'middle';\n\t\t\t\t\t\t\t\t\ttextAlign = !isRotated ? 'center' : 'left';\n\t\t\t\t\t\t\t\t\tlabelY = me.bottom - tl;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tvar xLineValue = me.getPixelForTick(index) + helpers.aliasPixel(lineWidth); // xvalues for grid lines\n\t\t\t\t\t\t\t\tlabelX = me.getPixelForTick(index, gridLines.offsetGridLines) + optionTicks.labelOffset; // x values for optionTicks (need to consider offsetLabel option)\n\n\t\t\t\t\t\t\t\ttx1 = tx2 = x1 = x2 = xLineValue;\n\t\t\t\t\t\t\t\tty1 = yTickStart;\n\t\t\t\t\t\t\t\tty2 = yTickEnd;\n\t\t\t\t\t\t\t\ty1 = chartArea.top;\n\t\t\t\t\t\t\t\ty2 = chartArea.bottom;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tvar isLeft = options.position === 'left';\n\t\t\t\t\t\t\t\tvar tickPadding = optionTicks.padding;\n\t\t\t\t\t\t\t\tvar labelXOffset;\n\n\t\t\t\t\t\t\t\tif (optionTicks.mirror) {\n\t\t\t\t\t\t\t\t\ttextAlign = isLeft ? 'left' : 'right';\n\t\t\t\t\t\t\t\t\tlabelXOffset = tickPadding;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\ttextAlign = isLeft ? 'right' : 'left';\n\t\t\t\t\t\t\t\t\tlabelXOffset = tl + tickPadding;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tlabelX = isLeft ? me.right - labelXOffset : me.left + labelXOffset;\n\n\t\t\t\t\t\t\t\tvar yLineValue = me.getPixelForTick(index); // xvalues for grid lines\n\t\t\t\t\t\t\t\tyLineValue += helpers.aliasPixel(lineWidth);\n\t\t\t\t\t\t\t\tlabelY = me.getPixelForTick(index, gridLines.offsetGridLines);\n\n\t\t\t\t\t\t\t\ttx1 = xTickStart;\n\t\t\t\t\t\t\t\ttx2 = xTickEnd;\n\t\t\t\t\t\t\t\tx1 = chartArea.left;\n\t\t\t\t\t\t\t\tx2 = chartArea.right;\n\t\t\t\t\t\t\t\tty1 = ty2 = y1 = y2 = yLineValue;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\titemsToDraw.push({\n\t\t\t\t\t\t\t\ttx1: tx1,\n\t\t\t\t\t\t\t\tty1: ty1,\n\t\t\t\t\t\t\t\ttx2: tx2,\n\t\t\t\t\t\t\t\tty2: ty2,\n\t\t\t\t\t\t\t\tx1: x1,\n\t\t\t\t\t\t\t\ty1: y1,\n\t\t\t\t\t\t\t\tx2: x2,\n\t\t\t\t\t\t\t\ty2: y2,\n\t\t\t\t\t\t\t\tlabelX: labelX,\n\t\t\t\t\t\t\t\tlabelY: labelY,\n\t\t\t\t\t\t\t\tglWidth: lineWidth,\n\t\t\t\t\t\t\t\tglColor: lineColor,\n\t\t\t\t\t\t\t\tglBorderDash: borderDash,\n\t\t\t\t\t\t\t\tglBorderDashOffset: borderDashOffset,\n\t\t\t\t\t\t\t\trotation: -1 * labelRotationRadians,\n\t\t\t\t\t\t\t\tlabel: label,\n\t\t\t\t\t\t\t\ttextBaseline: textBaseline,\n\t\t\t\t\t\t\t\ttextAlign: textAlign\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\t// Draw all of the tick labels, tick marks, and grid lines at the correct places\n\t\t\t\t\t\thelpers.each(itemsToDraw, function (itemToDraw) {\n\t\t\t\t\t\t\tif (gridLines.display) {\n\t\t\t\t\t\t\t\tcontext.save();\n\t\t\t\t\t\t\t\tcontext.lineWidth = itemToDraw.glWidth;\n\t\t\t\t\t\t\t\tcontext.strokeStyle = itemToDraw.glColor;\n\t\t\t\t\t\t\t\tif (context.setLineDash) {\n\t\t\t\t\t\t\t\t\tcontext.setLineDash(itemToDraw.glBorderDash);\n\t\t\t\t\t\t\t\t\tcontext.lineDashOffset = itemToDraw.glBorderDashOffset;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tcontext.beginPath();\n\n\t\t\t\t\t\t\t\tif (gridLines.drawTicks) {\n\t\t\t\t\t\t\t\t\tcontext.moveTo(itemToDraw.tx1, itemToDraw.ty1);\n\t\t\t\t\t\t\t\t\tcontext.lineTo(itemToDraw.tx2, itemToDraw.ty2);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (gridLines.drawOnChartArea) {\n\t\t\t\t\t\t\t\t\tcontext.moveTo(itemToDraw.x1, itemToDraw.y1);\n\t\t\t\t\t\t\t\t\tcontext.lineTo(itemToDraw.x2, itemToDraw.y2);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tcontext.stroke();\n\t\t\t\t\t\t\t\tcontext.restore();\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (optionTicks.display) {\n\t\t\t\t\t\t\t\tcontext.save();\n\t\t\t\t\t\t\t\tcontext.translate(itemToDraw.labelX, itemToDraw.labelY);\n\t\t\t\t\t\t\t\tcontext.rotate(itemToDraw.rotation);\n\t\t\t\t\t\t\t\tcontext.font = tickFont.font;\n\t\t\t\t\t\t\t\tcontext.textBaseline = itemToDraw.textBaseline;\n\t\t\t\t\t\t\t\tcontext.textAlign = itemToDraw.textAlign;\n\n\t\t\t\t\t\t\t\tvar label = itemToDraw.label;\n\t\t\t\t\t\t\t\tif (helpers.isArray(label)) {\n\t\t\t\t\t\t\t\t\tfor (var i = 0, y = 0; i < label.length; ++i) {\n\t\t\t\t\t\t\t\t\t\t// We just make sure the multiline element is a string here..\n\t\t\t\t\t\t\t\t\t\tcontext.fillText('' + label[i], 0, y);\n\t\t\t\t\t\t\t\t\t\t// apply same lineSpacing as calculated @ L#320\n\t\t\t\t\t\t\t\t\t\ty += tickFont.size * 1.5;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tcontext.fillText(label, 0, 0);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcontext.restore();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tif (scaleLabel.display) {\n\t\t\t\t\t\t\t// Draw the scale label\n\t\t\t\t\t\t\tvar scaleLabelX;\n\t\t\t\t\t\t\tvar scaleLabelY;\n\t\t\t\t\t\t\tvar rotation = 0;\n\n\t\t\t\t\t\t\tif (isHorizontal) {\n\t\t\t\t\t\t\t\tscaleLabelX = me.left + (me.right - me.left) / 2; // midpoint of the width\n\t\t\t\t\t\t\t\tscaleLabelY = options.position === 'bottom' ? me.bottom - scaleLabelFont.size / 2 : me.top + scaleLabelFont.size / 2;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tvar isLeft = options.position === 'left';\n\t\t\t\t\t\t\t\tscaleLabelX = isLeft ? me.left + scaleLabelFont.size / 2 : me.right - scaleLabelFont.size / 2;\n\t\t\t\t\t\t\t\tscaleLabelY = me.top + (me.bottom - me.top) / 2;\n\t\t\t\t\t\t\t\trotation = isLeft ? -0.5 * Math.PI : 0.5 * Math.PI;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tcontext.save();\n\t\t\t\t\t\t\tcontext.translate(scaleLabelX, scaleLabelY);\n\t\t\t\t\t\t\tcontext.rotate(rotation);\n\t\t\t\t\t\t\tcontext.textAlign = 'center';\n\t\t\t\t\t\t\tcontext.textBaseline = 'middle';\n\t\t\t\t\t\t\tcontext.fillStyle = scaleLabelFontColor; // render in correct colour\n\t\t\t\t\t\t\tcontext.font = scaleLabelFont.font;\n\t\t\t\t\t\t\tcontext.fillText(scaleLabel.labelString, 0, 0);\n\t\t\t\t\t\t\tcontext.restore();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (gridLines.drawBorder) {\n\t\t\t\t\t\t\t// Draw the line at the edge of the axis\n\t\t\t\t\t\t\tcontext.lineWidth = helpers.getValueAtIndexOrDefault(gridLines.lineWidth, 0);\n\t\t\t\t\t\t\tcontext.strokeStyle = helpers.getValueAtIndexOrDefault(gridLines.color, 0);\n\t\t\t\t\t\t\tvar x1 = me.left,\n\t\t\t\t\t\t\t    x2 = me.right,\n\t\t\t\t\t\t\t    y1 = me.top,\n\t\t\t\t\t\t\t    y2 = me.bottom;\n\n\t\t\t\t\t\t\tvar aliasPixel = helpers.aliasPixel(context.lineWidth);\n\t\t\t\t\t\t\tif (isHorizontal) {\n\t\t\t\t\t\t\t\ty1 = y2 = options.position === 'top' ? me.bottom : me.top;\n\t\t\t\t\t\t\t\ty1 += aliasPixel;\n\t\t\t\t\t\t\t\ty2 += aliasPixel;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tx1 = x2 = options.position === 'left' ? me.right : me.left;\n\t\t\t\t\t\t\t\tx1 += aliasPixel;\n\t\t\t\t\t\t\t\tx2 += aliasPixel;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tcontext.beginPath();\n\t\t\t\t\t\t\tcontext.moveTo(x1, y1);\n\t\t\t\t\t\t\tcontext.lineTo(x2, y2);\n\t\t\t\t\t\t\tcontext.stroke();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t};\n\t\t}, {}], 33: [function (require, module, exports) {\n\t\t\t'use strict';\n\n\t\t\tmodule.exports = function (Chart) {\n\n\t\t\t\tvar helpers = Chart.helpers;\n\n\t\t\t\tChart.scaleService = {\n\t\t\t\t\t// Scale registration object. Extensions can register new scale types (such as log or DB scales) and then\n\t\t\t\t\t// use the new chart options to grab the correct scale\n\t\t\t\t\tconstructors: {},\n\t\t\t\t\t// Use a registration function so that we can move to an ES6 map when we no longer need to support\n\t\t\t\t\t// old browsers\n\n\t\t\t\t\t// Scale config defaults\n\t\t\t\t\tdefaults: {},\n\t\t\t\t\tregisterScaleType: function registerScaleType(type, scaleConstructor, defaults) {\n\t\t\t\t\t\tthis.constructors[type] = scaleConstructor;\n\t\t\t\t\t\tthis.defaults[type] = helpers.clone(defaults);\n\t\t\t\t\t},\n\t\t\t\t\tgetScaleConstructor: function getScaleConstructor(type) {\n\t\t\t\t\t\treturn this.constructors.hasOwnProperty(type) ? this.constructors[type] : undefined;\n\t\t\t\t\t},\n\t\t\t\t\tgetScaleDefaults: function getScaleDefaults(type) {\n\t\t\t\t\t\t// Return the scale defaults merged with the global settings so that we always use the latest ones\n\t\t\t\t\t\treturn this.defaults.hasOwnProperty(type) ? helpers.scaleMerge(Chart.defaults.scale, this.defaults[type]) : {};\n\t\t\t\t\t},\n\t\t\t\t\tupdateScaleDefaults: function updateScaleDefaults(type, additions) {\n\t\t\t\t\t\tvar defaults = this.defaults;\n\t\t\t\t\t\tif (defaults.hasOwnProperty(type)) {\n\t\t\t\t\t\t\tdefaults[type] = helpers.extend(defaults[type], additions);\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\taddScalesToLayout: function addScalesToLayout(chartInstance) {\n\t\t\t\t\t\t// Adds each scale to the chart.boxes array to be sized accordingly\n\t\t\t\t\t\thelpers.each(chartInstance.scales, function (scale) {\n\t\t\t\t\t\t\tChart.layoutService.addBox(chartInstance, scale);\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t};\n\t\t}, {}], 34: [function (require, module, exports) {\n\t\t\t'use strict';\n\n\t\t\tmodule.exports = function (Chart) {\n\n\t\t\t\tvar helpers = Chart.helpers;\n\n\t\t\t\t/**\n     * Namespace to hold static tick generation functions\n     * @namespace Chart.Ticks\n     */\n\t\t\t\tChart.Ticks = {\n\t\t\t\t\t/**\n      * Namespace to hold generators for different types of ticks\n      * @namespace Chart.Ticks.generators\n      */\n\t\t\t\t\tgenerators: {\n\t\t\t\t\t\t/**\n       * Interface for the options provided to the numeric tick generator\n       * @interface INumericTickGenerationOptions\n       */\n\t\t\t\t\t\t/**\n       * The maximum number of ticks to display\n       * @name INumericTickGenerationOptions#maxTicks\n       * @type Number\n       */\n\t\t\t\t\t\t/**\n       * The distance between each tick.\n       * @name INumericTickGenerationOptions#stepSize\n       * @type Number\n       * @optional\n       */\n\t\t\t\t\t\t/**\n       * Forced minimum for the ticks. If not specified, the minimum of the data range is used to calculate the tick minimum\n       * @name INumericTickGenerationOptions#min\n       * @type Number\n       * @optional\n       */\n\t\t\t\t\t\t/**\n       * The maximum value of the ticks. If not specified, the maximum of the data range is used to calculate the tick maximum\n       * @name INumericTickGenerationOptions#max\n       * @type Number\n       * @optional\n       */\n\n\t\t\t\t\t\t/**\n       * Generate a set of linear ticks\n       * @method Chart.Ticks.generators.linear\n       * @param generationOptions {INumericTickGenerationOptions} the options used to generate the ticks\n       * @param dataRange {IRange} the range of the data\n       * @returns {Array<Number>} array of tick values\n       */\n\t\t\t\t\t\tlinear: function linear(generationOptions, dataRange) {\n\t\t\t\t\t\t\tvar ticks = [];\n\t\t\t\t\t\t\t// To get a \"nice\" value for the tick spacing, we will use the appropriately named\n\t\t\t\t\t\t\t// \"nice number\" algorithm. See http://stackoverflow.com/questions/8506881/nice-label-algorithm-for-charts-with-minimum-ticks\n\t\t\t\t\t\t\t// for details.\n\n\t\t\t\t\t\t\tvar spacing;\n\t\t\t\t\t\t\tif (generationOptions.stepSize && generationOptions.stepSize > 0) {\n\t\t\t\t\t\t\t\tspacing = generationOptions.stepSize;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tvar niceRange = helpers.niceNum(dataRange.max - dataRange.min, false);\n\t\t\t\t\t\t\t\tspacing = helpers.niceNum(niceRange / (generationOptions.maxTicks - 1), true);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tvar niceMin = Math.floor(dataRange.min / spacing) * spacing;\n\t\t\t\t\t\t\tvar niceMax = Math.ceil(dataRange.max / spacing) * spacing;\n\n\t\t\t\t\t\t\t// If min, max and stepSize is set and they make an evenly spaced scale use it.\n\t\t\t\t\t\t\tif (generationOptions.min && generationOptions.max && generationOptions.stepSize) {\n\t\t\t\t\t\t\t\t// If very close to our whole number, use it.\n\t\t\t\t\t\t\t\tif (helpers.almostWhole((generationOptions.max - generationOptions.min) / generationOptions.stepSize, spacing / 1000)) {\n\t\t\t\t\t\t\t\t\tniceMin = generationOptions.min;\n\t\t\t\t\t\t\t\t\tniceMax = generationOptions.max;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tvar numSpaces = (niceMax - niceMin) / spacing;\n\t\t\t\t\t\t\t// If very close to our rounded value, use it.\n\t\t\t\t\t\t\tif (helpers.almostEquals(numSpaces, Math.round(numSpaces), spacing / 1000)) {\n\t\t\t\t\t\t\t\tnumSpaces = Math.round(numSpaces);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tnumSpaces = Math.ceil(numSpaces);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Put the values into the ticks array\n\t\t\t\t\t\t\tticks.push(generationOptions.min !== undefined ? generationOptions.min : niceMin);\n\t\t\t\t\t\t\tfor (var j = 1; j < numSpaces; ++j) {\n\t\t\t\t\t\t\t\tticks.push(niceMin + j * spacing);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tticks.push(generationOptions.max !== undefined ? generationOptions.max : niceMax);\n\n\t\t\t\t\t\t\treturn ticks;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\t/**\n       * Generate a set of logarithmic ticks\n       * @method Chart.Ticks.generators.logarithmic\n       * @param generationOptions {INumericTickGenerationOptions} the options used to generate the ticks\n       * @param dataRange {IRange} the range of the data\n       * @returns {Array<Number>} array of tick values\n       */\n\t\t\t\t\t\tlogarithmic: function logarithmic(generationOptions, dataRange) {\n\t\t\t\t\t\t\tvar ticks = [];\n\t\t\t\t\t\t\tvar getValueOrDefault = helpers.getValueOrDefault;\n\n\t\t\t\t\t\t\t// Figure out what the max number of ticks we can support it is based on the size of\n\t\t\t\t\t\t\t// the axis area. For now, we say that the minimum tick spacing in pixels must be 50\n\t\t\t\t\t\t\t// We also limit the maximum number of ticks to 11 which gives a nice 10 squares on\n\t\t\t\t\t\t\t// the graph\n\t\t\t\t\t\t\tvar tickVal = getValueOrDefault(generationOptions.min, Math.pow(10, Math.floor(helpers.log10(dataRange.min))));\n\n\t\t\t\t\t\t\tvar endExp = Math.floor(helpers.log10(dataRange.max));\n\t\t\t\t\t\t\tvar endSignificand = Math.ceil(dataRange.max / Math.pow(10, endExp));\n\t\t\t\t\t\t\tvar exp;\n\t\t\t\t\t\t\tvar significand;\n\n\t\t\t\t\t\t\tif (tickVal === 0) {\n\t\t\t\t\t\t\t\texp = Math.floor(helpers.log10(dataRange.minNotZero));\n\t\t\t\t\t\t\t\tsignificand = Math.floor(dataRange.minNotZero / Math.pow(10, exp));\n\n\t\t\t\t\t\t\t\tticks.push(tickVal);\n\t\t\t\t\t\t\t\ttickVal = significand * Math.pow(10, exp);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\texp = Math.floor(helpers.log10(tickVal));\n\t\t\t\t\t\t\t\tsignificand = Math.floor(tickVal / Math.pow(10, exp));\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\t\tticks.push(tickVal);\n\n\t\t\t\t\t\t\t\t++significand;\n\t\t\t\t\t\t\t\tif (significand === 10) {\n\t\t\t\t\t\t\t\t\tsignificand = 1;\n\t\t\t\t\t\t\t\t\t++exp;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\ttickVal = significand * Math.pow(10, exp);\n\t\t\t\t\t\t\t} while (exp < endExp || exp === endExp && significand < endSignificand);\n\n\t\t\t\t\t\t\tvar lastTick = getValueOrDefault(generationOptions.max, tickVal);\n\t\t\t\t\t\t\tticks.push(lastTick);\n\n\t\t\t\t\t\t\treturn ticks;\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\n\t\t\t\t\t/**\n      * Namespace to hold formatters for different types of ticks\n      * @namespace Chart.Ticks.formatters\n      */\n\t\t\t\t\tformatters: {\n\t\t\t\t\t\t/**\n       * Formatter for value labels\n       * @method Chart.Ticks.formatters.values\n       * @param value the value to display\n       * @return {String|Array} the label to display\n       */\n\t\t\t\t\t\tvalues: function values(value) {\n\t\t\t\t\t\t\treturn helpers.isArray(value) ? value : '' + value;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\t/**\n       * Formatter for linear numeric ticks\n       * @method Chart.Ticks.formatters.linear\n       * @param tickValue {Number} the value to be formatted\n       * @param index {Number} the position of the tickValue parameter in the ticks array\n       * @param ticks {Array<Number>} the list of ticks being converted\n       * @return {String} string representation of the tickValue parameter\n       */\n\t\t\t\t\t\tlinear: function linear(tickValue, index, ticks) {\n\t\t\t\t\t\t\t// If we have lots of ticks, don't use the ones\n\t\t\t\t\t\t\tvar delta = ticks.length > 3 ? ticks[2] - ticks[1] : ticks[1] - ticks[0];\n\n\t\t\t\t\t\t\t// If we have a number like 2.5 as the delta, figure out how many decimal places we need\n\t\t\t\t\t\t\tif (Math.abs(delta) > 1) {\n\t\t\t\t\t\t\t\tif (tickValue !== Math.floor(tickValue)) {\n\t\t\t\t\t\t\t\t\t// not an integer\n\t\t\t\t\t\t\t\t\tdelta = tickValue - Math.floor(tickValue);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tvar logDelta = helpers.log10(Math.abs(delta));\n\t\t\t\t\t\t\tvar tickString = '';\n\n\t\t\t\t\t\t\tif (tickValue !== 0) {\n\t\t\t\t\t\t\t\tvar numDecimal = -1 * Math.floor(logDelta);\n\t\t\t\t\t\t\t\tnumDecimal = Math.max(Math.min(numDecimal, 20), 0); // toFixed has a max of 20 decimal places\n\t\t\t\t\t\t\t\ttickString = tickValue.toFixed(numDecimal);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttickString = '0'; // never show decimal places for 0\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treturn tickString;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tlogarithmic: function logarithmic(tickValue, index, ticks) {\n\t\t\t\t\t\t\tvar remain = tickValue / Math.pow(10, Math.floor(helpers.log10(tickValue)));\n\n\t\t\t\t\t\t\tif (tickValue === 0) {\n\t\t\t\t\t\t\t\treturn '0';\n\t\t\t\t\t\t\t} else if (remain === 1 || remain === 2 || remain === 5 || index === 0 || index === ticks.length - 1) {\n\t\t\t\t\t\t\t\treturn tickValue.toExponential();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn '';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t};\n\t\t}, {}], 35: [function (require, module, exports) {\n\t\t\t'use strict';\n\n\t\t\tmodule.exports = function (Chart) {\n\n\t\t\t\tvar helpers = Chart.helpers;\n\n\t\t\t\tChart.defaults.global.title = {\n\t\t\t\t\tdisplay: false,\n\t\t\t\t\tposition: 'top',\n\t\t\t\t\tfullWidth: true, // marks that this box should take the full width of the canvas (pushing down other boxes)\n\n\t\t\t\t\tfontStyle: 'bold',\n\t\t\t\t\tpadding: 10,\n\n\t\t\t\t\t// actual title\n\t\t\t\t\ttext: ''\n\t\t\t\t};\n\n\t\t\t\tvar noop = helpers.noop;\n\t\t\t\tChart.Title = Chart.Element.extend({\n\n\t\t\t\t\tinitialize: function initialize(config) {\n\t\t\t\t\t\tvar me = this;\n\t\t\t\t\t\thelpers.extend(me, config);\n\n\t\t\t\t\t\t// Contains hit boxes for each dataset (in dataset order)\n\t\t\t\t\t\tme.legendHitBoxes = [];\n\t\t\t\t\t},\n\n\t\t\t\t\t// These methods are ordered by lifecycle. Utilities then follow.\n\n\t\t\t\t\tbeforeUpdate: noop,\n\t\t\t\t\tupdate: function update(maxWidth, maxHeight, margins) {\n\t\t\t\t\t\tvar me = this;\n\n\t\t\t\t\t\t// Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)\n\t\t\t\t\t\tme.beforeUpdate();\n\n\t\t\t\t\t\t// Absorb the master measurements\n\t\t\t\t\t\tme.maxWidth = maxWidth;\n\t\t\t\t\t\tme.maxHeight = maxHeight;\n\t\t\t\t\t\tme.margins = margins;\n\n\t\t\t\t\t\t// Dimensions\n\t\t\t\t\t\tme.beforeSetDimensions();\n\t\t\t\t\t\tme.setDimensions();\n\t\t\t\t\t\tme.afterSetDimensions();\n\t\t\t\t\t\t// Labels\n\t\t\t\t\t\tme.beforeBuildLabels();\n\t\t\t\t\t\tme.buildLabels();\n\t\t\t\t\t\tme.afterBuildLabels();\n\n\t\t\t\t\t\t// Fit\n\t\t\t\t\t\tme.beforeFit();\n\t\t\t\t\t\tme.fit();\n\t\t\t\t\t\tme.afterFit();\n\t\t\t\t\t\t//\n\t\t\t\t\t\tme.afterUpdate();\n\n\t\t\t\t\t\treturn me.minSize;\n\t\t\t\t\t},\n\t\t\t\t\tafterUpdate: noop,\n\n\t\t\t\t\t//\n\n\t\t\t\t\tbeforeSetDimensions: noop,\n\t\t\t\t\tsetDimensions: function setDimensions() {\n\t\t\t\t\t\tvar me = this;\n\t\t\t\t\t\t// Set the unconstrained dimension before label rotation\n\t\t\t\t\t\tif (me.isHorizontal()) {\n\t\t\t\t\t\t\t// Reset position before calculating rotation\n\t\t\t\t\t\t\tme.width = me.maxWidth;\n\t\t\t\t\t\t\tme.left = 0;\n\t\t\t\t\t\t\tme.right = me.width;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tme.height = me.maxHeight;\n\n\t\t\t\t\t\t\t// Reset position before calculating rotation\n\t\t\t\t\t\t\tme.top = 0;\n\t\t\t\t\t\t\tme.bottom = me.height;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Reset padding\n\t\t\t\t\t\tme.paddingLeft = 0;\n\t\t\t\t\t\tme.paddingTop = 0;\n\t\t\t\t\t\tme.paddingRight = 0;\n\t\t\t\t\t\tme.paddingBottom = 0;\n\n\t\t\t\t\t\t// Reset minSize\n\t\t\t\t\t\tme.minSize = {\n\t\t\t\t\t\t\twidth: 0,\n\t\t\t\t\t\t\theight: 0\n\t\t\t\t\t\t};\n\t\t\t\t\t},\n\t\t\t\t\tafterSetDimensions: noop,\n\n\t\t\t\t\t//\n\n\t\t\t\t\tbeforeBuildLabels: noop,\n\t\t\t\t\tbuildLabels: noop,\n\t\t\t\t\tafterBuildLabels: noop,\n\n\t\t\t\t\t//\n\n\t\t\t\t\tbeforeFit: noop,\n\t\t\t\t\tfit: function fit() {\n\t\t\t\t\t\tvar me = this,\n\t\t\t\t\t\t    valueOrDefault = helpers.getValueOrDefault,\n\t\t\t\t\t\t    opts = me.options,\n\t\t\t\t\t\t    globalDefaults = Chart.defaults.global,\n\t\t\t\t\t\t    display = opts.display,\n\t\t\t\t\t\t    fontSize = valueOrDefault(opts.fontSize, globalDefaults.defaultFontSize),\n\t\t\t\t\t\t    minSize = me.minSize;\n\n\t\t\t\t\t\tif (me.isHorizontal()) {\n\t\t\t\t\t\t\tminSize.width = me.maxWidth; // fill all the width\n\t\t\t\t\t\t\tminSize.height = display ? fontSize + opts.padding * 2 : 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tminSize.width = display ? fontSize + opts.padding * 2 : 0;\n\t\t\t\t\t\t\tminSize.height = me.maxHeight; // fill all the height\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tme.width = minSize.width;\n\t\t\t\t\t\tme.height = minSize.height;\n\t\t\t\t\t},\n\t\t\t\t\tafterFit: noop,\n\n\t\t\t\t\t// Shared Methods\n\t\t\t\t\tisHorizontal: function isHorizontal() {\n\t\t\t\t\t\tvar pos = this.options.position;\n\t\t\t\t\t\treturn pos === 'top' || pos === 'bottom';\n\t\t\t\t\t},\n\n\t\t\t\t\t// Actually draw the title block on the canvas\n\t\t\t\t\tdraw: function draw() {\n\t\t\t\t\t\tvar me = this,\n\t\t\t\t\t\t    ctx = me.ctx,\n\t\t\t\t\t\t    valueOrDefault = helpers.getValueOrDefault,\n\t\t\t\t\t\t    opts = me.options,\n\t\t\t\t\t\t    globalDefaults = Chart.defaults.global;\n\n\t\t\t\t\t\tif (opts.display) {\n\t\t\t\t\t\t\tvar fontSize = valueOrDefault(opts.fontSize, globalDefaults.defaultFontSize),\n\t\t\t\t\t\t\t    fontStyle = valueOrDefault(opts.fontStyle, globalDefaults.defaultFontStyle),\n\t\t\t\t\t\t\t    fontFamily = valueOrDefault(opts.fontFamily, globalDefaults.defaultFontFamily),\n\t\t\t\t\t\t\t    titleFont = helpers.fontString(fontSize, fontStyle, fontFamily),\n\t\t\t\t\t\t\t    rotation = 0,\n\t\t\t\t\t\t\t    titleX,\n\t\t\t\t\t\t\t    titleY,\n\t\t\t\t\t\t\t    top = me.top,\n\t\t\t\t\t\t\t    left = me.left,\n\t\t\t\t\t\t\t    bottom = me.bottom,\n\t\t\t\t\t\t\t    right = me.right,\n\t\t\t\t\t\t\t    maxWidth;\n\n\t\t\t\t\t\t\tctx.fillStyle = valueOrDefault(opts.fontColor, globalDefaults.defaultFontColor); // render in correct colour\n\t\t\t\t\t\t\tctx.font = titleFont;\n\n\t\t\t\t\t\t\t// Horizontal\n\t\t\t\t\t\t\tif (me.isHorizontal()) {\n\t\t\t\t\t\t\t\ttitleX = left + (right - left) / 2; // midpoint of the width\n\t\t\t\t\t\t\t\ttitleY = top + (bottom - top) / 2; // midpoint of the height\n\t\t\t\t\t\t\t\tmaxWidth = right - left;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttitleX = opts.position === 'left' ? left + fontSize / 2 : right - fontSize / 2;\n\t\t\t\t\t\t\t\ttitleY = top + (bottom - top) / 2;\n\t\t\t\t\t\t\t\tmaxWidth = bottom - top;\n\t\t\t\t\t\t\t\trotation = Math.PI * (opts.position === 'left' ? -0.5 : 0.5);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tctx.save();\n\t\t\t\t\t\t\tctx.translate(titleX, titleY);\n\t\t\t\t\t\t\tctx.rotate(rotation);\n\t\t\t\t\t\t\tctx.textAlign = 'center';\n\t\t\t\t\t\t\tctx.textBaseline = 'middle';\n\t\t\t\t\t\t\tctx.fillText(opts.text, 0, 0, maxWidth);\n\t\t\t\t\t\t\tctx.restore();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tfunction createNewTitleBlockAndAttach(chartInstance, titleOpts) {\n\t\t\t\t\tvar title = new Chart.Title({\n\t\t\t\t\t\tctx: chartInstance.chart.ctx,\n\t\t\t\t\t\toptions: titleOpts,\n\t\t\t\t\t\tchart: chartInstance\n\t\t\t\t\t});\n\t\t\t\t\tchartInstance.titleBlock = title;\n\t\t\t\t\tChart.layoutService.addBox(chartInstance, title);\n\t\t\t\t}\n\n\t\t\t\t// Register the title plugin\n\t\t\t\tChart.plugins.register({\n\t\t\t\t\tbeforeInit: function beforeInit(chartInstance) {\n\t\t\t\t\t\tvar titleOpts = chartInstance.options.title;\n\n\t\t\t\t\t\tif (titleOpts) {\n\t\t\t\t\t\t\tcreateNewTitleBlockAndAttach(chartInstance, titleOpts);\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tbeforeUpdate: function beforeUpdate(chartInstance) {\n\t\t\t\t\t\tvar titleOpts = chartInstance.options.title;\n\n\t\t\t\t\t\tif (titleOpts) {\n\t\t\t\t\t\t\ttitleOpts = helpers.configMerge(Chart.defaults.global.title, titleOpts);\n\n\t\t\t\t\t\t\tif (chartInstance.titleBlock) {\n\t\t\t\t\t\t\t\tchartInstance.titleBlock.options = titleOpts;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tcreateNewTitleBlockAndAttach(chartInstance, titleOpts);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tChart.layoutService.removeBox(chartInstance, chartInstance.titleBlock);\n\t\t\t\t\t\t\tdelete chartInstance.titleBlock;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t};\n\t\t}, {}], 36: [function (require, module, exports) {\n\t\t\t'use strict';\n\n\t\t\tmodule.exports = function (Chart) {\n\n\t\t\t\tvar helpers = Chart.helpers;\n\n\t\t\t\t/**\n    \t * Helper method to merge the opacity into a color\n    \t */\n\t\t\t\tfunction mergeOpacity(colorString, opacity) {\n\t\t\t\t\tvar color = helpers.color(colorString);\n\t\t\t\t\treturn color.alpha(opacity * color.alpha()).rgbaString();\n\t\t\t\t}\n\n\t\t\t\tChart.defaults.global.tooltips = {\n\t\t\t\t\tenabled: true,\n\t\t\t\t\tcustom: null,\n\t\t\t\t\tmode: 'nearest',\n\t\t\t\t\tposition: 'average',\n\t\t\t\t\tintersect: true,\n\t\t\t\t\tbackgroundColor: 'rgba(0,0,0,0.8)',\n\t\t\t\t\ttitleFontStyle: 'bold',\n\t\t\t\t\ttitleSpacing: 2,\n\t\t\t\t\ttitleMarginBottom: 6,\n\t\t\t\t\ttitleFontColor: '#fff',\n\t\t\t\t\ttitleAlign: 'left',\n\t\t\t\t\tbodySpacing: 2,\n\t\t\t\t\tbodyFontColor: '#fff',\n\t\t\t\t\tbodyAlign: 'left',\n\t\t\t\t\tfooterFontStyle: 'bold',\n\t\t\t\t\tfooterSpacing: 2,\n\t\t\t\t\tfooterMarginTop: 6,\n\t\t\t\t\tfooterFontColor: '#fff',\n\t\t\t\t\tfooterAlign: 'left',\n\t\t\t\t\tyPadding: 6,\n\t\t\t\t\txPadding: 6,\n\t\t\t\t\tcaretSize: 5,\n\t\t\t\t\tcornerRadius: 6,\n\t\t\t\t\tmultiKeyBackground: '#fff',\n\t\t\t\t\tdisplayColors: true,\n\t\t\t\t\tcallbacks: {\n\t\t\t\t\t\t// Args are: (tooltipItems, data)\n\t\t\t\t\t\tbeforeTitle: helpers.noop,\n\t\t\t\t\t\ttitle: function title(tooltipItems, data) {\n\t\t\t\t\t\t\t// Pick first xLabel for now\n\t\t\t\t\t\t\tvar title = '';\n\t\t\t\t\t\t\tvar labels = data.labels;\n\t\t\t\t\t\t\tvar labelCount = labels ? labels.length : 0;\n\n\t\t\t\t\t\t\tif (tooltipItems.length > 0) {\n\t\t\t\t\t\t\t\tvar item = tooltipItems[0];\n\n\t\t\t\t\t\t\t\tif (item.xLabel) {\n\t\t\t\t\t\t\t\t\ttitle = item.xLabel;\n\t\t\t\t\t\t\t\t} else if (labelCount > 0 && item.index < labelCount) {\n\t\t\t\t\t\t\t\t\ttitle = labels[item.index];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treturn title;\n\t\t\t\t\t\t},\n\t\t\t\t\t\tafterTitle: helpers.noop,\n\n\t\t\t\t\t\t// Args are: (tooltipItems, data)\n\t\t\t\t\t\tbeforeBody: helpers.noop,\n\n\t\t\t\t\t\t// Args are: (tooltipItem, data)\n\t\t\t\t\t\tbeforeLabel: helpers.noop,\n\t\t\t\t\t\tlabel: function label(tooltipItem, data) {\n\t\t\t\t\t\t\tvar datasetLabel = data.datasets[tooltipItem.datasetIndex].label || '';\n\t\t\t\t\t\t\treturn datasetLabel + ': ' + tooltipItem.yLabel;\n\t\t\t\t\t\t},\n\t\t\t\t\t\tlabelColor: function labelColor(tooltipItem, chartInstance) {\n\t\t\t\t\t\t\tvar meta = chartInstance.getDatasetMeta(tooltipItem.datasetIndex);\n\t\t\t\t\t\t\tvar activeElement = meta.data[tooltipItem.index];\n\t\t\t\t\t\t\tvar view = activeElement._view;\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tborderColor: view.borderColor,\n\t\t\t\t\t\t\t\tbackgroundColor: view.backgroundColor\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t},\n\t\t\t\t\t\tafterLabel: helpers.noop,\n\n\t\t\t\t\t\t// Args are: (tooltipItems, data)\n\t\t\t\t\t\tafterBody: helpers.noop,\n\n\t\t\t\t\t\t// Args are: (tooltipItems, data)\n\t\t\t\t\t\tbeforeFooter: helpers.noop,\n\t\t\t\t\t\tfooter: helpers.noop,\n\t\t\t\t\t\tafterFooter: helpers.noop\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\t// Helper to push or concat based on if the 2nd parameter is an array or not\n\t\t\t\tfunction pushOrConcat(base, toPush) {\n\t\t\t\t\tif (toPush) {\n\t\t\t\t\t\tif (helpers.isArray(toPush)) {\n\t\t\t\t\t\t\t// base = base.concat(toPush);\n\t\t\t\t\t\t\tArray.prototype.push.apply(base, toPush);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tbase.push(toPush);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn base;\n\t\t\t\t}\n\n\t\t\t\t// Private helper to create a tooltip item model\n\t\t\t\t// @param element : the chart element (point, arc, bar) to create the tooltip item for\n\t\t\t\t// @return : new tooltip item\n\t\t\t\tfunction createTooltipItem(element) {\n\t\t\t\t\tvar xScale = element._xScale;\n\t\t\t\t\tvar yScale = element._yScale || element._scale; // handle radar || polarArea charts\n\t\t\t\t\tvar index = element._index,\n\t\t\t\t\t    datasetIndex = element._datasetIndex;\n\n\t\t\t\t\treturn {\n\t\t\t\t\t\txLabel: xScale ? xScale.getLabelForIndex(index, datasetIndex) : '',\n\t\t\t\t\t\tyLabel: yScale ? yScale.getLabelForIndex(index, datasetIndex) : '',\n\t\t\t\t\t\tindex: index,\n\t\t\t\t\t\tdatasetIndex: datasetIndex,\n\t\t\t\t\t\tx: element._model.x,\n\t\t\t\t\t\ty: element._model.y\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\t/**\n     * Helper to get the reset model for the tooltip\n     * @param tooltipOpts {Object} the tooltip options\n     */\n\t\t\t\tfunction getBaseModel(tooltipOpts) {\n\t\t\t\t\tvar globalDefaults = Chart.defaults.global;\n\t\t\t\t\tvar getValueOrDefault = helpers.getValueOrDefault;\n\n\t\t\t\t\treturn {\n\t\t\t\t\t\t// Positioning\n\t\t\t\t\t\txPadding: tooltipOpts.xPadding,\n\t\t\t\t\t\tyPadding: tooltipOpts.yPadding,\n\t\t\t\t\t\txAlign: tooltipOpts.xAlign,\n\t\t\t\t\t\tyAlign: tooltipOpts.yAlign,\n\n\t\t\t\t\t\t// Body\n\t\t\t\t\t\tbodyFontColor: tooltipOpts.bodyFontColor,\n\t\t\t\t\t\t_bodyFontFamily: getValueOrDefault(tooltipOpts.bodyFontFamily, globalDefaults.defaultFontFamily),\n\t\t\t\t\t\t_bodyFontStyle: getValueOrDefault(tooltipOpts.bodyFontStyle, globalDefaults.defaultFontStyle),\n\t\t\t\t\t\t_bodyAlign: tooltipOpts.bodyAlign,\n\t\t\t\t\t\tbodyFontSize: getValueOrDefault(tooltipOpts.bodyFontSize, globalDefaults.defaultFontSize),\n\t\t\t\t\t\tbodySpacing: tooltipOpts.bodySpacing,\n\n\t\t\t\t\t\t// Title\n\t\t\t\t\t\ttitleFontColor: tooltipOpts.titleFontColor,\n\t\t\t\t\t\t_titleFontFamily: getValueOrDefault(tooltipOpts.titleFontFamily, globalDefaults.defaultFontFamily),\n\t\t\t\t\t\t_titleFontStyle: getValueOrDefault(tooltipOpts.titleFontStyle, globalDefaults.defaultFontStyle),\n\t\t\t\t\t\ttitleFontSize: getValueOrDefault(tooltipOpts.titleFontSize, globalDefaults.defaultFontSize),\n\t\t\t\t\t\t_titleAlign: tooltipOpts.titleAlign,\n\t\t\t\t\t\ttitleSpacing: tooltipOpts.titleSpacing,\n\t\t\t\t\t\ttitleMarginBottom: tooltipOpts.titleMarginBottom,\n\n\t\t\t\t\t\t// Footer\n\t\t\t\t\t\tfooterFontColor: tooltipOpts.footerFontColor,\n\t\t\t\t\t\t_footerFontFamily: getValueOrDefault(tooltipOpts.footerFontFamily, globalDefaults.defaultFontFamily),\n\t\t\t\t\t\t_footerFontStyle: getValueOrDefault(tooltipOpts.footerFontStyle, globalDefaults.defaultFontStyle),\n\t\t\t\t\t\tfooterFontSize: getValueOrDefault(tooltipOpts.footerFontSize, globalDefaults.defaultFontSize),\n\t\t\t\t\t\t_footerAlign: tooltipOpts.footerAlign,\n\t\t\t\t\t\tfooterSpacing: tooltipOpts.footerSpacing,\n\t\t\t\t\t\tfooterMarginTop: tooltipOpts.footerMarginTop,\n\n\t\t\t\t\t\t// Appearance\n\t\t\t\t\t\tcaretSize: tooltipOpts.caretSize,\n\t\t\t\t\t\tcornerRadius: tooltipOpts.cornerRadius,\n\t\t\t\t\t\tbackgroundColor: tooltipOpts.backgroundColor,\n\t\t\t\t\t\topacity: 0,\n\t\t\t\t\t\tlegendColorBackground: tooltipOpts.multiKeyBackground,\n\t\t\t\t\t\tdisplayColors: tooltipOpts.displayColors\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\t/**\n     * Get the size of the tooltip\n     */\n\t\t\t\tfunction getTooltipSize(tooltip, model) {\n\t\t\t\t\tvar ctx = tooltip._chart.ctx;\n\n\t\t\t\t\tvar height = model.yPadding * 2; // Tooltip Padding\n\t\t\t\t\tvar width = 0;\n\n\t\t\t\t\t// Count of all lines in the body\n\t\t\t\t\tvar body = model.body;\n\t\t\t\t\tvar combinedBodyLength = body.reduce(function (count, bodyItem) {\n\t\t\t\t\t\treturn count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length;\n\t\t\t\t\t}, 0);\n\t\t\t\t\tcombinedBodyLength += model.beforeBody.length + model.afterBody.length;\n\n\t\t\t\t\tvar titleLineCount = model.title.length;\n\t\t\t\t\tvar footerLineCount = model.footer.length;\n\t\t\t\t\tvar titleFontSize = model.titleFontSize,\n\t\t\t\t\t    bodyFontSize = model.bodyFontSize,\n\t\t\t\t\t    footerFontSize = model.footerFontSize;\n\n\t\t\t\t\theight += titleLineCount * titleFontSize; // Title Lines\n\t\t\t\t\theight += titleLineCount ? (titleLineCount - 1) * model.titleSpacing : 0; // Title Line Spacing\n\t\t\t\t\theight += titleLineCount ? model.titleMarginBottom : 0; // Title's bottom Margin\n\t\t\t\t\theight += combinedBodyLength * bodyFontSize; // Body Lines\n\t\t\t\t\theight += combinedBodyLength ? (combinedBodyLength - 1) * model.bodySpacing : 0; // Body Line Spacing\n\t\t\t\t\theight += footerLineCount ? model.footerMarginTop : 0; // Footer Margin\n\t\t\t\t\theight += footerLineCount * footerFontSize; // Footer Lines\n\t\t\t\t\theight += footerLineCount ? (footerLineCount - 1) * model.footerSpacing : 0; // Footer Line Spacing\n\n\t\t\t\t\t// Title width\n\t\t\t\t\tvar widthPadding = 0;\n\t\t\t\t\tvar maxLineWidth = function maxLineWidth(line) {\n\t\t\t\t\t\twidth = Math.max(width, ctx.measureText(line).width + widthPadding);\n\t\t\t\t\t};\n\n\t\t\t\t\tctx.font = helpers.fontString(titleFontSize, model._titleFontStyle, model._titleFontFamily);\n\t\t\t\t\thelpers.each(model.title, maxLineWidth);\n\n\t\t\t\t\t// Body width\n\t\t\t\t\tctx.font = helpers.fontString(bodyFontSize, model._bodyFontStyle, model._bodyFontFamily);\n\t\t\t\t\thelpers.each(model.beforeBody.concat(model.afterBody), maxLineWidth);\n\n\t\t\t\t\t// Body lines may include some extra width due to the color box\n\t\t\t\t\twidthPadding = model.displayColors ? bodyFontSize + 2 : 0;\n\t\t\t\t\thelpers.each(body, function (bodyItem) {\n\t\t\t\t\t\thelpers.each(bodyItem.before, maxLineWidth);\n\t\t\t\t\t\thelpers.each(bodyItem.lines, maxLineWidth);\n\t\t\t\t\t\thelpers.each(bodyItem.after, maxLineWidth);\n\t\t\t\t\t});\n\n\t\t\t\t\t// Reset back to 0\n\t\t\t\t\twidthPadding = 0;\n\n\t\t\t\t\t// Footer width\n\t\t\t\t\tctx.font = helpers.fontString(footerFontSize, model._footerFontStyle, model._footerFontFamily);\n\t\t\t\t\thelpers.each(model.footer, maxLineWidth);\n\n\t\t\t\t\t// Add padding\n\t\t\t\t\twidth += 2 * model.xPadding;\n\n\t\t\t\t\treturn {\n\t\t\t\t\t\twidth: width,\n\t\t\t\t\t\theight: height\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\t/**\n     * Helper to get the alignment of a tooltip given the size\n     */\n\t\t\t\tfunction determineAlignment(tooltip, size) {\n\t\t\t\t\tvar model = tooltip._model;\n\t\t\t\t\tvar chart = tooltip._chart;\n\t\t\t\t\tvar chartArea = tooltip._chartInstance.chartArea;\n\t\t\t\t\tvar xAlign = 'center';\n\t\t\t\t\tvar yAlign = 'center';\n\n\t\t\t\t\tif (model.y < size.height) {\n\t\t\t\t\t\tyAlign = 'top';\n\t\t\t\t\t} else if (model.y > chart.height - size.height) {\n\t\t\t\t\t\tyAlign = 'bottom';\n\t\t\t\t\t}\n\n\t\t\t\t\tvar lf, rf; // functions to determine left, right alignment\n\t\t\t\t\tvar olf, orf; // functions to determine if left/right alignment causes tooltip to go outside chart\n\t\t\t\t\tvar yf; // function to get the y alignment if the tooltip goes outside of the left or right edges\n\t\t\t\t\tvar midX = (chartArea.left + chartArea.right) / 2;\n\t\t\t\t\tvar midY = (chartArea.top + chartArea.bottom) / 2;\n\n\t\t\t\t\tif (yAlign === 'center') {\n\t\t\t\t\t\tlf = function lf(x) {\n\t\t\t\t\t\t\treturn x <= midX;\n\t\t\t\t\t\t};\n\t\t\t\t\t\trf = function rf(x) {\n\t\t\t\t\t\t\treturn x > midX;\n\t\t\t\t\t\t};\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlf = function lf(x) {\n\t\t\t\t\t\t\treturn x <= size.width / 2;\n\t\t\t\t\t\t};\n\t\t\t\t\t\trf = function rf(x) {\n\t\t\t\t\t\t\treturn x >= chart.width - size.width / 2;\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t\tolf = function olf(x) {\n\t\t\t\t\t\treturn x + size.width > chart.width;\n\t\t\t\t\t};\n\t\t\t\t\torf = function orf(x) {\n\t\t\t\t\t\treturn x - size.width < 0;\n\t\t\t\t\t};\n\t\t\t\t\tyf = function yf(y) {\n\t\t\t\t\t\treturn y <= midY ? 'top' : 'bottom';\n\t\t\t\t\t};\n\n\t\t\t\t\tif (lf(model.x)) {\n\t\t\t\t\t\txAlign = 'left';\n\n\t\t\t\t\t\t// Is tooltip too wide and goes over the right side of the chart.?\n\t\t\t\t\t\tif (olf(model.x)) {\n\t\t\t\t\t\t\txAlign = 'center';\n\t\t\t\t\t\t\tyAlign = yf(model.y);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (rf(model.x)) {\n\t\t\t\t\t\txAlign = 'right';\n\n\t\t\t\t\t\t// Is tooltip too wide and goes outside left edge of canvas?\n\t\t\t\t\t\tif (orf(model.x)) {\n\t\t\t\t\t\t\txAlign = 'center';\n\t\t\t\t\t\t\tyAlign = yf(model.y);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tvar opts = tooltip._options;\n\t\t\t\t\treturn {\n\t\t\t\t\t\txAlign: opts.xAlign ? opts.xAlign : xAlign,\n\t\t\t\t\t\tyAlign: opts.yAlign ? opts.yAlign : yAlign\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\t/**\n     * @Helper to get the location a tooltip needs to be placed at given the initial position (via the vm) and the size and alignment\n     */\n\t\t\t\tfunction getBackgroundPoint(vm, size, alignment) {\n\t\t\t\t\t// Background Position\n\t\t\t\t\tvar x = vm.x;\n\t\t\t\t\tvar y = vm.y;\n\n\t\t\t\t\tvar caretSize = vm.caretSize,\n\t\t\t\t\t    caretPadding = vm.caretPadding,\n\t\t\t\t\t    cornerRadius = vm.cornerRadius,\n\t\t\t\t\t    xAlign = alignment.xAlign,\n\t\t\t\t\t    yAlign = alignment.yAlign,\n\t\t\t\t\t    paddingAndSize = caretSize + caretPadding,\n\t\t\t\t\t    radiusAndPadding = cornerRadius + caretPadding;\n\n\t\t\t\t\tif (xAlign === 'right') {\n\t\t\t\t\t\tx -= size.width;\n\t\t\t\t\t} else if (xAlign === 'center') {\n\t\t\t\t\t\tx -= size.width / 2;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (yAlign === 'top') {\n\t\t\t\t\t\ty += paddingAndSize;\n\t\t\t\t\t} else if (yAlign === 'bottom') {\n\t\t\t\t\t\ty -= size.height + paddingAndSize;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ty -= size.height / 2;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (yAlign === 'center') {\n\t\t\t\t\t\tif (xAlign === 'left') {\n\t\t\t\t\t\t\tx += paddingAndSize;\n\t\t\t\t\t\t} else if (xAlign === 'right') {\n\t\t\t\t\t\t\tx -= paddingAndSize;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (xAlign === 'left') {\n\t\t\t\t\t\tx -= radiusAndPadding;\n\t\t\t\t\t} else if (xAlign === 'right') {\n\t\t\t\t\t\tx += radiusAndPadding;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn {\n\t\t\t\t\t\tx: x,\n\t\t\t\t\t\ty: y\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\tChart.Tooltip = Chart.Element.extend({\n\t\t\t\t\tinitialize: function initialize() {\n\t\t\t\t\t\tthis._model = getBaseModel(this._options);\n\t\t\t\t\t},\n\n\t\t\t\t\t// Get the title\n\t\t\t\t\t// Args are: (tooltipItem, data)\n\t\t\t\t\tgetTitle: function getTitle() {\n\t\t\t\t\t\tvar me = this;\n\t\t\t\t\t\tvar opts = me._options;\n\t\t\t\t\t\tvar callbacks = opts.callbacks;\n\n\t\t\t\t\t\tvar beforeTitle = callbacks.beforeTitle.apply(me, arguments),\n\t\t\t\t\t\t    title = callbacks.title.apply(me, arguments),\n\t\t\t\t\t\t    afterTitle = callbacks.afterTitle.apply(me, arguments);\n\n\t\t\t\t\t\tvar lines = [];\n\t\t\t\t\t\tlines = pushOrConcat(lines, beforeTitle);\n\t\t\t\t\t\tlines = pushOrConcat(lines, title);\n\t\t\t\t\t\tlines = pushOrConcat(lines, afterTitle);\n\n\t\t\t\t\t\treturn lines;\n\t\t\t\t\t},\n\n\t\t\t\t\t// Args are: (tooltipItem, data)\n\t\t\t\t\tgetBeforeBody: function getBeforeBody() {\n\t\t\t\t\t\tvar lines = this._options.callbacks.beforeBody.apply(this, arguments);\n\t\t\t\t\t\treturn helpers.isArray(lines) ? lines : lines !== undefined ? [lines] : [];\n\t\t\t\t\t},\n\n\t\t\t\t\t// Args are: (tooltipItem, data)\n\t\t\t\t\tgetBody: function getBody(tooltipItems, data) {\n\t\t\t\t\t\tvar me = this;\n\t\t\t\t\t\tvar callbacks = me._options.callbacks;\n\t\t\t\t\t\tvar bodyItems = [];\n\n\t\t\t\t\t\thelpers.each(tooltipItems, function (tooltipItem) {\n\t\t\t\t\t\t\tvar bodyItem = {\n\t\t\t\t\t\t\t\tbefore: [],\n\t\t\t\t\t\t\t\tlines: [],\n\t\t\t\t\t\t\t\tafter: []\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tpushOrConcat(bodyItem.before, callbacks.beforeLabel.call(me, tooltipItem, data));\n\t\t\t\t\t\t\tpushOrConcat(bodyItem.lines, callbacks.label.call(me, tooltipItem, data));\n\t\t\t\t\t\t\tpushOrConcat(bodyItem.after, callbacks.afterLabel.call(me, tooltipItem, data));\n\n\t\t\t\t\t\t\tbodyItems.push(bodyItem);\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\treturn bodyItems;\n\t\t\t\t\t},\n\n\t\t\t\t\t// Args are: (tooltipItem, data)\n\t\t\t\t\tgetAfterBody: function getAfterBody() {\n\t\t\t\t\t\tvar lines = this._options.callbacks.afterBody.apply(this, arguments);\n\t\t\t\t\t\treturn helpers.isArray(lines) ? lines : lines !== undefined ? [lines] : [];\n\t\t\t\t\t},\n\n\t\t\t\t\t// Get the footer and beforeFooter and afterFooter lines\n\t\t\t\t\t// Args are: (tooltipItem, data)\n\t\t\t\t\tgetFooter: function getFooter() {\n\t\t\t\t\t\tvar me = this;\n\t\t\t\t\t\tvar callbacks = me._options.callbacks;\n\n\t\t\t\t\t\tvar beforeFooter = callbacks.beforeFooter.apply(me, arguments);\n\t\t\t\t\t\tvar footer = callbacks.footer.apply(me, arguments);\n\t\t\t\t\t\tvar afterFooter = callbacks.afterFooter.apply(me, arguments);\n\n\t\t\t\t\t\tvar lines = [];\n\t\t\t\t\t\tlines = pushOrConcat(lines, beforeFooter);\n\t\t\t\t\t\tlines = pushOrConcat(lines, footer);\n\t\t\t\t\t\tlines = pushOrConcat(lines, afterFooter);\n\n\t\t\t\t\t\treturn lines;\n\t\t\t\t\t},\n\n\t\t\t\t\tupdate: function update(changed) {\n\t\t\t\t\t\tvar me = this;\n\t\t\t\t\t\tvar opts = me._options;\n\n\t\t\t\t\t\t// Need to regenerate the model because its faster than using extend and it is necessary due to the optimization in Chart.Element.transition\n\t\t\t\t\t\t// that does _view = _model if ease === 1. This causes the 2nd tooltip update to set properties in both the view and model at the same time\n\t\t\t\t\t\t// which breaks any animations.\n\t\t\t\t\t\tvar existingModel = me._model;\n\t\t\t\t\t\tvar model = me._model = getBaseModel(opts);\n\t\t\t\t\t\tvar active = me._active;\n\n\t\t\t\t\t\tvar data = me._data;\n\t\t\t\t\t\tvar chartInstance = me._chartInstance;\n\n\t\t\t\t\t\t// In the case where active.length === 0 we need to keep these at existing values for good animations\n\t\t\t\t\t\tvar alignment = {\n\t\t\t\t\t\t\txAlign: existingModel.xAlign,\n\t\t\t\t\t\t\tyAlign: existingModel.yAlign\n\t\t\t\t\t\t};\n\t\t\t\t\t\tvar backgroundPoint = {\n\t\t\t\t\t\t\tx: existingModel.x,\n\t\t\t\t\t\t\ty: existingModel.y\n\t\t\t\t\t\t};\n\t\t\t\t\t\tvar tooltipSize = {\n\t\t\t\t\t\t\twidth: existingModel.width,\n\t\t\t\t\t\t\theight: existingModel.height\n\t\t\t\t\t\t};\n\t\t\t\t\t\tvar tooltipPosition = {\n\t\t\t\t\t\t\tx: existingModel.caretX,\n\t\t\t\t\t\t\ty: existingModel.caretY\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tvar i, len;\n\n\t\t\t\t\t\tif (active.length) {\n\t\t\t\t\t\t\tmodel.opacity = 1;\n\n\t\t\t\t\t\t\tvar labelColors = [];\n\t\t\t\t\t\t\ttooltipPosition = Chart.Tooltip.positioners[opts.position](active, me._eventPosition);\n\n\t\t\t\t\t\t\tvar tooltipItems = [];\n\t\t\t\t\t\t\tfor (i = 0, len = active.length; i < len; ++i) {\n\t\t\t\t\t\t\t\ttooltipItems.push(createTooltipItem(active[i]));\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// If the user provided a filter function, use it to modify the tooltip items\n\t\t\t\t\t\t\tif (opts.filter) {\n\t\t\t\t\t\t\t\ttooltipItems = tooltipItems.filter(function (a) {\n\t\t\t\t\t\t\t\t\treturn opts.filter(a, data);\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// If the user provided a sorting function, use it to modify the tooltip items\n\t\t\t\t\t\t\tif (opts.itemSort) {\n\t\t\t\t\t\t\t\ttooltipItems = tooltipItems.sort(function (a, b) {\n\t\t\t\t\t\t\t\t\treturn opts.itemSort(a, b, data);\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Determine colors for boxes\n\t\t\t\t\t\t\thelpers.each(tooltipItems, function (tooltipItem) {\n\t\t\t\t\t\t\t\tlabelColors.push(opts.callbacks.labelColor.call(me, tooltipItem, chartInstance));\n\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t// Build the Text Lines\n\t\t\t\t\t\t\tmodel.title = me.getTitle(tooltipItems, data);\n\t\t\t\t\t\t\tmodel.beforeBody = me.getBeforeBody(tooltipItems, data);\n\t\t\t\t\t\t\tmodel.body = me.getBody(tooltipItems, data);\n\t\t\t\t\t\t\tmodel.afterBody = me.getAfterBody(tooltipItems, data);\n\t\t\t\t\t\t\tmodel.footer = me.getFooter(tooltipItems, data);\n\n\t\t\t\t\t\t\t// Initial positioning and colors\n\t\t\t\t\t\t\tmodel.x = Math.round(tooltipPosition.x);\n\t\t\t\t\t\t\tmodel.y = Math.round(tooltipPosition.y);\n\t\t\t\t\t\t\tmodel.caretPadding = helpers.getValueOrDefault(tooltipPosition.padding, 2);\n\t\t\t\t\t\t\tmodel.labelColors = labelColors;\n\n\t\t\t\t\t\t\t// data points\n\t\t\t\t\t\t\tmodel.dataPoints = tooltipItems;\n\n\t\t\t\t\t\t\t// We need to determine alignment of the tooltip\n\t\t\t\t\t\t\ttooltipSize = getTooltipSize(this, model);\n\t\t\t\t\t\t\talignment = determineAlignment(this, tooltipSize);\n\t\t\t\t\t\t\t// Final Size and Position\n\t\t\t\t\t\t\tbackgroundPoint = getBackgroundPoint(model, tooltipSize, alignment);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tmodel.opacity = 0;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tmodel.xAlign = alignment.xAlign;\n\t\t\t\t\t\tmodel.yAlign = alignment.yAlign;\n\t\t\t\t\t\tmodel.x = backgroundPoint.x;\n\t\t\t\t\t\tmodel.y = backgroundPoint.y;\n\t\t\t\t\t\tmodel.width = tooltipSize.width;\n\t\t\t\t\t\tmodel.height = tooltipSize.height;\n\n\t\t\t\t\t\t// Point where the caret on the tooltip points to\n\t\t\t\t\t\tmodel.caretX = tooltipPosition.x;\n\t\t\t\t\t\tmodel.caretY = tooltipPosition.y;\n\n\t\t\t\t\t\tme._model = model;\n\n\t\t\t\t\t\tif (changed && opts.custom) {\n\t\t\t\t\t\t\topts.custom.call(me, model);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn me;\n\t\t\t\t\t},\n\t\t\t\t\tdrawCaret: function drawCaret(tooltipPoint, size, opacity) {\n\t\t\t\t\t\tvar vm = this._view;\n\t\t\t\t\t\tvar ctx = this._chart.ctx;\n\t\t\t\t\t\tvar x1, x2, x3;\n\t\t\t\t\t\tvar y1, y2, y3;\n\t\t\t\t\t\tvar caretSize = vm.caretSize;\n\t\t\t\t\t\tvar cornerRadius = vm.cornerRadius;\n\t\t\t\t\t\tvar xAlign = vm.xAlign,\n\t\t\t\t\t\t    yAlign = vm.yAlign;\n\t\t\t\t\t\tvar ptX = tooltipPoint.x,\n\t\t\t\t\t\t    ptY = tooltipPoint.y;\n\t\t\t\t\t\tvar width = size.width,\n\t\t\t\t\t\t    height = size.height;\n\n\t\t\t\t\t\tif (yAlign === 'center') {\n\t\t\t\t\t\t\t// Left or right side\n\t\t\t\t\t\t\tif (xAlign === 'left') {\n\t\t\t\t\t\t\t\tx1 = ptX;\n\t\t\t\t\t\t\t\tx2 = x1 - caretSize;\n\t\t\t\t\t\t\t\tx3 = x1;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tx1 = ptX + width;\n\t\t\t\t\t\t\t\tx2 = x1 + caretSize;\n\t\t\t\t\t\t\t\tx3 = x1;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\ty2 = ptY + height / 2;\n\t\t\t\t\t\t\ty1 = y2 - caretSize;\n\t\t\t\t\t\t\ty3 = y2 + caretSize;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (xAlign === 'left') {\n\t\t\t\t\t\t\t\tx1 = ptX + cornerRadius;\n\t\t\t\t\t\t\t\tx2 = x1 + caretSize;\n\t\t\t\t\t\t\t\tx3 = x2 + caretSize;\n\t\t\t\t\t\t\t} else if (xAlign === 'right') {\n\t\t\t\t\t\t\t\tx1 = ptX + width - cornerRadius;\n\t\t\t\t\t\t\t\tx2 = x1 - caretSize;\n\t\t\t\t\t\t\t\tx3 = x2 - caretSize;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tx2 = ptX + width / 2;\n\t\t\t\t\t\t\t\tx1 = x2 - caretSize;\n\t\t\t\t\t\t\t\tx3 = x2 + caretSize;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (yAlign === 'top') {\n\t\t\t\t\t\t\t\ty1 = ptY;\n\t\t\t\t\t\t\t\ty2 = y1 - caretSize;\n\t\t\t\t\t\t\t\ty3 = y1;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ty1 = ptY + height;\n\t\t\t\t\t\t\t\ty2 = y1 + caretSize;\n\t\t\t\t\t\t\t\ty3 = y1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tctx.fillStyle = mergeOpacity(vm.backgroundColor, opacity);\n\t\t\t\t\t\tctx.beginPath();\n\t\t\t\t\t\tctx.moveTo(x1, y1);\n\t\t\t\t\t\tctx.lineTo(x2, y2);\n\t\t\t\t\t\tctx.lineTo(x3, y3);\n\t\t\t\t\t\tctx.closePath();\n\t\t\t\t\t\tctx.fill();\n\t\t\t\t\t},\n\t\t\t\t\tdrawTitle: function drawTitle(pt, vm, ctx, opacity) {\n\t\t\t\t\t\tvar title = vm.title;\n\n\t\t\t\t\t\tif (title.length) {\n\t\t\t\t\t\t\tctx.textAlign = vm._titleAlign;\n\t\t\t\t\t\t\tctx.textBaseline = 'top';\n\n\t\t\t\t\t\t\tvar titleFontSize = vm.titleFontSize,\n\t\t\t\t\t\t\t    titleSpacing = vm.titleSpacing;\n\n\t\t\t\t\t\t\tctx.fillStyle = mergeOpacity(vm.titleFontColor, opacity);\n\t\t\t\t\t\t\tctx.font = helpers.fontString(titleFontSize, vm._titleFontStyle, vm._titleFontFamily);\n\n\t\t\t\t\t\t\tvar i, len;\n\t\t\t\t\t\t\tfor (i = 0, len = title.length; i < len; ++i) {\n\t\t\t\t\t\t\t\tctx.fillText(title[i], pt.x, pt.y);\n\t\t\t\t\t\t\t\tpt.y += titleFontSize + titleSpacing; // Line Height and spacing\n\n\t\t\t\t\t\t\t\tif (i + 1 === title.length) {\n\t\t\t\t\t\t\t\t\tpt.y += vm.titleMarginBottom - titleSpacing; // If Last, add margin, remove spacing\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tdrawBody: function drawBody(pt, vm, ctx, opacity) {\n\t\t\t\t\t\tvar bodyFontSize = vm.bodyFontSize;\n\t\t\t\t\t\tvar bodySpacing = vm.bodySpacing;\n\t\t\t\t\t\tvar body = vm.body;\n\n\t\t\t\t\t\tctx.textAlign = vm._bodyAlign;\n\t\t\t\t\t\tctx.textBaseline = 'top';\n\n\t\t\t\t\t\tvar textColor = mergeOpacity(vm.bodyFontColor, opacity);\n\t\t\t\t\t\tctx.fillStyle = textColor;\n\t\t\t\t\t\tctx.font = helpers.fontString(bodyFontSize, vm._bodyFontStyle, vm._bodyFontFamily);\n\n\t\t\t\t\t\t// Before Body\n\t\t\t\t\t\tvar xLinePadding = 0;\n\t\t\t\t\t\tvar fillLineOfText = function fillLineOfText(line) {\n\t\t\t\t\t\t\tctx.fillText(line, pt.x + xLinePadding, pt.y);\n\t\t\t\t\t\t\tpt.y += bodyFontSize + bodySpacing;\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\t// Before body lines\n\t\t\t\t\t\thelpers.each(vm.beforeBody, fillLineOfText);\n\n\t\t\t\t\t\tvar drawColorBoxes = vm.displayColors;\n\t\t\t\t\t\txLinePadding = drawColorBoxes ? bodyFontSize + 2 : 0;\n\n\t\t\t\t\t\t// Draw body lines now\n\t\t\t\t\t\thelpers.each(body, function (bodyItem, i) {\n\t\t\t\t\t\t\thelpers.each(bodyItem.before, fillLineOfText);\n\n\t\t\t\t\t\t\thelpers.each(bodyItem.lines, function (line) {\n\t\t\t\t\t\t\t\t// Draw Legend-like boxes if needed\n\t\t\t\t\t\t\t\tif (drawColorBoxes) {\n\t\t\t\t\t\t\t\t\t// Fill a white rect so that colours merge nicely if the opacity is < 1\n\t\t\t\t\t\t\t\t\tctx.fillStyle = mergeOpacity(vm.legendColorBackground, opacity);\n\t\t\t\t\t\t\t\t\tctx.fillRect(pt.x, pt.y, bodyFontSize, bodyFontSize);\n\n\t\t\t\t\t\t\t\t\t// Border\n\t\t\t\t\t\t\t\t\tctx.strokeStyle = mergeOpacity(vm.labelColors[i].borderColor, opacity);\n\t\t\t\t\t\t\t\t\tctx.strokeRect(pt.x, pt.y, bodyFontSize, bodyFontSize);\n\n\t\t\t\t\t\t\t\t\t// Inner square\n\t\t\t\t\t\t\t\t\tctx.fillStyle = mergeOpacity(vm.labelColors[i].backgroundColor, opacity);\n\t\t\t\t\t\t\t\t\tctx.fillRect(pt.x + 1, pt.y + 1, bodyFontSize - 2, bodyFontSize - 2);\n\n\t\t\t\t\t\t\t\t\tctx.fillStyle = textColor;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tfillLineOfText(line);\n\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\thelpers.each(bodyItem.after, fillLineOfText);\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\t// Reset back to 0 for after body\n\t\t\t\t\t\txLinePadding = 0;\n\n\t\t\t\t\t\t// After body lines\n\t\t\t\t\t\thelpers.each(vm.afterBody, fillLineOfText);\n\t\t\t\t\t\tpt.y -= bodySpacing; // Remove last body spacing\n\t\t\t\t\t},\n\t\t\t\t\tdrawFooter: function drawFooter(pt, vm, ctx, opacity) {\n\t\t\t\t\t\tvar footer = vm.footer;\n\n\t\t\t\t\t\tif (footer.length) {\n\t\t\t\t\t\t\tpt.y += vm.footerMarginTop;\n\n\t\t\t\t\t\t\tctx.textAlign = vm._footerAlign;\n\t\t\t\t\t\t\tctx.textBaseline = 'top';\n\n\t\t\t\t\t\t\tctx.fillStyle = mergeOpacity(vm.footerFontColor, opacity);\n\t\t\t\t\t\t\tctx.font = helpers.fontString(vm.footerFontSize, vm._footerFontStyle, vm._footerFontFamily);\n\n\t\t\t\t\t\t\thelpers.each(footer, function (line) {\n\t\t\t\t\t\t\t\tctx.fillText(line, pt.x, pt.y);\n\t\t\t\t\t\t\t\tpt.y += vm.footerFontSize + vm.footerSpacing;\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tdrawBackground: function drawBackground(pt, vm, ctx, tooltipSize, opacity) {\n\t\t\t\t\t\tctx.fillStyle = mergeOpacity(vm.backgroundColor, opacity);\n\t\t\t\t\t\thelpers.drawRoundedRectangle(ctx, pt.x, pt.y, tooltipSize.width, tooltipSize.height, vm.cornerRadius);\n\t\t\t\t\t\tctx.fill();\n\t\t\t\t\t},\n\t\t\t\t\tdraw: function draw() {\n\t\t\t\t\t\tvar ctx = this._chart.ctx;\n\t\t\t\t\t\tvar vm = this._view;\n\n\t\t\t\t\t\tif (vm.opacity === 0) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar tooltipSize = {\n\t\t\t\t\t\t\twidth: vm.width,\n\t\t\t\t\t\t\theight: vm.height\n\t\t\t\t\t\t};\n\t\t\t\t\t\tvar pt = {\n\t\t\t\t\t\t\tx: vm.x,\n\t\t\t\t\t\t\ty: vm.y\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\t// IE11/Edge does not like very small opacities, so snap to 0\n\t\t\t\t\t\tvar opacity = Math.abs(vm.opacity < 1e-3) ? 0 : vm.opacity;\n\n\t\t\t\t\t\tif (this._options.enabled) {\n\t\t\t\t\t\t\t// Draw Background\n\t\t\t\t\t\t\tthis.drawBackground(pt, vm, ctx, tooltipSize, opacity);\n\n\t\t\t\t\t\t\t// Draw Caret\n\t\t\t\t\t\t\tthis.drawCaret(pt, tooltipSize, opacity);\n\n\t\t\t\t\t\t\t// Draw Title, Body, and Footer\n\t\t\t\t\t\t\tpt.x += vm.xPadding;\n\t\t\t\t\t\t\tpt.y += vm.yPadding;\n\n\t\t\t\t\t\t\t// Titles\n\t\t\t\t\t\t\tthis.drawTitle(pt, vm, ctx, opacity);\n\n\t\t\t\t\t\t\t// Body\n\t\t\t\t\t\t\tthis.drawBody(pt, vm, ctx, opacity);\n\n\t\t\t\t\t\t\t// Footer\n\t\t\t\t\t\t\tthis.drawFooter(pt, vm, ctx, opacity);\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\n\t\t\t\t\t/**\n      * Handle an event\n      * @private\n      * @param {IEvent} event - The event to handle\n      * @returns {Boolean} true if the tooltip changed\n      */\n\t\t\t\t\thandleEvent: function handleEvent(e) {\n\t\t\t\t\t\tvar me = this;\n\t\t\t\t\t\tvar options = me._options;\n\t\t\t\t\t\tvar changed = false;\n\n\t\t\t\t\t\tme._lastActive = me._lastActive || [];\n\n\t\t\t\t\t\t// Find Active Elements for tooltips\n\t\t\t\t\t\tif (e.type === 'mouseout') {\n\t\t\t\t\t\t\tme._active = [];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tme._active = me._chartInstance.getElementsAtEventForMode(e, options.mode, options);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Remember Last Actives\n\t\t\t\t\t\tchanged = !helpers.arrayEquals(me._active, me._lastActive);\n\t\t\t\t\t\tme._lastActive = me._active;\n\n\t\t\t\t\t\tif (options.enabled || options.custom) {\n\t\t\t\t\t\t\tme._eventPosition = {\n\t\t\t\t\t\t\t\tx: e.x,\n\t\t\t\t\t\t\t\ty: e.y\n\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\tvar model = me._model;\n\t\t\t\t\t\t\tme.update(true);\n\t\t\t\t\t\t\tme.pivot();\n\n\t\t\t\t\t\t\t// See if our tooltip position changed\n\t\t\t\t\t\t\tchanged |= model.x !== me._model.x || model.y !== me._model.y;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn changed;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\t/**\n     * @namespace Chart.Tooltip.positioners\n     */\n\t\t\t\tChart.Tooltip.positioners = {\n\t\t\t\t\t/**\n      * Average mode places the tooltip at the average position of the elements shown\n      * @function Chart.Tooltip.positioners.average\n      * @param elements {ChartElement[]} the elements being displayed in the tooltip\n      * @returns {Point} tooltip position\n      */\n\t\t\t\t\taverage: function average(elements) {\n\t\t\t\t\t\tif (!elements.length) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar i, len;\n\t\t\t\t\t\tvar x = 0;\n\t\t\t\t\t\tvar y = 0;\n\t\t\t\t\t\tvar count = 0;\n\n\t\t\t\t\t\tfor (i = 0, len = elements.length; i < len; ++i) {\n\t\t\t\t\t\t\tvar el = elements[i];\n\t\t\t\t\t\t\tif (el && el.hasValue()) {\n\t\t\t\t\t\t\t\tvar pos = el.tooltipPosition();\n\t\t\t\t\t\t\t\tx += pos.x;\n\t\t\t\t\t\t\t\ty += pos.y;\n\t\t\t\t\t\t\t\t++count;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tx: Math.round(x / count),\n\t\t\t\t\t\t\ty: Math.round(y / count)\n\t\t\t\t\t\t};\n\t\t\t\t\t},\n\n\t\t\t\t\t/**\n      * Gets the tooltip position nearest of the item nearest to the event position\n      * @function Chart.Tooltip.positioners.nearest\n      * @param elements {Chart.Element[]} the tooltip elements\n      * @param eventPosition {Point} the position of the event in canvas coordinates\n      * @returns {Point} the tooltip position\n      */\n\t\t\t\t\tnearest: function nearest(elements, eventPosition) {\n\t\t\t\t\t\tvar x = eventPosition.x;\n\t\t\t\t\t\tvar y = eventPosition.y;\n\n\t\t\t\t\t\tvar nearestElement;\n\t\t\t\t\t\tvar minDistance = Number.POSITIVE_INFINITY;\n\t\t\t\t\t\tvar i, len;\n\t\t\t\t\t\tfor (i = 0, len = elements.length; i < len; ++i) {\n\t\t\t\t\t\t\tvar el = elements[i];\n\t\t\t\t\t\t\tif (el && el.hasValue()) {\n\t\t\t\t\t\t\t\tvar center = el.getCenterPoint();\n\t\t\t\t\t\t\t\tvar d = helpers.distanceBetweenPoints(eventPosition, center);\n\n\t\t\t\t\t\t\t\tif (d < minDistance) {\n\t\t\t\t\t\t\t\t\tminDistance = d;\n\t\t\t\t\t\t\t\t\tnearestElement = el;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (nearestElement) {\n\t\t\t\t\t\t\tvar tp = nearestElement.tooltipPosition();\n\t\t\t\t\t\t\tx = tp.x;\n\t\t\t\t\t\t\ty = tp.y;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tx: x,\n\t\t\t\t\t\t\ty: y\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t};\n\t\t}, {}], 37: [function (require, module, exports) {\n\t\t\t'use strict';\n\n\t\t\tmodule.exports = function (Chart) {\n\n\t\t\t\tvar helpers = Chart.helpers,\n\t\t\t\t    globalOpts = Chart.defaults.global;\n\n\t\t\t\tglobalOpts.elements.arc = {\n\t\t\t\t\tbackgroundColor: globalOpts.defaultColor,\n\t\t\t\t\tborderColor: '#fff',\n\t\t\t\t\tborderWidth: 2\n\t\t\t\t};\n\n\t\t\t\tChart.elements.Arc = Chart.Element.extend({\n\t\t\t\t\tinLabelRange: function inLabelRange(mouseX) {\n\t\t\t\t\t\tvar vm = this._view;\n\n\t\t\t\t\t\tif (vm) {\n\t\t\t\t\t\t\treturn Math.pow(mouseX - vm.x, 2) < Math.pow(vm.radius + vm.hoverRadius, 2);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t},\n\t\t\t\t\tinRange: function inRange(chartX, chartY) {\n\t\t\t\t\t\tvar vm = this._view;\n\n\t\t\t\t\t\tif (vm) {\n\t\t\t\t\t\t\tvar pointRelativePosition = helpers.getAngleFromPoint(vm, {\n\t\t\t\t\t\t\t\tx: chartX,\n\t\t\t\t\t\t\t\ty: chartY\n\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t\t    angle = pointRelativePosition.angle,\n\t\t\t\t\t\t\t    distance = pointRelativePosition.distance;\n\n\t\t\t\t\t\t\t// Sanitise angle range\n\t\t\t\t\t\t\tvar startAngle = vm.startAngle;\n\t\t\t\t\t\t\tvar endAngle = vm.endAngle;\n\t\t\t\t\t\t\twhile (endAngle < startAngle) {\n\t\t\t\t\t\t\t\tendAngle += 2.0 * Math.PI;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\twhile (angle > endAngle) {\n\t\t\t\t\t\t\t\tangle -= 2.0 * Math.PI;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\twhile (angle < startAngle) {\n\t\t\t\t\t\t\t\tangle += 2.0 * Math.PI;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Check if within the range of the open/close angle\n\t\t\t\t\t\t\tvar betweenAngles = angle >= startAngle && angle <= endAngle,\n\t\t\t\t\t\t\t    withinRadius = distance >= vm.innerRadius && distance <= vm.outerRadius;\n\n\t\t\t\t\t\t\treturn betweenAngles && withinRadius;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t},\n\t\t\t\t\tgetCenterPoint: function getCenterPoint() {\n\t\t\t\t\t\tvar vm = this._view;\n\t\t\t\t\t\tvar halfAngle = (vm.startAngle + vm.endAngle) / 2;\n\t\t\t\t\t\tvar halfRadius = (vm.innerRadius + vm.outerRadius) / 2;\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tx: vm.x + Math.cos(halfAngle) * halfRadius,\n\t\t\t\t\t\t\ty: vm.y + Math.sin(halfAngle) * halfRadius\n\t\t\t\t\t\t};\n\t\t\t\t\t},\n\t\t\t\t\tgetArea: function getArea() {\n\t\t\t\t\t\tvar vm = this._view;\n\t\t\t\t\t\treturn Math.PI * ((vm.endAngle - vm.startAngle) / (2 * Math.PI)) * (Math.pow(vm.outerRadius, 2) - Math.pow(vm.innerRadius, 2));\n\t\t\t\t\t},\n\t\t\t\t\ttooltipPosition: function tooltipPosition() {\n\t\t\t\t\t\tvar vm = this._view;\n\n\t\t\t\t\t\tvar centreAngle = vm.startAngle + (vm.endAngle - vm.startAngle) / 2,\n\t\t\t\t\t\t    rangeFromCentre = (vm.outerRadius - vm.innerRadius) / 2 + vm.innerRadius;\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tx: vm.x + Math.cos(centreAngle) * rangeFromCentre,\n\t\t\t\t\t\t\ty: vm.y + Math.sin(centreAngle) * rangeFromCentre\n\t\t\t\t\t\t};\n\t\t\t\t\t},\n\t\t\t\t\tdraw: function draw() {\n\n\t\t\t\t\t\tvar ctx = this._chart.ctx,\n\t\t\t\t\t\t    vm = this._view,\n\t\t\t\t\t\t    sA = vm.startAngle,\n\t\t\t\t\t\t    eA = vm.endAngle;\n\n\t\t\t\t\t\tctx.beginPath();\n\n\t\t\t\t\t\tctx.arc(vm.x, vm.y, vm.outerRadius, sA, eA);\n\t\t\t\t\t\tctx.arc(vm.x, vm.y, vm.innerRadius, eA, sA, true);\n\n\t\t\t\t\t\tctx.closePath();\n\t\t\t\t\t\tctx.strokeStyle = vm.borderColor;\n\t\t\t\t\t\tctx.lineWidth = vm.borderWidth;\n\n\t\t\t\t\t\tctx.fillStyle = vm.backgroundColor;\n\n\t\t\t\t\t\tctx.fill();\n\t\t\t\t\t\tctx.lineJoin = 'bevel';\n\n\t\t\t\t\t\tif (vm.borderWidth) {\n\t\t\t\t\t\t\tctx.stroke();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t};\n\t\t}, {}], 38: [function (require, module, exports) {\n\t\t\t'use strict';\n\n\t\t\tmodule.exports = function (Chart) {\n\n\t\t\t\tvar helpers = Chart.helpers;\n\t\t\t\tvar globalDefaults = Chart.defaults.global;\n\n\t\t\t\tChart.defaults.global.elements.line = {\n\t\t\t\t\ttension: 0.4,\n\t\t\t\t\tbackgroundColor: globalDefaults.defaultColor,\n\t\t\t\t\tborderWidth: 3,\n\t\t\t\t\tborderColor: globalDefaults.defaultColor,\n\t\t\t\t\tborderCapStyle: 'butt',\n\t\t\t\t\tborderDash: [],\n\t\t\t\t\tborderDashOffset: 0.0,\n\t\t\t\t\tborderJoinStyle: 'miter',\n\t\t\t\t\tcapBezierPoints: true,\n\t\t\t\t\tfill: true };\n\n\t\t\t\tChart.elements.Line = Chart.Element.extend({\n\t\t\t\t\tdraw: function draw() {\n\t\t\t\t\t\tvar me = this;\n\t\t\t\t\t\tvar vm = me._view;\n\t\t\t\t\t\tvar spanGaps = vm.spanGaps;\n\t\t\t\t\t\tvar fillPoint = vm.scaleZero;\n\t\t\t\t\t\tvar loop = me._loop;\n\n\t\t\t\t\t\t// Handle different fill modes for cartesian lines\n\t\t\t\t\t\tif (!loop) {\n\t\t\t\t\t\t\tif (vm.fill === 'top') {\n\t\t\t\t\t\t\t\tfillPoint = vm.scaleTop;\n\t\t\t\t\t\t\t} else if (vm.fill === 'bottom') {\n\t\t\t\t\t\t\t\tfillPoint = vm.scaleBottom;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar ctx = me._chart.ctx;\n\t\t\t\t\t\tctx.save();\n\n\t\t\t\t\t\t// Helper function to draw a line to a point\n\t\t\t\t\t\tfunction lineToPoint(previousPoint, point) {\n\t\t\t\t\t\t\tvar pointVM = point._view;\n\t\t\t\t\t\t\tif (point._view.steppedLine === true) {\n\t\t\t\t\t\t\t\tctx.lineTo(pointVM.x, previousPoint._view.y);\n\t\t\t\t\t\t\t\tctx.lineTo(pointVM.x, pointVM.y);\n\t\t\t\t\t\t\t} else if (point._view.tension === 0) {\n\t\t\t\t\t\t\t\tctx.lineTo(pointVM.x, pointVM.y);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tctx.bezierCurveTo(previousPoint._view.controlPointNextX, previousPoint._view.controlPointNextY, pointVM.controlPointPreviousX, pointVM.controlPointPreviousY, pointVM.x, pointVM.y);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar points = me._children.slice(); // clone array\n\t\t\t\t\t\tvar lastDrawnIndex = -1;\n\n\t\t\t\t\t\t// If we are looping, adding the first point again\n\t\t\t\t\t\tif (loop && points.length) {\n\t\t\t\t\t\t\tpoints.push(points[0]);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar index, current, previous, currentVM;\n\n\t\t\t\t\t\t// Fill Line\n\t\t\t\t\t\tif (points.length && vm.fill) {\n\t\t\t\t\t\t\tctx.beginPath();\n\n\t\t\t\t\t\t\tfor (index = 0; index < points.length; ++index) {\n\t\t\t\t\t\t\t\tcurrent = points[index];\n\t\t\t\t\t\t\t\tprevious = helpers.previousItem(points, index);\n\t\t\t\t\t\t\t\tcurrentVM = current._view;\n\n\t\t\t\t\t\t\t\t// First point moves to it's starting position no matter what\n\t\t\t\t\t\t\t\tif (index === 0) {\n\t\t\t\t\t\t\t\t\tif (loop) {\n\t\t\t\t\t\t\t\t\t\tctx.moveTo(fillPoint.x, fillPoint.y);\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tctx.moveTo(currentVM.x, fillPoint);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif (!currentVM.skip) {\n\t\t\t\t\t\t\t\t\t\tlastDrawnIndex = index;\n\t\t\t\t\t\t\t\t\t\tctx.lineTo(currentVM.x, currentVM.y);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tprevious = lastDrawnIndex === -1 ? previous : points[lastDrawnIndex];\n\n\t\t\t\t\t\t\t\t\tif (currentVM.skip) {\n\t\t\t\t\t\t\t\t\t\t// Only do this if this is the first point that is skipped\n\t\t\t\t\t\t\t\t\t\tif (!spanGaps && lastDrawnIndex === index - 1) {\n\t\t\t\t\t\t\t\t\t\t\tif (loop) {\n\t\t\t\t\t\t\t\t\t\t\t\tctx.lineTo(fillPoint.x, fillPoint.y);\n\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\tctx.lineTo(previous._view.x, fillPoint);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tif (lastDrawnIndex !== index - 1) {\n\t\t\t\t\t\t\t\t\t\t\t// There was a gap and this is the first point after the gap. If we've never drawn a point, this is a special case.\n\t\t\t\t\t\t\t\t\t\t\t// If the first data point is NaN, then there is no real gap to skip\n\t\t\t\t\t\t\t\t\t\t\tif (spanGaps && lastDrawnIndex !== -1) {\n\t\t\t\t\t\t\t\t\t\t\t\t// We are spanning the gap, so simple draw a line to this point\n\t\t\t\t\t\t\t\t\t\t\t\tlineToPoint(previous, current);\n\t\t\t\t\t\t\t\t\t\t\t} else if (loop) {\n\t\t\t\t\t\t\t\t\t\t\t\tctx.lineTo(currentVM.x, currentVM.y);\n\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\tctx.lineTo(currentVM.x, fillPoint);\n\t\t\t\t\t\t\t\t\t\t\t\tctx.lineTo(currentVM.x, currentVM.y);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t// Line to next point\n\t\t\t\t\t\t\t\t\t\t\tlineToPoint(previous, current);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tlastDrawnIndex = index;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (!loop && lastDrawnIndex !== -1) {\n\t\t\t\t\t\t\t\tctx.lineTo(points[lastDrawnIndex]._view.x, fillPoint);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tctx.fillStyle = vm.backgroundColor || globalDefaults.defaultColor;\n\t\t\t\t\t\t\tctx.closePath();\n\t\t\t\t\t\t\tctx.fill();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Stroke Line Options\n\t\t\t\t\t\tvar globalOptionLineElements = globalDefaults.elements.line;\n\t\t\t\t\t\tctx.lineCap = vm.borderCapStyle || globalOptionLineElements.borderCapStyle;\n\n\t\t\t\t\t\t// IE 9 and 10 do not support line dash\n\t\t\t\t\t\tif (ctx.setLineDash) {\n\t\t\t\t\t\t\tctx.setLineDash(vm.borderDash || globalOptionLineElements.borderDash);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tctx.lineDashOffset = vm.borderDashOffset || globalOptionLineElements.borderDashOffset;\n\t\t\t\t\t\tctx.lineJoin = vm.borderJoinStyle || globalOptionLineElements.borderJoinStyle;\n\t\t\t\t\t\tctx.lineWidth = vm.borderWidth || globalOptionLineElements.borderWidth;\n\t\t\t\t\t\tctx.strokeStyle = vm.borderColor || globalDefaults.defaultColor;\n\n\t\t\t\t\t\t// Stroke Line\n\t\t\t\t\t\tctx.beginPath();\n\t\t\t\t\t\tlastDrawnIndex = -1;\n\n\t\t\t\t\t\tfor (index = 0; index < points.length; ++index) {\n\t\t\t\t\t\t\tcurrent = points[index];\n\t\t\t\t\t\t\tprevious = helpers.previousItem(points, index);\n\t\t\t\t\t\t\tcurrentVM = current._view;\n\n\t\t\t\t\t\t\t// First point moves to it's starting position no matter what\n\t\t\t\t\t\t\tif (index === 0) {\n\t\t\t\t\t\t\t\tif (!currentVM.skip) {\n\t\t\t\t\t\t\t\t\tctx.moveTo(currentVM.x, currentVM.y);\n\t\t\t\t\t\t\t\t\tlastDrawnIndex = index;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tprevious = lastDrawnIndex === -1 ? previous : points[lastDrawnIndex];\n\n\t\t\t\t\t\t\t\tif (!currentVM.skip) {\n\t\t\t\t\t\t\t\t\tif (lastDrawnIndex !== index - 1 && !spanGaps || lastDrawnIndex === -1) {\n\t\t\t\t\t\t\t\t\t\t// There was a gap and this is the first point after the gap\n\t\t\t\t\t\t\t\t\t\tctx.moveTo(currentVM.x, currentVM.y);\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t// Line to next point\n\t\t\t\t\t\t\t\t\t\tlineToPoint(previous, current);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tlastDrawnIndex = index;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tctx.stroke();\n\t\t\t\t\t\tctx.restore();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t};\n\t\t}, {}], 39: [function (require, module, exports) {\n\t\t\t'use strict';\n\n\t\t\tmodule.exports = function (Chart) {\n\n\t\t\t\tvar helpers = Chart.helpers,\n\t\t\t\t    globalOpts = Chart.defaults.global,\n\t\t\t\t    defaultColor = globalOpts.defaultColor;\n\n\t\t\t\tglobalOpts.elements.point = {\n\t\t\t\t\tradius: 3,\n\t\t\t\t\tpointStyle: 'circle',\n\t\t\t\t\tbackgroundColor: defaultColor,\n\t\t\t\t\tborderWidth: 1,\n\t\t\t\t\tborderColor: defaultColor,\n\t\t\t\t\t// Hover\n\t\t\t\t\thitRadius: 1,\n\t\t\t\t\thoverRadius: 4,\n\t\t\t\t\thoverBorderWidth: 1\n\t\t\t\t};\n\n\t\t\t\tfunction xRange(mouseX) {\n\t\t\t\t\tvar vm = this._view;\n\t\t\t\t\treturn vm ? Math.pow(mouseX - vm.x, 2) < Math.pow(vm.radius + vm.hitRadius, 2) : false;\n\t\t\t\t}\n\n\t\t\t\tfunction yRange(mouseY) {\n\t\t\t\t\tvar vm = this._view;\n\t\t\t\t\treturn vm ? Math.pow(mouseY - vm.y, 2) < Math.pow(vm.radius + vm.hitRadius, 2) : false;\n\t\t\t\t}\n\n\t\t\t\tChart.elements.Point = Chart.Element.extend({\n\t\t\t\t\tinRange: function inRange(mouseX, mouseY) {\n\t\t\t\t\t\tvar vm = this._view;\n\t\t\t\t\t\treturn vm ? Math.pow(mouseX - vm.x, 2) + Math.pow(mouseY - vm.y, 2) < Math.pow(vm.hitRadius + vm.radius, 2) : false;\n\t\t\t\t\t},\n\n\t\t\t\t\tinLabelRange: xRange,\n\t\t\t\t\tinXRange: xRange,\n\t\t\t\t\tinYRange: yRange,\n\n\t\t\t\t\tgetCenterPoint: function getCenterPoint() {\n\t\t\t\t\t\tvar vm = this._view;\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tx: vm.x,\n\t\t\t\t\t\t\ty: vm.y\n\t\t\t\t\t\t};\n\t\t\t\t\t},\n\t\t\t\t\tgetArea: function getArea() {\n\t\t\t\t\t\treturn Math.PI * Math.pow(this._view.radius, 2);\n\t\t\t\t\t},\n\t\t\t\t\ttooltipPosition: function tooltipPosition() {\n\t\t\t\t\t\tvar vm = this._view;\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tx: vm.x,\n\t\t\t\t\t\t\ty: vm.y,\n\t\t\t\t\t\t\tpadding: vm.radius + vm.borderWidth\n\t\t\t\t\t\t};\n\t\t\t\t\t},\n\t\t\t\t\tdraw: function draw(chartArea) {\n\t\t\t\t\t\tvar vm = this._view;\n\t\t\t\t\t\tvar model = this._model;\n\t\t\t\t\t\tvar ctx = this._chart.ctx;\n\t\t\t\t\t\tvar pointStyle = vm.pointStyle;\n\t\t\t\t\t\tvar radius = vm.radius;\n\t\t\t\t\t\tvar x = vm.x;\n\t\t\t\t\t\tvar y = vm.y;\n\t\t\t\t\t\tvar color = Chart.helpers.color;\n\t\t\t\t\t\tvar errMargin = 1.01; // 1.01 is margin for Accumulated error. (Especially Edge, IE.)\n\t\t\t\t\t\tvar ratio = 0;\n\n\t\t\t\t\t\tif (vm.skip) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tctx.strokeStyle = vm.borderColor || defaultColor;\n\t\t\t\t\t\tctx.lineWidth = helpers.getValueOrDefault(vm.borderWidth, globalOpts.elements.point.borderWidth);\n\t\t\t\t\t\tctx.fillStyle = vm.backgroundColor || defaultColor;\n\n\t\t\t\t\t\t// Cliping for Points.\n\t\t\t\t\t\t// going out from inner charArea?\n\t\t\t\t\t\tif (chartArea !== undefined && (model.x < chartArea.left || chartArea.right * errMargin < model.x || model.y < chartArea.top || chartArea.bottom * errMargin < model.y)) {\n\t\t\t\t\t\t\t// Point fade out\n\t\t\t\t\t\t\tif (model.x < chartArea.left) {\n\t\t\t\t\t\t\t\tratio = (x - model.x) / (chartArea.left - model.x);\n\t\t\t\t\t\t\t} else if (chartArea.right * errMargin < model.x) {\n\t\t\t\t\t\t\t\tratio = (model.x - x) / (model.x - chartArea.right);\n\t\t\t\t\t\t\t} else if (model.y < chartArea.top) {\n\t\t\t\t\t\t\t\tratio = (y - model.y) / (chartArea.top - model.y);\n\t\t\t\t\t\t\t} else if (chartArea.bottom * errMargin < model.y) {\n\t\t\t\t\t\t\t\tratio = (model.y - y) / (model.y - chartArea.bottom);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tratio = Math.round(ratio * 100) / 100;\n\t\t\t\t\t\t\tctx.strokeStyle = color(ctx.strokeStyle).alpha(ratio).rgbString();\n\t\t\t\t\t\t\tctx.fillStyle = color(ctx.fillStyle).alpha(ratio).rgbString();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tChart.canvasHelpers.drawPoint(ctx, pointStyle, radius, x, y);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t};\n\t\t}, {}], 40: [function (require, module, exports) {\n\t\t\t'use strict';\n\n\t\t\tmodule.exports = function (Chart) {\n\n\t\t\t\tvar globalOpts = Chart.defaults.global;\n\n\t\t\t\tglobalOpts.elements.rectangle = {\n\t\t\t\t\tbackgroundColor: globalOpts.defaultColor,\n\t\t\t\t\tborderWidth: 0,\n\t\t\t\t\tborderColor: globalOpts.defaultColor,\n\t\t\t\t\tborderSkipped: 'bottom'\n\t\t\t\t};\n\n\t\t\t\tfunction isVertical(bar) {\n\t\t\t\t\treturn bar._view.width !== undefined;\n\t\t\t\t}\n\n\t\t\t\t/**\n     * Helper function to get the bounds of the bar regardless of the orientation\n     * @private\n     * @param bar {Chart.Element.Rectangle} the bar\n     * @return {Bounds} bounds of the bar\n     */\n\t\t\t\tfunction getBarBounds(bar) {\n\t\t\t\t\tvar vm = bar._view;\n\t\t\t\t\tvar x1, x2, y1, y2;\n\n\t\t\t\t\tif (isVertical(bar)) {\n\t\t\t\t\t\t// vertical\n\t\t\t\t\t\tvar halfWidth = vm.width / 2;\n\t\t\t\t\t\tx1 = vm.x - halfWidth;\n\t\t\t\t\t\tx2 = vm.x + halfWidth;\n\t\t\t\t\t\ty1 = Math.min(vm.y, vm.base);\n\t\t\t\t\t\ty2 = Math.max(vm.y, vm.base);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// horizontal bar\n\t\t\t\t\t\tvar halfHeight = vm.height / 2;\n\t\t\t\t\t\tx1 = Math.min(vm.x, vm.base);\n\t\t\t\t\t\tx2 = Math.max(vm.x, vm.base);\n\t\t\t\t\t\ty1 = vm.y - halfHeight;\n\t\t\t\t\t\ty2 = vm.y + halfHeight;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn {\n\t\t\t\t\t\tleft: x1,\n\t\t\t\t\t\ttop: y1,\n\t\t\t\t\t\tright: x2,\n\t\t\t\t\t\tbottom: y2\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\tChart.elements.Rectangle = Chart.Element.extend({\n\t\t\t\t\tdraw: function draw() {\n\t\t\t\t\t\tvar ctx = this._chart.ctx;\n\t\t\t\t\t\tvar vm = this._view;\n\t\t\t\t\t\tvar left, right, top, bottom, signX, signY, borderSkipped;\n\t\t\t\t\t\tvar borderWidth = vm.borderWidth;\n\n\t\t\t\t\t\tif (!vm.horizontal) {\n\t\t\t\t\t\t\t// bar\n\t\t\t\t\t\t\tleft = vm.x - vm.width / 2;\n\t\t\t\t\t\t\tright = vm.x + vm.width / 2;\n\t\t\t\t\t\t\ttop = vm.y;\n\t\t\t\t\t\t\tbottom = vm.base;\n\t\t\t\t\t\t\tsignX = 1;\n\t\t\t\t\t\t\tsignY = bottom > top ? 1 : -1;\n\t\t\t\t\t\t\tborderSkipped = vm.borderSkipped || 'bottom';\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// horizontal bar\n\t\t\t\t\t\t\tleft = vm.base;\n\t\t\t\t\t\t\tright = vm.x;\n\t\t\t\t\t\t\ttop = vm.y - vm.height / 2;\n\t\t\t\t\t\t\tbottom = vm.y + vm.height / 2;\n\t\t\t\t\t\t\tsignX = right > left ? 1 : -1;\n\t\t\t\t\t\t\tsignY = 1;\n\t\t\t\t\t\t\tborderSkipped = vm.borderSkipped || 'left';\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Canvas doesn't allow us to stroke inside the width so we can\n\t\t\t\t\t\t// adjust the sizes to fit if we're setting a stroke on the line\n\t\t\t\t\t\tif (borderWidth) {\n\t\t\t\t\t\t\t// borderWidth shold be less than bar width and bar height.\n\t\t\t\t\t\t\tvar barSize = Math.min(Math.abs(left - right), Math.abs(top - bottom));\n\t\t\t\t\t\t\tborderWidth = borderWidth > barSize ? barSize : borderWidth;\n\t\t\t\t\t\t\tvar halfStroke = borderWidth / 2;\n\t\t\t\t\t\t\t// Adjust borderWidth when bar top position is near vm.base(zero).\n\t\t\t\t\t\t\tvar borderLeft = left + (borderSkipped !== 'left' ? halfStroke * signX : 0);\n\t\t\t\t\t\t\tvar borderRight = right + (borderSkipped !== 'right' ? -halfStroke * signX : 0);\n\t\t\t\t\t\t\tvar borderTop = top + (borderSkipped !== 'top' ? halfStroke * signY : 0);\n\t\t\t\t\t\t\tvar borderBottom = bottom + (borderSkipped !== 'bottom' ? -halfStroke * signY : 0);\n\t\t\t\t\t\t\t// not become a vertical line?\n\t\t\t\t\t\t\tif (borderLeft !== borderRight) {\n\t\t\t\t\t\t\t\ttop = borderTop;\n\t\t\t\t\t\t\t\tbottom = borderBottom;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// not become a horizontal line?\n\t\t\t\t\t\t\tif (borderTop !== borderBottom) {\n\t\t\t\t\t\t\t\tleft = borderLeft;\n\t\t\t\t\t\t\t\tright = borderRight;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tctx.beginPath();\n\t\t\t\t\t\tctx.fillStyle = vm.backgroundColor;\n\t\t\t\t\t\tctx.strokeStyle = vm.borderColor;\n\t\t\t\t\t\tctx.lineWidth = borderWidth;\n\n\t\t\t\t\t\t// Corner points, from bottom-left to bottom-right clockwise\n\t\t\t\t\t\t// | 1 2 |\n\t\t\t\t\t\t// | 0 3 |\n\t\t\t\t\t\tvar corners = [[left, bottom], [left, top], [right, top], [right, bottom]];\n\n\t\t\t\t\t\t// Find first (starting) corner with fallback to 'bottom'\n\t\t\t\t\t\tvar borders = ['bottom', 'left', 'top', 'right'];\n\t\t\t\t\t\tvar startCorner = borders.indexOf(borderSkipped, 0);\n\t\t\t\t\t\tif (startCorner === -1) {\n\t\t\t\t\t\t\tstartCorner = 0;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfunction cornerAt(index) {\n\t\t\t\t\t\t\treturn corners[(startCorner + index) % 4];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Draw rectangle from 'startCorner'\n\t\t\t\t\t\tvar corner = cornerAt(0);\n\t\t\t\t\t\tctx.moveTo(corner[0], corner[1]);\n\n\t\t\t\t\t\tfor (var i = 1; i < 4; i++) {\n\t\t\t\t\t\t\tcorner = cornerAt(i);\n\t\t\t\t\t\t\tctx.lineTo(corner[0], corner[1]);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tctx.fill();\n\t\t\t\t\t\tif (borderWidth) {\n\t\t\t\t\t\t\tctx.stroke();\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\theight: function height() {\n\t\t\t\t\t\tvar vm = this._view;\n\t\t\t\t\t\treturn vm.base - vm.y;\n\t\t\t\t\t},\n\t\t\t\t\tinRange: function inRange(mouseX, mouseY) {\n\t\t\t\t\t\tvar inRange = false;\n\n\t\t\t\t\t\tif (this._view) {\n\t\t\t\t\t\t\tvar bounds = getBarBounds(this);\n\t\t\t\t\t\t\tinRange = mouseX >= bounds.left && mouseX <= bounds.right && mouseY >= bounds.top && mouseY <= bounds.bottom;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn inRange;\n\t\t\t\t\t},\n\t\t\t\t\tinLabelRange: function inLabelRange(mouseX, mouseY) {\n\t\t\t\t\t\tvar me = this;\n\t\t\t\t\t\tif (!me._view) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar inRange = false;\n\t\t\t\t\t\tvar bounds = getBarBounds(me);\n\n\t\t\t\t\t\tif (isVertical(me)) {\n\t\t\t\t\t\t\tinRange = mouseX >= bounds.left && mouseX <= bounds.right;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tinRange = mouseY >= bounds.top && mouseY <= bounds.bottom;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn inRange;\n\t\t\t\t\t},\n\t\t\t\t\tinXRange: function inXRange(mouseX) {\n\t\t\t\t\t\tvar bounds = getBarBounds(this);\n\t\t\t\t\t\treturn mouseX >= bounds.left && mouseX <= bounds.right;\n\t\t\t\t\t},\n\t\t\t\t\tinYRange: function inYRange(mouseY) {\n\t\t\t\t\t\tvar bounds = getBarBounds(this);\n\t\t\t\t\t\treturn mouseY >= bounds.top && mouseY <= bounds.bottom;\n\t\t\t\t\t},\n\t\t\t\t\tgetCenterPoint: function getCenterPoint() {\n\t\t\t\t\t\tvar vm = this._view;\n\t\t\t\t\t\tvar x, y;\n\t\t\t\t\t\tif (isVertical(this)) {\n\t\t\t\t\t\t\tx = vm.x;\n\t\t\t\t\t\t\ty = (vm.y + vm.base) / 2;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tx = (vm.x + vm.base) / 2;\n\t\t\t\t\t\t\ty = vm.y;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn { x: x, y: y };\n\t\t\t\t\t},\n\t\t\t\t\tgetArea: function getArea() {\n\t\t\t\t\t\tvar vm = this._view;\n\t\t\t\t\t\treturn vm.width * Math.abs(vm.y - vm.base);\n\t\t\t\t\t},\n\t\t\t\t\ttooltipPosition: function tooltipPosition() {\n\t\t\t\t\t\tvar vm = this._view;\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tx: vm.x,\n\t\t\t\t\t\t\ty: vm.y\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t};\n\t\t}, {}], 41: [function (require, module, exports) {\n\t\t\t'use strict';\n\n\t\t\t// Chart.Platform implementation for targeting a web browser\n\n\t\t\tmodule.exports = function (Chart) {\n\t\t\t\tvar helpers = Chart.helpers;\n\n\t\t\t\t// DOM event types -> Chart.js event types.\n\t\t\t\t// Note: only events with different types are mapped.\n\t\t\t\t// https://developer.mozilla.org/en-US/docs/Web/Events\n\t\t\t\tvar eventTypeMap = {\n\t\t\t\t\t// Touch events\n\t\t\t\t\ttouchstart: 'mousedown',\n\t\t\t\t\ttouchmove: 'mousemove',\n\t\t\t\t\ttouchend: 'mouseup',\n\n\t\t\t\t\t// Pointer events\n\t\t\t\t\tpointerenter: 'mouseenter',\n\t\t\t\t\tpointerdown: 'mousedown',\n\t\t\t\t\tpointermove: 'mousemove',\n\t\t\t\t\tpointerup: 'mouseup',\n\t\t\t\t\tpointerleave: 'mouseout',\n\t\t\t\t\tpointerout: 'mouseout'\n\t\t\t\t};\n\n\t\t\t\t/**\n     * The \"used\" size is the final value of a dimension property after all calculations have\n     * been performed. This method uses the computed style of `element` but returns undefined\n     * if the computed style is not expressed in pixels. That can happen in some cases where\n     * `element` has a size relative to its parent and this last one is not yet displayed,\n     * for example because of `display: none` on a parent node.\n     * @see https://developer.mozilla.org/en-US/docs/Web/CSS/used_value\n     * @returns {Number} Size in pixels or undefined if unknown.\n     */\n\t\t\t\tfunction readUsedSize(element, property) {\n\t\t\t\t\tvar value = helpers.getStyle(element, property);\n\t\t\t\t\tvar matches = value && value.match(/(\\d+)px/);\n\t\t\t\t\treturn matches ? Number(matches[1]) : undefined;\n\t\t\t\t}\n\n\t\t\t\t/**\n     * Initializes the canvas style and render size without modifying the canvas display size,\n     * since responsiveness is handled by the controller.resize() method. The config is used\n     * to determine the aspect ratio to apply in case no explicit height has been specified.\n     */\n\t\t\t\tfunction initCanvas(canvas, config) {\n\t\t\t\t\tvar style = canvas.style;\n\n\t\t\t\t\t// NOTE(SB) canvas.getAttribute('width') !== canvas.width: in the first case it\n\t\t\t\t\t// returns null or '' if no explicit value has been set to the canvas attribute.\n\t\t\t\t\tvar renderHeight = canvas.getAttribute('height');\n\t\t\t\t\tvar renderWidth = canvas.getAttribute('width');\n\n\t\t\t\t\t// Chart.js modifies some canvas values that we want to restore on destroy\n\t\t\t\t\tcanvas._chartjs = {\n\t\t\t\t\t\tinitial: {\n\t\t\t\t\t\t\theight: renderHeight,\n\t\t\t\t\t\t\twidth: renderWidth,\n\t\t\t\t\t\t\tstyle: {\n\t\t\t\t\t\t\t\tdisplay: style.display,\n\t\t\t\t\t\t\t\theight: style.height,\n\t\t\t\t\t\t\t\twidth: style.width\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\n\t\t\t\t\t// Force canvas to display as block to avoid extra space caused by inline\n\t\t\t\t\t// elements, which would interfere with the responsive resize process.\n\t\t\t\t\t// https://github.com/chartjs/Chart.js/issues/2538\n\t\t\t\t\tstyle.display = style.display || 'block';\n\n\t\t\t\t\tif (renderWidth === null || renderWidth === '') {\n\t\t\t\t\t\tvar displayWidth = readUsedSize(canvas, 'width');\n\t\t\t\t\t\tif (displayWidth !== undefined) {\n\t\t\t\t\t\t\tcanvas.width = displayWidth;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (renderHeight === null || renderHeight === '') {\n\t\t\t\t\t\tif (canvas.style.height === '') {\n\t\t\t\t\t\t\t// If no explicit render height and style height, let's apply the aspect ratio,\n\t\t\t\t\t\t\t// which one can be specified by the user but also by charts as default option\n\t\t\t\t\t\t\t// (i.e. options.aspectRatio). If not specified, use canvas aspect ratio of 2.\n\t\t\t\t\t\t\tcanvas.height = canvas.width / (config.options.aspectRatio || 2);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tvar displayHeight = readUsedSize(canvas, 'height');\n\t\t\t\t\t\t\tif (displayWidth !== undefined) {\n\t\t\t\t\t\t\t\tcanvas.height = displayHeight;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn canvas;\n\t\t\t\t}\n\n\t\t\t\tfunction createEvent(type, chart, x, y, native) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\ttype: type,\n\t\t\t\t\t\tchart: chart,\n\t\t\t\t\t\tnative: native || null,\n\t\t\t\t\t\tx: x !== undefined ? x : null,\n\t\t\t\t\t\ty: y !== undefined ? y : null\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\tfunction fromNativeEvent(event, chart) {\n\t\t\t\t\tvar type = eventTypeMap[event.type] || event.type;\n\t\t\t\t\tvar pos = helpers.getRelativePosition(event, chart);\n\t\t\t\t\treturn createEvent(type, chart, pos.x, pos.y, event);\n\t\t\t\t}\n\n\t\t\t\tfunction createResizer(handler) {\n\t\t\t\t\tvar iframe = document.createElement('iframe');\n\t\t\t\t\tiframe.className = 'chartjs-hidden-iframe';\n\t\t\t\t\tiframe.style.cssText = 'display:block;' + 'overflow:hidden;' + 'border:0;' + 'margin:0;' + 'top:0;' + 'left:0;' + 'bottom:0;' + 'right:0;' + 'height:100%;' + 'width:100%;' + 'position:absolute;' + 'pointer-events:none;' + 'z-index:-1;';\n\n\t\t\t\t\t// Prevent the iframe to gain focus on tab.\n\t\t\t\t\t// https://github.com/chartjs/Chart.js/issues/3090\n\t\t\t\t\tiframe.tabIndex = -1;\n\n\t\t\t\t\t// If the iframe is re-attached to the DOM, the resize listener is removed because the\n\t\t\t\t\t// content is reloaded, so make sure to install the handler after the iframe is loaded.\n\t\t\t\t\t// https://github.com/chartjs/Chart.js/issues/3521\n\t\t\t\t\thelpers.addEvent(iframe, 'load', function () {\n\t\t\t\t\t\thelpers.addEvent(iframe.contentWindow || iframe, 'resize', handler);\n\n\t\t\t\t\t\t// The iframe size might have changed while loading, which can also\n\t\t\t\t\t\t// happen if the size has been changed while detached from the DOM.\n\t\t\t\t\t\thandler();\n\t\t\t\t\t});\n\n\t\t\t\t\treturn iframe;\n\t\t\t\t}\n\n\t\t\t\tfunction addResizeListener(node, listener, chart) {\n\t\t\t\t\tvar stub = node._chartjs = {\n\t\t\t\t\t\tticking: false\n\t\t\t\t\t};\n\n\t\t\t\t\t// Throttle the callback notification until the next animation frame.\n\t\t\t\t\tvar notify = function notify() {\n\t\t\t\t\t\tif (!stub.ticking) {\n\t\t\t\t\t\t\tstub.ticking = true;\n\t\t\t\t\t\t\thelpers.requestAnimFrame.call(window, function () {\n\t\t\t\t\t\t\t\tif (stub.resizer) {\n\t\t\t\t\t\t\t\t\tstub.ticking = false;\n\t\t\t\t\t\t\t\t\treturn listener(createEvent('resize', chart));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\n\t\t\t\t\t// Let's keep track of this added iframe and thus avoid DOM query when removing it.\n\t\t\t\t\tstub.resizer = createResizer(notify);\n\n\t\t\t\t\tnode.insertBefore(stub.resizer, node.firstChild);\n\t\t\t\t}\n\n\t\t\t\tfunction removeResizeListener(node) {\n\t\t\t\t\tif (!node || !node._chartjs) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar resizer = node._chartjs.resizer;\n\t\t\t\t\tif (resizer) {\n\t\t\t\t\t\tresizer.parentNode.removeChild(resizer);\n\t\t\t\t\t\tnode._chartjs.resizer = null;\n\t\t\t\t\t}\n\n\t\t\t\t\tdelete node._chartjs;\n\t\t\t\t}\n\n\t\t\t\treturn {\n\t\t\t\t\tacquireContext: function acquireContext(item, config) {\n\t\t\t\t\t\tif (typeof item === 'string') {\n\t\t\t\t\t\t\titem = document.getElementById(item);\n\t\t\t\t\t\t} else if (item.length) {\n\t\t\t\t\t\t\t// Support for array based queries (such as jQuery)\n\t\t\t\t\t\t\titem = item[0];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (item && item.canvas) {\n\t\t\t\t\t\t\t// Support for any object associated to a canvas (including a context2d)\n\t\t\t\t\t\t\titem = item.canvas;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (item instanceof HTMLCanvasElement) {\n\t\t\t\t\t\t\t// To prevent canvas fingerprinting, some add-ons undefine the getContext\n\t\t\t\t\t\t\t// method, for example: https://github.com/kkapsner/CanvasBlocker\n\t\t\t\t\t\t\t// https://github.com/chartjs/Chart.js/issues/2807\n\t\t\t\t\t\t\tvar context = item.getContext && item.getContext('2d');\n\t\t\t\t\t\t\tif (context instanceof CanvasRenderingContext2D) {\n\t\t\t\t\t\t\t\tinitCanvas(item, config);\n\t\t\t\t\t\t\t\treturn context;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t},\n\n\t\t\t\t\treleaseContext: function releaseContext(context) {\n\t\t\t\t\t\tvar canvas = context.canvas;\n\t\t\t\t\t\tif (!canvas._chartjs) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar initial = canvas._chartjs.initial;\n\t\t\t\t\t\t['height', 'width'].forEach(function (prop) {\n\t\t\t\t\t\t\tvar value = initial[prop];\n\t\t\t\t\t\t\tif (value === undefined || value === null) {\n\t\t\t\t\t\t\t\tcanvas.removeAttribute(prop);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tcanvas.setAttribute(prop, value);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\thelpers.each(initial.style || {}, function (value, key) {\n\t\t\t\t\t\t\tcanvas.style[key] = value;\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\t// The canvas render size might have been changed (and thus the state stack discarded),\n\t\t\t\t\t\t// we can't use save() and restore() to restore the initial state. So make sure that at\n\t\t\t\t\t\t// least the canvas context is reset to the default state by setting the canvas width.\n\t\t\t\t\t\t// https://www.w3.org/TR/2011/WD-html5-20110525/the-canvas-element.html\n\t\t\t\t\t\tcanvas.width = canvas.width;\n\n\t\t\t\t\t\tdelete canvas._chartjs;\n\t\t\t\t\t},\n\n\t\t\t\t\taddEventListener: function addEventListener(chart, type, listener) {\n\t\t\t\t\t\tvar canvas = chart.chart.canvas;\n\t\t\t\t\t\tif (type === 'resize') {\n\t\t\t\t\t\t\t// Note: the resize event is not supported on all browsers.\n\t\t\t\t\t\t\taddResizeListener(canvas.parentNode, listener, chart.chart);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar stub = listener._chartjs || (listener._chartjs = {});\n\t\t\t\t\t\tvar proxies = stub.proxies || (stub.proxies = {});\n\t\t\t\t\t\tvar proxy = proxies[chart.id + '_' + type] = function (event) {\n\t\t\t\t\t\t\tlistener(fromNativeEvent(event, chart.chart));\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\thelpers.addEvent(canvas, type, proxy);\n\t\t\t\t\t},\n\n\t\t\t\t\tremoveEventListener: function removeEventListener(chart, type, listener) {\n\t\t\t\t\t\tvar canvas = chart.chart.canvas;\n\t\t\t\t\t\tif (type === 'resize') {\n\t\t\t\t\t\t\t// Note: the resize event is not supported on all browsers.\n\t\t\t\t\t\t\tremoveResizeListener(canvas.parentNode, listener);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar stub = listener._chartjs || {};\n\t\t\t\t\t\tvar proxies = stub.proxies || {};\n\t\t\t\t\t\tvar proxy = proxies[chart.id + '_' + type];\n\t\t\t\t\t\tif (!proxy) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\thelpers.removeEvent(canvas, type, proxy);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t};\n\t\t}, {}], 42: [function (require, module, exports) {\n\t\t\t'use strict';\n\n\t\t\t// By default, select the browser (DOM) platform.\n\t\t\t// @TODO Make possible to select another platform at build time.\n\n\t\t\tvar implementation = require(41);\n\n\t\t\tmodule.exports = function (Chart) {\n\t\t\t\t/**\n     * @namespace Chart.platform\n     * @see https://chartjs.gitbooks.io/proposals/content/Platform.html\n     * @since 2.4.0\n     */\n\t\t\t\tChart.platform = {\n\t\t\t\t\t/**\n      * Called at chart construction time, returns a context2d instance implementing\n      * the [W3C Canvas 2D Context API standard]{@link https://www.w3.org/TR/2dcontext/}.\n      * @param {*} item - The native item from which to acquire context (platform specific)\n      * @param {Object} options - The chart options\n      * @returns {CanvasRenderingContext2D} context2d instance\n      */\n\t\t\t\t\tacquireContext: function acquireContext() {},\n\n\t\t\t\t\t/**\n      * Called at chart destruction time, releases any resources associated to the context\n      * previously returned by the acquireContext() method.\n      * @param {CanvasRenderingContext2D} context - The context2d instance\n      * @returns {Boolean} true if the method succeeded, else false\n      */\n\t\t\t\t\treleaseContext: function releaseContext() {},\n\n\t\t\t\t\t/**\n      * Registers the specified listener on the given chart.\n      * @param {Chart} chart - Chart from which to listen for event\n      * @param {String} type - The ({@link IEvent}) type to listen for\n      * @param {Function} listener - Receives a notification (an object that implements\n      * the {@link IEvent} interface) when an event of the specified type occurs.\n      */\n\t\t\t\t\taddEventListener: function addEventListener() {},\n\n\t\t\t\t\t/**\n      * Removes the specified listener previously registered with addEventListener.\n      * @param {Chart} chart -Chart from which to remove the listener\n      * @param {String} type - The ({@link IEvent}) type to remove\n      * @param {Function} listener - The listener function to remove from the event target.\n      */\n\t\t\t\t\tremoveEventListener: function removeEventListener() {}\n\t\t\t\t};\n\n\t\t\t\t/**\n     * @interface IPlatform\n     * Allows abstracting platform dependencies away from the chart\n     * @borrows Chart.platform.acquireContext as acquireContext\n     * @borrows Chart.platform.releaseContext as releaseContext\n     * @borrows Chart.platform.addEventListener as addEventListener\n     * @borrows Chart.platform.removeEventListener as removeEventListener\n     */\n\n\t\t\t\t/**\n     * @interface IEvent\n     * @prop {String} type - The event type name, possible values are:\n     * 'contextmenu', 'mouseenter', 'mousedown', 'mousemove', 'mouseup', 'mouseout',\n     * 'click', 'dblclick', 'keydown', 'keypress', 'keyup' and 'resize'\n     * @prop {*} native - The original native event (null for emulated events, e.g. 'resize')\n     * @prop {Number} x - The mouse x position, relative to the canvas (null for incompatible events)\n     * @prop {Number} y - The mouse y position, relative to the canvas (null for incompatible events)\n     */\n\n\t\t\t\tChart.helpers.extend(Chart.platform, implementation(Chart));\n\t\t\t};\n\t\t}, { \"41\": 41 }], 43: [function (require, module, exports) {\n\t\t\t'use strict';\n\n\t\t\tmodule.exports = function (Chart) {\n\n\t\t\t\tvar helpers = Chart.helpers;\n\t\t\t\t// Default config for a category scale\n\t\t\t\tvar defaultConfig = {\n\t\t\t\t\tposition: 'bottom'\n\t\t\t\t};\n\n\t\t\t\tvar DatasetScale = Chart.Scale.extend({\n\t\t\t\t\t/**\n     * Internal function to get the correct labels. If data.xLabels or data.yLabels are defined, use those\n     * else fall back to data.labels\n     * @private\n     */\n\t\t\t\t\tgetLabels: function getLabels() {\n\t\t\t\t\t\tvar data = this.chart.data;\n\t\t\t\t\t\treturn (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels;\n\t\t\t\t\t},\n\t\t\t\t\t// Implement this so that\n\t\t\t\t\tdetermineDataLimits: function determineDataLimits() {\n\t\t\t\t\t\tvar me = this;\n\t\t\t\t\t\tvar labels = me.getLabels();\n\t\t\t\t\t\tme.minIndex = 0;\n\t\t\t\t\t\tme.maxIndex = labels.length - 1;\n\t\t\t\t\t\tvar findIndex;\n\n\t\t\t\t\t\tif (me.options.ticks.min !== undefined) {\n\t\t\t\t\t\t\t// user specified min value\n\t\t\t\t\t\t\tfindIndex = helpers.indexOf(labels, me.options.ticks.min);\n\t\t\t\t\t\t\tme.minIndex = findIndex !== -1 ? findIndex : me.minIndex;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (me.options.ticks.max !== undefined) {\n\t\t\t\t\t\t\t// user specified max value\n\t\t\t\t\t\t\tfindIndex = helpers.indexOf(labels, me.options.ticks.max);\n\t\t\t\t\t\t\tme.maxIndex = findIndex !== -1 ? findIndex : me.maxIndex;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tme.min = labels[me.minIndex];\n\t\t\t\t\t\tme.max = labels[me.maxIndex];\n\t\t\t\t\t},\n\n\t\t\t\t\tbuildTicks: function buildTicks() {\n\t\t\t\t\t\tvar me = this;\n\t\t\t\t\t\tvar labels = me.getLabels();\n\t\t\t\t\t\t// If we are viewing some subset of labels, slice the original array\n\t\t\t\t\t\tme.ticks = me.minIndex === 0 && me.maxIndex === labels.length - 1 ? labels : labels.slice(me.minIndex, me.maxIndex + 1);\n\t\t\t\t\t},\n\n\t\t\t\t\tgetLabelForIndex: function getLabelForIndex(index, datasetIndex) {\n\t\t\t\t\t\tvar me = this;\n\t\t\t\t\t\tvar data = me.chart.data;\n\t\t\t\t\t\tvar isHorizontal = me.isHorizontal();\n\n\t\t\t\t\t\tif (data.yLabels && !isHorizontal) {\n\t\t\t\t\t\t\treturn me.getRightValue(data.datasets[datasetIndex].data[index]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn me.ticks[index - me.minIndex];\n\t\t\t\t\t},\n\n\t\t\t\t\t// Used to get data value locations.  Value can either be an index or a numerical value\n\t\t\t\t\tgetPixelForValue: function getPixelForValue(value, index, datasetIndex, includeOffset) {\n\t\t\t\t\t\tvar me = this;\n\t\t\t\t\t\t// 1 is added because we need the length but we have the indexes\n\t\t\t\t\t\tvar offsetAmt = Math.max(me.maxIndex + 1 - me.minIndex - (me.options.gridLines.offsetGridLines ? 0 : 1), 1);\n\n\t\t\t\t\t\tif (value !== undefined && isNaN(index)) {\n\t\t\t\t\t\t\tvar labels = me.getLabels();\n\t\t\t\t\t\t\tvar idx = labels.indexOf(value);\n\t\t\t\t\t\t\tindex = idx !== -1 ? idx : index;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (me.isHorizontal()) {\n\t\t\t\t\t\t\tvar valueWidth = me.width / offsetAmt;\n\t\t\t\t\t\t\tvar widthOffset = valueWidth * (index - me.minIndex);\n\n\t\t\t\t\t\t\tif (me.options.gridLines.offsetGridLines && includeOffset || me.maxIndex === me.minIndex && includeOffset) {\n\t\t\t\t\t\t\t\twidthOffset += valueWidth / 2;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treturn me.left + Math.round(widthOffset);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvar valueHeight = me.height / offsetAmt;\n\t\t\t\t\t\tvar heightOffset = valueHeight * (index - me.minIndex);\n\n\t\t\t\t\t\tif (me.options.gridLines.offsetGridLines && includeOffset) {\n\t\t\t\t\t\t\theightOffset += valueHeight / 2;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn me.top + Math.round(heightOffset);\n\t\t\t\t\t},\n\t\t\t\t\tgetPixelForTick: function getPixelForTick(index, includeOffset) {\n\t\t\t\t\t\treturn this.getPixelForValue(this.ticks[index], index + this.minIndex, null, includeOffset);\n\t\t\t\t\t},\n\t\t\t\t\tgetValueForPixel: function getValueForPixel(pixel) {\n\t\t\t\t\t\tvar me = this;\n\t\t\t\t\t\tvar value;\n\t\t\t\t\t\tvar offsetAmt = Math.max(me.ticks.length - (me.options.gridLines.offsetGridLines ? 0 : 1), 1);\n\t\t\t\t\t\tvar horz = me.isHorizontal();\n\t\t\t\t\t\tvar valueDimension = (horz ? me.width : me.height) / offsetAmt;\n\n\t\t\t\t\t\tpixel -= horz ? me.left : me.top;\n\n\t\t\t\t\t\tif (me.options.gridLines.offsetGridLines) {\n\t\t\t\t\t\t\tpixel -= valueDimension / 2;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (pixel <= 0) {\n\t\t\t\t\t\t\tvalue = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tvalue = Math.round(pixel / valueDimension);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn value;\n\t\t\t\t\t},\n\t\t\t\t\tgetBasePixel: function getBasePixel() {\n\t\t\t\t\t\treturn this.bottom;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tChart.scaleService.registerScaleType('category', DatasetScale, defaultConfig);\n\t\t\t};\n\t\t}, {}], 44: [function (require, module, exports) {\n\t\t\t'use strict';\n\n\t\t\tmodule.exports = function (Chart) {\n\n\t\t\t\tvar helpers = Chart.helpers;\n\n\t\t\t\tvar defaultConfig = {\n\t\t\t\t\tposition: 'left',\n\t\t\t\t\tticks: {\n\t\t\t\t\t\tcallback: Chart.Ticks.formatters.linear\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\tvar LinearScale = Chart.LinearScaleBase.extend({\n\t\t\t\t\tdetermineDataLimits: function determineDataLimits() {\n\t\t\t\t\t\tvar me = this;\n\t\t\t\t\t\tvar opts = me.options;\n\t\t\t\t\t\tvar chart = me.chart;\n\t\t\t\t\t\tvar data = chart.data;\n\t\t\t\t\t\tvar datasets = data.datasets;\n\t\t\t\t\t\tvar isHorizontal = me.isHorizontal();\n\n\t\t\t\t\t\tfunction IDMatches(meta) {\n\t\t\t\t\t\t\treturn isHorizontal ? meta.xAxisID === me.id : meta.yAxisID === me.id;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// First Calculate the range\n\t\t\t\t\t\tme.min = null;\n\t\t\t\t\t\tme.max = null;\n\n\t\t\t\t\t\tvar hasStacks = opts.stacked;\n\t\t\t\t\t\tif (hasStacks === undefined) {\n\t\t\t\t\t\t\thelpers.each(datasets, function (dataset, datasetIndex) {\n\t\t\t\t\t\t\t\tif (hasStacks) {\n\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tvar meta = chart.getDatasetMeta(datasetIndex);\n\t\t\t\t\t\t\t\tif (chart.isDatasetVisible(datasetIndex) && IDMatches(meta) && meta.stack !== undefined) {\n\t\t\t\t\t\t\t\t\thasStacks = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (opts.stacked || hasStacks) {\n\t\t\t\t\t\t\tvar valuesPerStack = {};\n\n\t\t\t\t\t\t\thelpers.each(datasets, function (dataset, datasetIndex) {\n\t\t\t\t\t\t\t\tvar meta = chart.getDatasetMeta(datasetIndex);\n\t\t\t\t\t\t\t\tvar key = [meta.type,\n\t\t\t\t\t\t\t\t// we have a separate stack for stack=undefined datasets when the opts.stacked is undefined\n\t\t\t\t\t\t\t\topts.stacked === undefined && meta.stack === undefined ? datasetIndex : '', meta.stack].join('.');\n\n\t\t\t\t\t\t\t\tif (valuesPerStack[key] === undefined) {\n\t\t\t\t\t\t\t\t\tvaluesPerStack[key] = {\n\t\t\t\t\t\t\t\t\t\tpositiveValues: [],\n\t\t\t\t\t\t\t\t\t\tnegativeValues: []\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// Store these per type\n\t\t\t\t\t\t\t\tvar positiveValues = valuesPerStack[key].positiveValues;\n\t\t\t\t\t\t\t\tvar negativeValues = valuesPerStack[key].negativeValues;\n\n\t\t\t\t\t\t\t\tif (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {\n\t\t\t\t\t\t\t\t\thelpers.each(dataset.data, function (rawValue, index) {\n\t\t\t\t\t\t\t\t\t\tvar value = +me.getRightValue(rawValue);\n\t\t\t\t\t\t\t\t\t\tif (isNaN(value) || meta.data[index].hidden) {\n\t\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tpositiveValues[index] = positiveValues[index] || 0;\n\t\t\t\t\t\t\t\t\t\tnegativeValues[index] = negativeValues[index] || 0;\n\n\t\t\t\t\t\t\t\t\t\tif (opts.relativePoints) {\n\t\t\t\t\t\t\t\t\t\t\tpositiveValues[index] = 100;\n\t\t\t\t\t\t\t\t\t\t} else if (value < 0) {\n\t\t\t\t\t\t\t\t\t\t\tnegativeValues[index] += value;\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\tpositiveValues[index] += value;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\thelpers.each(valuesPerStack, function (valuesForType) {\n\t\t\t\t\t\t\t\tvar values = valuesForType.positiveValues.concat(valuesForType.negativeValues);\n\t\t\t\t\t\t\t\tvar minVal = helpers.min(values);\n\t\t\t\t\t\t\t\tvar maxVal = helpers.max(values);\n\t\t\t\t\t\t\t\tme.min = me.min === null ? minVal : Math.min(me.min, minVal);\n\t\t\t\t\t\t\t\tme.max = me.max === null ? maxVal : Math.max(me.max, maxVal);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\thelpers.each(datasets, function (dataset, datasetIndex) {\n\t\t\t\t\t\t\t\tvar meta = chart.getDatasetMeta(datasetIndex);\n\t\t\t\t\t\t\t\tif (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {\n\t\t\t\t\t\t\t\t\thelpers.each(dataset.data, function (rawValue, index) {\n\t\t\t\t\t\t\t\t\t\tvar value = +me.getRightValue(rawValue);\n\t\t\t\t\t\t\t\t\t\tif (isNaN(value) || meta.data[index].hidden) {\n\t\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tif (me.min === null) {\n\t\t\t\t\t\t\t\t\t\t\tme.min = value;\n\t\t\t\t\t\t\t\t\t\t} else if (value < me.min) {\n\t\t\t\t\t\t\t\t\t\t\tme.min = value;\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tif (me.max === null) {\n\t\t\t\t\t\t\t\t\t\t\tme.max = value;\n\t\t\t\t\t\t\t\t\t\t} else if (value > me.max) {\n\t\t\t\t\t\t\t\t\t\t\tme.max = value;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Common base implementation to handle ticks.min, ticks.max, ticks.beginAtZero\n\t\t\t\t\t\tthis.handleTickRangeOptions();\n\t\t\t\t\t},\n\t\t\t\t\tgetTickLimit: function getTickLimit() {\n\t\t\t\t\t\tvar maxTicks;\n\t\t\t\t\t\tvar me = this;\n\t\t\t\t\t\tvar tickOpts = me.options.ticks;\n\n\t\t\t\t\t\tif (me.isHorizontal()) {\n\t\t\t\t\t\t\tmaxTicks = Math.min(tickOpts.maxTicksLimit ? tickOpts.maxTicksLimit : 11, Math.ceil(me.width / 50));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// The factor of 2 used to scale the font size has been experimentally determined.\n\t\t\t\t\t\t\tvar tickFontSize = helpers.getValueOrDefault(tickOpts.fontSize, Chart.defaults.global.defaultFontSize);\n\t\t\t\t\t\t\tmaxTicks = Math.min(tickOpts.maxTicksLimit ? tickOpts.maxTicksLimit : 11, Math.ceil(me.height / (2 * tickFontSize)));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn maxTicks;\n\t\t\t\t\t},\n\t\t\t\t\t// Called after the ticks are built. We need\n\t\t\t\t\thandleDirectionalChanges: function handleDirectionalChanges() {\n\t\t\t\t\t\tif (!this.isHorizontal()) {\n\t\t\t\t\t\t\t// We are in a vertical orientation. The top value is the highest. So reverse the array\n\t\t\t\t\t\t\tthis.ticks.reverse();\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tgetLabelForIndex: function getLabelForIndex(index, datasetIndex) {\n\t\t\t\t\t\treturn +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);\n\t\t\t\t\t},\n\t\t\t\t\t// Utils\n\t\t\t\t\tgetPixelForValue: function getPixelForValue(value) {\n\t\t\t\t\t\t// This must be called after fit has been run so that\n\t\t\t\t\t\t// this.left, this.top, this.right, and this.bottom have been defined\n\t\t\t\t\t\tvar me = this;\n\t\t\t\t\t\tvar start = me.start;\n\n\t\t\t\t\t\tvar rightValue = +me.getRightValue(value);\n\t\t\t\t\t\tvar pixel;\n\t\t\t\t\t\tvar range = me.end - start;\n\n\t\t\t\t\t\tif (me.isHorizontal()) {\n\t\t\t\t\t\t\tpixel = me.left + me.width / range * (rightValue - start);\n\t\t\t\t\t\t\treturn Math.round(pixel);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tpixel = me.bottom - me.height / range * (rightValue - start);\n\t\t\t\t\t\treturn Math.round(pixel);\n\t\t\t\t\t},\n\t\t\t\t\tgetValueForPixel: function getValueForPixel(pixel) {\n\t\t\t\t\t\tvar me = this;\n\t\t\t\t\t\tvar isHorizontal = me.isHorizontal();\n\t\t\t\t\t\tvar innerDimension = isHorizontal ? me.width : me.height;\n\t\t\t\t\t\tvar offset = (isHorizontal ? pixel - me.left : me.bottom - pixel) / innerDimension;\n\t\t\t\t\t\treturn me.start + (me.end - me.start) * offset;\n\t\t\t\t\t},\n\t\t\t\t\tgetPixelForTick: function getPixelForTick(index) {\n\t\t\t\t\t\treturn this.getPixelForValue(this.ticksAsNumbers[index]);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tChart.scaleService.registerScaleType('linear', LinearScale, defaultConfig);\n\t\t\t};\n\t\t}, {}], 45: [function (require, module, exports) {\n\t\t\t'use strict';\n\n\t\t\tmodule.exports = function (Chart) {\n\n\t\t\t\tvar helpers = Chart.helpers,\n\t\t\t\t    noop = helpers.noop;\n\n\t\t\t\tChart.LinearScaleBase = Chart.Scale.extend({\n\t\t\t\t\thandleTickRangeOptions: function handleTickRangeOptions() {\n\t\t\t\t\t\tvar me = this;\n\t\t\t\t\t\tvar opts = me.options;\n\t\t\t\t\t\tvar tickOpts = opts.ticks;\n\n\t\t\t\t\t\t// If we are forcing it to begin at 0, but 0 will already be rendered on the chart,\n\t\t\t\t\t\t// do nothing since that would make the chart weird. If the user really wants a weird chart\n\t\t\t\t\t\t// axis, they can manually override it\n\t\t\t\t\t\tif (tickOpts.beginAtZero) {\n\t\t\t\t\t\t\tvar minSign = helpers.sign(me.min);\n\t\t\t\t\t\t\tvar maxSign = helpers.sign(me.max);\n\n\t\t\t\t\t\t\tif (minSign < 0 && maxSign < 0) {\n\t\t\t\t\t\t\t\t// move the top up to 0\n\t\t\t\t\t\t\t\tme.max = 0;\n\t\t\t\t\t\t\t} else if (minSign > 0 && maxSign > 0) {\n\t\t\t\t\t\t\t\t// move the bottom down to 0\n\t\t\t\t\t\t\t\tme.min = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (tickOpts.min !== undefined) {\n\t\t\t\t\t\t\tme.min = tickOpts.min;\n\t\t\t\t\t\t} else if (tickOpts.suggestedMin !== undefined) {\n\t\t\t\t\t\t\tme.min = Math.min(me.min, tickOpts.suggestedMin);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (tickOpts.max !== undefined) {\n\t\t\t\t\t\t\tme.max = tickOpts.max;\n\t\t\t\t\t\t} else if (tickOpts.suggestedMax !== undefined) {\n\t\t\t\t\t\t\tme.max = Math.max(me.max, tickOpts.suggestedMax);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (me.min === me.max) {\n\t\t\t\t\t\t\tme.max++;\n\n\t\t\t\t\t\t\tif (!tickOpts.beginAtZero) {\n\t\t\t\t\t\t\t\tme.min--;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tgetTickLimit: noop,\n\t\t\t\t\thandleDirectionalChanges: noop,\n\n\t\t\t\t\tbuildTicks: function buildTicks() {\n\t\t\t\t\t\tvar me = this;\n\t\t\t\t\t\tvar opts = me.options;\n\t\t\t\t\t\tvar tickOpts = opts.ticks;\n\n\t\t\t\t\t\t// Figure out what the max number of ticks we can support it is based on the size of\n\t\t\t\t\t\t// the axis area. For now, we say that the minimum tick spacing in pixels must be 50\n\t\t\t\t\t\t// We also limit the maximum number of ticks to 11 which gives a nice 10 squares on\n\t\t\t\t\t\t// the graph. Make sure we always have at least 2 ticks\n\t\t\t\t\t\tvar maxTicks = me.getTickLimit();\n\t\t\t\t\t\tmaxTicks = Math.max(2, maxTicks);\n\n\t\t\t\t\t\tvar numericGeneratorOptions = {\n\t\t\t\t\t\t\tmaxTicks: maxTicks,\n\t\t\t\t\t\t\tmin: tickOpts.min,\n\t\t\t\t\t\t\tmax: tickOpts.max,\n\t\t\t\t\t\t\tstepSize: helpers.getValueOrDefault(tickOpts.fixedStepSize, tickOpts.stepSize)\n\t\t\t\t\t\t};\n\t\t\t\t\t\tvar ticks = me.ticks = Chart.Ticks.generators.linear(numericGeneratorOptions, me);\n\n\t\t\t\t\t\tme.handleDirectionalChanges();\n\n\t\t\t\t\t\t// At this point, we need to update our max and min given the tick values since we have expanded the\n\t\t\t\t\t\t// range of the scale\n\t\t\t\t\t\tme.max = helpers.max(ticks);\n\t\t\t\t\t\tme.min = helpers.min(ticks);\n\n\t\t\t\t\t\tif (tickOpts.reverse) {\n\t\t\t\t\t\t\tticks.reverse();\n\n\t\t\t\t\t\t\tme.start = me.max;\n\t\t\t\t\t\t\tme.end = me.min;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tme.start = me.min;\n\t\t\t\t\t\t\tme.end = me.max;\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tconvertTicksToLabels: function convertTicksToLabels() {\n\t\t\t\t\t\tvar me = this;\n\t\t\t\t\t\tme.ticksAsNumbers = me.ticks.slice();\n\t\t\t\t\t\tme.zeroLineIndex = me.ticks.indexOf(0);\n\n\t\t\t\t\t\tChart.Scale.prototype.convertTicksToLabels.call(me);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t};\n\t\t}, {}], 46: [function (require, module, exports) {\n\t\t\t'use strict';\n\n\t\t\tmodule.exports = function (Chart) {\n\n\t\t\t\tvar helpers = Chart.helpers;\n\n\t\t\t\tvar defaultConfig = {\n\t\t\t\t\tposition: 'left',\n\n\t\t\t\t\t// label settings\n\t\t\t\t\tticks: {\n\t\t\t\t\t\tcallback: Chart.Ticks.formatters.logarithmic\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\tvar LogarithmicScale = Chart.Scale.extend({\n\t\t\t\t\tdetermineDataLimits: function determineDataLimits() {\n\t\t\t\t\t\tvar me = this;\n\t\t\t\t\t\tvar opts = me.options;\n\t\t\t\t\t\tvar tickOpts = opts.ticks;\n\t\t\t\t\t\tvar chart = me.chart;\n\t\t\t\t\t\tvar data = chart.data;\n\t\t\t\t\t\tvar datasets = data.datasets;\n\t\t\t\t\t\tvar getValueOrDefault = helpers.getValueOrDefault;\n\t\t\t\t\t\tvar isHorizontal = me.isHorizontal();\n\t\t\t\t\t\tfunction IDMatches(meta) {\n\t\t\t\t\t\t\treturn isHorizontal ? meta.xAxisID === me.id : meta.yAxisID === me.id;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Calculate Range\n\t\t\t\t\t\tme.min = null;\n\t\t\t\t\t\tme.max = null;\n\t\t\t\t\t\tme.minNotZero = null;\n\n\t\t\t\t\t\tvar hasStacks = opts.stacked;\n\t\t\t\t\t\tif (hasStacks === undefined) {\n\t\t\t\t\t\t\thelpers.each(datasets, function (dataset, datasetIndex) {\n\t\t\t\t\t\t\t\tif (hasStacks) {\n\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tvar meta = chart.getDatasetMeta(datasetIndex);\n\t\t\t\t\t\t\t\tif (chart.isDatasetVisible(datasetIndex) && IDMatches(meta) && meta.stack !== undefined) {\n\t\t\t\t\t\t\t\t\thasStacks = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (opts.stacked || hasStacks) {\n\t\t\t\t\t\t\tvar valuesPerStack = {};\n\n\t\t\t\t\t\t\thelpers.each(datasets, function (dataset, datasetIndex) {\n\t\t\t\t\t\t\t\tvar meta = chart.getDatasetMeta(datasetIndex);\n\t\t\t\t\t\t\t\tvar key = [meta.type,\n\t\t\t\t\t\t\t\t// we have a separate stack for stack=undefined datasets when the opts.stacked is undefined\n\t\t\t\t\t\t\t\topts.stacked === undefined && meta.stack === undefined ? datasetIndex : '', meta.stack].join('.');\n\n\t\t\t\t\t\t\t\tif (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {\n\t\t\t\t\t\t\t\t\tif (valuesPerStack[key] === undefined) {\n\t\t\t\t\t\t\t\t\t\tvaluesPerStack[key] = [];\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\thelpers.each(dataset.data, function (rawValue, index) {\n\t\t\t\t\t\t\t\t\t\tvar values = valuesPerStack[key];\n\t\t\t\t\t\t\t\t\t\tvar value = +me.getRightValue(rawValue);\n\t\t\t\t\t\t\t\t\t\tif (isNaN(value) || meta.data[index].hidden) {\n\t\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tvalues[index] = values[index] || 0;\n\n\t\t\t\t\t\t\t\t\t\tif (opts.relativePoints) {\n\t\t\t\t\t\t\t\t\t\t\tvalues[index] = 100;\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t// Don't need to split positive and negative since the log scale can't handle a 0 crossing\n\t\t\t\t\t\t\t\t\t\t\tvalues[index] += value;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\thelpers.each(valuesPerStack, function (valuesForType) {\n\t\t\t\t\t\t\t\tvar minVal = helpers.min(valuesForType);\n\t\t\t\t\t\t\t\tvar maxVal = helpers.max(valuesForType);\n\t\t\t\t\t\t\t\tme.min = me.min === null ? minVal : Math.min(me.min, minVal);\n\t\t\t\t\t\t\t\tme.max = me.max === null ? maxVal : Math.max(me.max, maxVal);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\thelpers.each(datasets, function (dataset, datasetIndex) {\n\t\t\t\t\t\t\t\tvar meta = chart.getDatasetMeta(datasetIndex);\n\t\t\t\t\t\t\t\tif (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {\n\t\t\t\t\t\t\t\t\thelpers.each(dataset.data, function (rawValue, index) {\n\t\t\t\t\t\t\t\t\t\tvar value = +me.getRightValue(rawValue);\n\t\t\t\t\t\t\t\t\t\tif (isNaN(value) || meta.data[index].hidden) {\n\t\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tif (me.min === null) {\n\t\t\t\t\t\t\t\t\t\t\tme.min = value;\n\t\t\t\t\t\t\t\t\t\t} else if (value < me.min) {\n\t\t\t\t\t\t\t\t\t\t\tme.min = value;\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tif (me.max === null) {\n\t\t\t\t\t\t\t\t\t\t\tme.max = value;\n\t\t\t\t\t\t\t\t\t\t} else if (value > me.max) {\n\t\t\t\t\t\t\t\t\t\t\tme.max = value;\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tif (value !== 0 && (me.minNotZero === null || value < me.minNotZero)) {\n\t\t\t\t\t\t\t\t\t\t\tme.minNotZero = value;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tme.min = getValueOrDefault(tickOpts.min, me.min);\n\t\t\t\t\t\tme.max = getValueOrDefault(tickOpts.max, me.max);\n\n\t\t\t\t\t\tif (me.min === me.max) {\n\t\t\t\t\t\t\tif (me.min !== 0 && me.min !== null) {\n\t\t\t\t\t\t\t\tme.min = Math.pow(10, Math.floor(helpers.log10(me.min)) - 1);\n\t\t\t\t\t\t\t\tme.max = Math.pow(10, Math.floor(helpers.log10(me.max)) + 1);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tme.min = 1;\n\t\t\t\t\t\t\t\tme.max = 10;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tbuildTicks: function buildTicks() {\n\t\t\t\t\t\tvar me = this;\n\t\t\t\t\t\tvar opts = me.options;\n\t\t\t\t\t\tvar tickOpts = opts.ticks;\n\n\t\t\t\t\t\tvar generationOptions = {\n\t\t\t\t\t\t\tmin: tickOpts.min,\n\t\t\t\t\t\t\tmax: tickOpts.max\n\t\t\t\t\t\t};\n\t\t\t\t\t\tvar ticks = me.ticks = Chart.Ticks.generators.logarithmic(generationOptions, me);\n\n\t\t\t\t\t\tif (!me.isHorizontal()) {\n\t\t\t\t\t\t\t// We are in a vertical orientation. The top value is the highest. So reverse the array\n\t\t\t\t\t\t\tticks.reverse();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// At this point, we need to update our max and min given the tick values since we have expanded the\n\t\t\t\t\t\t// range of the scale\n\t\t\t\t\t\tme.max = helpers.max(ticks);\n\t\t\t\t\t\tme.min = helpers.min(ticks);\n\n\t\t\t\t\t\tif (tickOpts.reverse) {\n\t\t\t\t\t\t\tticks.reverse();\n\n\t\t\t\t\t\t\tme.start = me.max;\n\t\t\t\t\t\t\tme.end = me.min;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tme.start = me.min;\n\t\t\t\t\t\t\tme.end = me.max;\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tconvertTicksToLabels: function convertTicksToLabels() {\n\t\t\t\t\t\tthis.tickValues = this.ticks.slice();\n\n\t\t\t\t\t\tChart.Scale.prototype.convertTicksToLabels.call(this);\n\t\t\t\t\t},\n\t\t\t\t\t// Get the correct tooltip label\n\t\t\t\t\tgetLabelForIndex: function getLabelForIndex(index, datasetIndex) {\n\t\t\t\t\t\treturn +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);\n\t\t\t\t\t},\n\t\t\t\t\tgetPixelForTick: function getPixelForTick(index) {\n\t\t\t\t\t\treturn this.getPixelForValue(this.tickValues[index]);\n\t\t\t\t\t},\n\t\t\t\t\tgetPixelForValue: function getPixelForValue(value) {\n\t\t\t\t\t\tvar me = this;\n\t\t\t\t\t\tvar innerDimension;\n\t\t\t\t\t\tvar pixel;\n\n\t\t\t\t\t\tvar start = me.start;\n\t\t\t\t\t\tvar newVal = +me.getRightValue(value);\n\t\t\t\t\t\tvar range;\n\t\t\t\t\t\tvar opts = me.options;\n\t\t\t\t\t\tvar tickOpts = opts.ticks;\n\n\t\t\t\t\t\tif (me.isHorizontal()) {\n\t\t\t\t\t\t\trange = helpers.log10(me.end) - helpers.log10(start); // todo: if start === 0\n\t\t\t\t\t\t\tif (newVal === 0) {\n\t\t\t\t\t\t\t\tpixel = me.left;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tinnerDimension = me.width;\n\t\t\t\t\t\t\t\tpixel = me.left + innerDimension / range * (helpers.log10(newVal) - helpers.log10(start));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Bottom - top since pixels increase downward on a screen\n\t\t\t\t\t\t\tinnerDimension = me.height;\n\t\t\t\t\t\t\tif (start === 0 && !tickOpts.reverse) {\n\t\t\t\t\t\t\t\trange = helpers.log10(me.end) - helpers.log10(me.minNotZero);\n\t\t\t\t\t\t\t\tif (newVal === start) {\n\t\t\t\t\t\t\t\t\tpixel = me.bottom;\n\t\t\t\t\t\t\t\t} else if (newVal === me.minNotZero) {\n\t\t\t\t\t\t\t\t\tpixel = me.bottom - innerDimension * 0.02;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tpixel = me.bottom - innerDimension * 0.02 - innerDimension * 0.98 / range * (helpers.log10(newVal) - helpers.log10(me.minNotZero));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if (me.end === 0 && tickOpts.reverse) {\n\t\t\t\t\t\t\t\trange = helpers.log10(me.start) - helpers.log10(me.minNotZero);\n\t\t\t\t\t\t\t\tif (newVal === me.end) {\n\t\t\t\t\t\t\t\t\tpixel = me.top;\n\t\t\t\t\t\t\t\t} else if (newVal === me.minNotZero) {\n\t\t\t\t\t\t\t\t\tpixel = me.top + innerDimension * 0.02;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tpixel = me.top + innerDimension * 0.02 + innerDimension * 0.98 / range * (helpers.log10(newVal) - helpers.log10(me.minNotZero));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\trange = helpers.log10(me.end) - helpers.log10(start);\n\t\t\t\t\t\t\t\tinnerDimension = me.height;\n\t\t\t\t\t\t\t\tpixel = me.bottom - innerDimension / range * (helpers.log10(newVal) - helpers.log10(start));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn pixel;\n\t\t\t\t\t},\n\t\t\t\t\tgetValueForPixel: function getValueForPixel(pixel) {\n\t\t\t\t\t\tvar me = this;\n\t\t\t\t\t\tvar range = helpers.log10(me.end) - helpers.log10(me.start);\n\t\t\t\t\t\tvar value, innerDimension;\n\n\t\t\t\t\t\tif (me.isHorizontal()) {\n\t\t\t\t\t\t\tinnerDimension = me.width;\n\t\t\t\t\t\t\tvalue = me.start * Math.pow(10, (pixel - me.left) * range / innerDimension);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// todo: if start === 0\n\t\t\t\t\t\t\tinnerDimension = me.height;\n\t\t\t\t\t\t\tvalue = Math.pow(10, (me.bottom - pixel) * range / innerDimension) / me.start;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn value;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tChart.scaleService.registerScaleType('logarithmic', LogarithmicScale, defaultConfig);\n\t\t\t};\n\t\t}, {}], 47: [function (require, module, exports) {\n\t\t\t'use strict';\n\n\t\t\tmodule.exports = function (Chart) {\n\n\t\t\t\tvar helpers = Chart.helpers;\n\t\t\t\tvar globalDefaults = Chart.defaults.global;\n\n\t\t\t\tvar defaultConfig = {\n\t\t\t\t\tdisplay: true,\n\n\t\t\t\t\t// Boolean - Whether to animate scaling the chart from the centre\n\t\t\t\t\tanimate: true,\n\t\t\t\t\tlineArc: false,\n\t\t\t\t\tposition: 'chartArea',\n\n\t\t\t\t\tangleLines: {\n\t\t\t\t\t\tdisplay: true,\n\t\t\t\t\t\tcolor: 'rgba(0, 0, 0, 0.1)',\n\t\t\t\t\t\tlineWidth: 1\n\t\t\t\t\t},\n\n\t\t\t\t\t// label settings\n\t\t\t\t\tticks: {\n\t\t\t\t\t\t// Boolean - Show a backdrop to the scale label\n\t\t\t\t\t\tshowLabelBackdrop: true,\n\n\t\t\t\t\t\t// String - The colour of the label backdrop\n\t\t\t\t\t\tbackdropColor: 'rgba(255,255,255,0.75)',\n\n\t\t\t\t\t\t// Number - The backdrop padding above & below the label in pixels\n\t\t\t\t\t\tbackdropPaddingY: 2,\n\n\t\t\t\t\t\t// Number - The backdrop padding to the side of the label in pixels\n\t\t\t\t\t\tbackdropPaddingX: 2,\n\n\t\t\t\t\t\tcallback: Chart.Ticks.formatters.linear\n\t\t\t\t\t},\n\n\t\t\t\t\tpointLabels: {\n\t\t\t\t\t\t// Number - Point label font size in pixels\n\t\t\t\t\t\tfontSize: 10,\n\n\t\t\t\t\t\t// Function - Used to convert point labels\n\t\t\t\t\t\tcallback: function callback(label) {\n\t\t\t\t\t\t\treturn label;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\tfunction getValueCount(scale) {\n\t\t\t\t\treturn !scale.options.lineArc ? scale.chart.data.labels.length : 0;\n\t\t\t\t}\n\n\t\t\t\tfunction getPointLabelFontOptions(scale) {\n\t\t\t\t\tvar pointLabelOptions = scale.options.pointLabels;\n\t\t\t\t\tvar fontSize = helpers.getValueOrDefault(pointLabelOptions.fontSize, globalDefaults.defaultFontSize);\n\t\t\t\t\tvar fontStyle = helpers.getValueOrDefault(pointLabelOptions.fontStyle, globalDefaults.defaultFontStyle);\n\t\t\t\t\tvar fontFamily = helpers.getValueOrDefault(pointLabelOptions.fontFamily, globalDefaults.defaultFontFamily);\n\t\t\t\t\tvar font = helpers.fontString(fontSize, fontStyle, fontFamily);\n\n\t\t\t\t\treturn {\n\t\t\t\t\t\tsize: fontSize,\n\t\t\t\t\t\tstyle: fontStyle,\n\t\t\t\t\t\tfamily: fontFamily,\n\t\t\t\t\t\tfont: font\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\tfunction measureLabelSize(ctx, fontSize, label) {\n\t\t\t\t\tif (helpers.isArray(label)) {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tw: helpers.longestText(ctx, ctx.font, label),\n\t\t\t\t\t\t\th: label.length * fontSize + (label.length - 1) * 1.5 * fontSize\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t\treturn {\n\t\t\t\t\t\tw: ctx.measureText(label).width,\n\t\t\t\t\t\th: fontSize\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\tfunction determineLimits(angle, pos, size, min, max) {\n\t\t\t\t\tif (angle === min || angle === max) {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tstart: pos - size / 2,\n\t\t\t\t\t\t\tend: pos + size / 2\n\t\t\t\t\t\t};\n\t\t\t\t\t} else if (angle < min || angle > max) {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tstart: pos - size - 5,\n\t\t\t\t\t\t\tend: pos\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t\treturn {\n\t\t\t\t\t\tstart: pos,\n\t\t\t\t\t\tend: pos + size + 5\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\t/**\n     * Helper function to fit a radial linear scale with point labels\n     */\n\t\t\t\tfunction fitWithPointLabels(scale) {\n\t\t\t\t\t/*\n      * Right, this is really confusing and there is a lot of maths going on here\n      * The gist of the problem is here: https://gist.github.com/nnnick/696cc9c55f4b0beb8fe9\n      *\n      * Reaction: https://dl.dropboxusercontent.com/u/34601363/toomuchscience.gif\n      *\n      * Solution:\n      *\n      * We assume the radius of the polygon is half the size of the canvas at first\n      * at each index we check if the text overlaps.\n      *\n      * Where it does, we store that angle and that index.\n      *\n      * After finding the largest index and angle we calculate how much we need to remove\n      * from the shape radius to move the point inwards by that x.\n      *\n      * We average the left and right distances to get the maximum shape radius that can fit in the box\n      * along with labels.\n      *\n      * Once we have that, we can find the centre point for the chart, by taking the x text protrusion\n      * on each side, removing that from the size, halving it and adding the left x protrusion width.\n      *\n      * This will mean we have a shape fitted to the canvas, as large as it can be with the labels\n      * and position it in the most space efficient manner\n      *\n      * https://dl.dropboxusercontent.com/u/34601363/yeahscience.gif\n      */\n\n\t\t\t\t\tvar plFont = getPointLabelFontOptions(scale);\n\n\t\t\t\t\t// Get maximum radius of the polygon. Either half the height (minus the text width) or half the width.\n\t\t\t\t\t// Use this to calculate the offset + change. - Make sure L/R protrusion is at least 0 to stop issues with centre points\n\t\t\t\t\tvar largestPossibleRadius = Math.min(scale.height / 2, scale.width / 2);\n\t\t\t\t\tvar furthestLimits = {\n\t\t\t\t\t\tl: scale.width,\n\t\t\t\t\t\tr: 0,\n\t\t\t\t\t\tt: scale.height,\n\t\t\t\t\t\tb: 0\n\t\t\t\t\t};\n\t\t\t\t\tvar furthestAngles = {};\n\t\t\t\t\tvar i;\n\t\t\t\t\tvar textSize;\n\t\t\t\t\tvar pointPosition;\n\n\t\t\t\t\tscale.ctx.font = plFont.font;\n\t\t\t\t\tscale._pointLabelSizes = [];\n\n\t\t\t\t\tvar valueCount = getValueCount(scale);\n\t\t\t\t\tfor (i = 0; i < valueCount; i++) {\n\t\t\t\t\t\tpointPosition = scale.getPointPosition(i, largestPossibleRadius);\n\t\t\t\t\t\ttextSize = measureLabelSize(scale.ctx, plFont.size, scale.pointLabels[i] || '');\n\t\t\t\t\t\tscale._pointLabelSizes[i] = textSize;\n\n\t\t\t\t\t\t// Add quarter circle to make degree 0 mean top of circle\n\t\t\t\t\t\tvar angleRadians = scale.getIndexAngle(i);\n\t\t\t\t\t\tvar angle = helpers.toDegrees(angleRadians) % 360;\n\t\t\t\t\t\tvar hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);\n\t\t\t\t\t\tvar vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);\n\n\t\t\t\t\t\tif (hLimits.start < furthestLimits.l) {\n\t\t\t\t\t\t\tfurthestLimits.l = hLimits.start;\n\t\t\t\t\t\t\tfurthestAngles.l = angleRadians;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (hLimits.end > furthestLimits.r) {\n\t\t\t\t\t\t\tfurthestLimits.r = hLimits.end;\n\t\t\t\t\t\t\tfurthestAngles.r = angleRadians;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (vLimits.start < furthestLimits.t) {\n\t\t\t\t\t\t\tfurthestLimits.t = vLimits.start;\n\t\t\t\t\t\t\tfurthestAngles.t = angleRadians;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (vLimits.end > furthestLimits.b) {\n\t\t\t\t\t\t\tfurthestLimits.b = vLimits.end;\n\t\t\t\t\t\t\tfurthestAngles.b = angleRadians;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tscale.setReductions(largestPossibleRadius, furthestLimits, furthestAngles);\n\t\t\t\t}\n\n\t\t\t\t/**\n     * Helper function to fit a radial linear scale with no point labels\n     */\n\t\t\t\tfunction _fit(scale) {\n\t\t\t\t\tvar largestPossibleRadius = Math.min(scale.height / 2, scale.width / 2);\n\t\t\t\t\tscale.drawingArea = Math.round(largestPossibleRadius);\n\t\t\t\t\tscale.setCenterPoint(0, 0, 0, 0);\n\t\t\t\t}\n\n\t\t\t\tfunction getTextAlignForAngle(angle) {\n\t\t\t\t\tif (angle === 0 || angle === 180) {\n\t\t\t\t\t\treturn 'center';\n\t\t\t\t\t} else if (angle < 180) {\n\t\t\t\t\t\treturn 'left';\n\t\t\t\t\t}\n\n\t\t\t\t\treturn 'right';\n\t\t\t\t}\n\n\t\t\t\tfunction fillText(ctx, text, position, fontSize) {\n\t\t\t\t\tif (helpers.isArray(text)) {\n\t\t\t\t\t\tvar y = position.y;\n\t\t\t\t\t\tvar spacing = 1.5 * fontSize;\n\n\t\t\t\t\t\tfor (var i = 0; i < text.length; ++i) {\n\t\t\t\t\t\t\tctx.fillText(text[i], position.x, y);\n\t\t\t\t\t\t\ty += spacing;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tctx.fillText(text, position.x, position.y);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfunction adjustPointPositionForLabelHeight(angle, textSize, position) {\n\t\t\t\t\tif (angle === 90 || angle === 270) {\n\t\t\t\t\t\tposition.y -= textSize.h / 2;\n\t\t\t\t\t} else if (angle > 270 || angle < 90) {\n\t\t\t\t\t\tposition.y -= textSize.h;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfunction drawPointLabels(scale) {\n\t\t\t\t\tvar ctx = scale.ctx;\n\t\t\t\t\tvar getValueOrDefault = helpers.getValueOrDefault;\n\t\t\t\t\tvar opts = scale.options;\n\t\t\t\t\tvar angleLineOpts = opts.angleLines;\n\t\t\t\t\tvar pointLabelOpts = opts.pointLabels;\n\n\t\t\t\t\tctx.lineWidth = angleLineOpts.lineWidth;\n\t\t\t\t\tctx.strokeStyle = angleLineOpts.color;\n\n\t\t\t\t\tvar outerDistance = scale.getDistanceFromCenterForValue(opts.reverse ? scale.min : scale.max);\n\n\t\t\t\t\t// Point Label Font\n\t\t\t\t\tvar plFont = getPointLabelFontOptions(scale);\n\n\t\t\t\t\tctx.textBaseline = 'top';\n\n\t\t\t\t\tfor (var i = getValueCount(scale) - 1; i >= 0; i--) {\n\t\t\t\t\t\tif (angleLineOpts.display) {\n\t\t\t\t\t\t\tvar outerPosition = scale.getPointPosition(i, outerDistance);\n\t\t\t\t\t\t\tctx.beginPath();\n\t\t\t\t\t\t\tctx.moveTo(scale.xCenter, scale.yCenter);\n\t\t\t\t\t\t\tctx.lineTo(outerPosition.x, outerPosition.y);\n\t\t\t\t\t\t\tctx.stroke();\n\t\t\t\t\t\t\tctx.closePath();\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Extra 3px out for some label spacing\n\t\t\t\t\t\tvar pointLabelPosition = scale.getPointPosition(i, outerDistance + 5);\n\n\t\t\t\t\t\t// Keep this in loop since we may support array properties here\n\t\t\t\t\t\tvar pointLabelFontColor = getValueOrDefault(pointLabelOpts.fontColor, globalDefaults.defaultFontColor);\n\t\t\t\t\t\tctx.font = plFont.font;\n\t\t\t\t\t\tctx.fillStyle = pointLabelFontColor;\n\n\t\t\t\t\t\tvar angleRadians = scale.getIndexAngle(i);\n\t\t\t\t\t\tvar angle = helpers.toDegrees(angleRadians);\n\t\t\t\t\t\tctx.textAlign = getTextAlignForAngle(angle);\n\t\t\t\t\t\tadjustPointPositionForLabelHeight(angle, scale._pointLabelSizes[i], pointLabelPosition);\n\t\t\t\t\t\tfillText(ctx, scale.pointLabels[i] || '', pointLabelPosition, plFont.size);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfunction drawRadiusLine(scale, gridLineOpts, radius, index) {\n\t\t\t\t\tvar ctx = scale.ctx;\n\t\t\t\t\tctx.strokeStyle = helpers.getValueAtIndexOrDefault(gridLineOpts.color, index - 1);\n\t\t\t\t\tctx.lineWidth = helpers.getValueAtIndexOrDefault(gridLineOpts.lineWidth, index - 1);\n\n\t\t\t\t\tif (scale.options.lineArc) {\n\t\t\t\t\t\t// Draw circular arcs between the points\n\t\t\t\t\t\tctx.beginPath();\n\t\t\t\t\t\tctx.arc(scale.xCenter, scale.yCenter, radius, 0, Math.PI * 2);\n\t\t\t\t\t\tctx.closePath();\n\t\t\t\t\t\tctx.stroke();\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Draw straight lines connecting each index\n\t\t\t\t\t\tvar valueCount = getValueCount(scale);\n\n\t\t\t\t\t\tif (valueCount === 0) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tctx.beginPath();\n\t\t\t\t\t\tvar pointPosition = scale.getPointPosition(0, radius);\n\t\t\t\t\t\tctx.moveTo(pointPosition.x, pointPosition.y);\n\n\t\t\t\t\t\tfor (var i = 1; i < valueCount; i++) {\n\t\t\t\t\t\t\tpointPosition = scale.getPointPosition(i, radius);\n\t\t\t\t\t\t\tctx.lineTo(pointPosition.x, pointPosition.y);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tctx.closePath();\n\t\t\t\t\t\tctx.stroke();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfunction numberOrZero(param) {\n\t\t\t\t\treturn helpers.isNumber(param) ? param : 0;\n\t\t\t\t}\n\n\t\t\t\tvar LinearRadialScale = Chart.LinearScaleBase.extend({\n\t\t\t\t\tsetDimensions: function setDimensions() {\n\t\t\t\t\t\tvar me = this;\n\t\t\t\t\t\tvar opts = me.options;\n\t\t\t\t\t\tvar tickOpts = opts.ticks;\n\t\t\t\t\t\t// Set the unconstrained dimension before label rotation\n\t\t\t\t\t\tme.width = me.maxWidth;\n\t\t\t\t\t\tme.height = me.maxHeight;\n\t\t\t\t\t\tme.xCenter = Math.round(me.width / 2);\n\t\t\t\t\t\tme.yCenter = Math.round(me.height / 2);\n\n\t\t\t\t\t\tvar minSize = helpers.min([me.height, me.width]);\n\t\t\t\t\t\tvar tickFontSize = helpers.getValueOrDefault(tickOpts.fontSize, globalDefaults.defaultFontSize);\n\t\t\t\t\t\tme.drawingArea = opts.display ? minSize / 2 - (tickFontSize / 2 + tickOpts.backdropPaddingY) : minSize / 2;\n\t\t\t\t\t},\n\t\t\t\t\tdetermineDataLimits: function determineDataLimits() {\n\t\t\t\t\t\tvar me = this;\n\t\t\t\t\t\tvar chart = me.chart;\n\t\t\t\t\t\tvar min = Number.POSITIVE_INFINITY;\n\t\t\t\t\t\tvar max = Number.NEGATIVE_INFINITY;\n\n\t\t\t\t\t\thelpers.each(chart.data.datasets, function (dataset, datasetIndex) {\n\t\t\t\t\t\t\tif (chart.isDatasetVisible(datasetIndex)) {\n\t\t\t\t\t\t\t\tvar meta = chart.getDatasetMeta(datasetIndex);\n\n\t\t\t\t\t\t\t\thelpers.each(dataset.data, function (rawValue, index) {\n\t\t\t\t\t\t\t\t\tvar value = +me.getRightValue(rawValue);\n\t\t\t\t\t\t\t\t\tif (isNaN(value) || meta.data[index].hidden) {\n\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tmin = Math.min(value, min);\n\t\t\t\t\t\t\t\t\tmax = Math.max(value, max);\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tme.min = min === Number.POSITIVE_INFINITY ? 0 : min;\n\t\t\t\t\t\tme.max = max === Number.NEGATIVE_INFINITY ? 0 : max;\n\n\t\t\t\t\t\t// Common base implementation to handle ticks.min, ticks.max, ticks.beginAtZero\n\t\t\t\t\t\tme.handleTickRangeOptions();\n\t\t\t\t\t},\n\t\t\t\t\tgetTickLimit: function getTickLimit() {\n\t\t\t\t\t\tvar tickOpts = this.options.ticks;\n\t\t\t\t\t\tvar tickFontSize = helpers.getValueOrDefault(tickOpts.fontSize, globalDefaults.defaultFontSize);\n\t\t\t\t\t\treturn Math.min(tickOpts.maxTicksLimit ? tickOpts.maxTicksLimit : 11, Math.ceil(this.drawingArea / (1.5 * tickFontSize)));\n\t\t\t\t\t},\n\t\t\t\t\tconvertTicksToLabels: function convertTicksToLabels() {\n\t\t\t\t\t\tvar me = this;\n\t\t\t\t\t\tChart.LinearScaleBase.prototype.convertTicksToLabels.call(me);\n\n\t\t\t\t\t\t// Point labels\n\t\t\t\t\t\tme.pointLabels = me.chart.data.labels.map(me.options.pointLabels.callback, me);\n\t\t\t\t\t},\n\t\t\t\t\tgetLabelForIndex: function getLabelForIndex(index, datasetIndex) {\n\t\t\t\t\t\treturn +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);\n\t\t\t\t\t},\n\t\t\t\t\tfit: function fit() {\n\t\t\t\t\t\tif (this.options.lineArc) {\n\t\t\t\t\t\t\t_fit(this);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfitWithPointLabels(this);\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t/**\n      * Set radius reductions and determine new radius and center point\n      * @private\n      */\n\t\t\t\t\tsetReductions: function setReductions(largestPossibleRadius, furthestLimits, furthestAngles) {\n\t\t\t\t\t\tvar me = this;\n\t\t\t\t\t\tvar radiusReductionLeft = furthestLimits.l / Math.sin(furthestAngles.l);\n\t\t\t\t\t\tvar radiusReductionRight = Math.max(furthestLimits.r - me.width, 0) / Math.sin(furthestAngles.r);\n\t\t\t\t\t\tvar radiusReductionTop = -furthestLimits.t / Math.cos(furthestAngles.t);\n\t\t\t\t\t\tvar radiusReductionBottom = -Math.max(furthestLimits.b - me.height, 0) / Math.cos(furthestAngles.b);\n\n\t\t\t\t\t\tradiusReductionLeft = numberOrZero(radiusReductionLeft);\n\t\t\t\t\t\tradiusReductionRight = numberOrZero(radiusReductionRight);\n\t\t\t\t\t\tradiusReductionTop = numberOrZero(radiusReductionTop);\n\t\t\t\t\t\tradiusReductionBottom = numberOrZero(radiusReductionBottom);\n\n\t\t\t\t\t\tme.drawingArea = Math.min(Math.round(largestPossibleRadius - (radiusReductionLeft + radiusReductionRight) / 2), Math.round(largestPossibleRadius - (radiusReductionTop + radiusReductionBottom) / 2));\n\t\t\t\t\t\tme.setCenterPoint(radiusReductionLeft, radiusReductionRight, radiusReductionTop, radiusReductionBottom);\n\t\t\t\t\t},\n\t\t\t\t\tsetCenterPoint: function setCenterPoint(leftMovement, rightMovement, topMovement, bottomMovement) {\n\t\t\t\t\t\tvar me = this;\n\t\t\t\t\t\tvar maxRight = me.width - rightMovement - me.drawingArea,\n\t\t\t\t\t\t    maxLeft = leftMovement + me.drawingArea,\n\t\t\t\t\t\t    maxTop = topMovement + me.drawingArea,\n\t\t\t\t\t\t    maxBottom = me.height - bottomMovement - me.drawingArea;\n\n\t\t\t\t\t\tme.xCenter = Math.round((maxLeft + maxRight) / 2 + me.left);\n\t\t\t\t\t\tme.yCenter = Math.round((maxTop + maxBottom) / 2 + me.top);\n\t\t\t\t\t},\n\n\t\t\t\t\tgetIndexAngle: function getIndexAngle(index) {\n\t\t\t\t\t\tvar angleMultiplier = Math.PI * 2 / getValueCount(this);\n\t\t\t\t\t\tvar startAngle = this.chart.options && this.chart.options.startAngle ? this.chart.options.startAngle : 0;\n\n\t\t\t\t\t\tvar startAngleRadians = startAngle * Math.PI * 2 / 360;\n\n\t\t\t\t\t\t// Start from the top instead of right, so remove a quarter of the circle\n\t\t\t\t\t\treturn index * angleMultiplier + startAngleRadians;\n\t\t\t\t\t},\n\t\t\t\t\tgetDistanceFromCenterForValue: function getDistanceFromCenterForValue(value) {\n\t\t\t\t\t\tvar me = this;\n\n\t\t\t\t\t\tif (value === null) {\n\t\t\t\t\t\t\treturn 0; // null always in center\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Take into account half font size + the yPadding of the top value\n\t\t\t\t\t\tvar scalingFactor = me.drawingArea / (me.max - me.min);\n\t\t\t\t\t\tif (me.options.reverse) {\n\t\t\t\t\t\t\treturn (me.max - value) * scalingFactor;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn (value - me.min) * scalingFactor;\n\t\t\t\t\t},\n\t\t\t\t\tgetPointPosition: function getPointPosition(index, distanceFromCenter) {\n\t\t\t\t\t\tvar me = this;\n\t\t\t\t\t\tvar thisAngle = me.getIndexAngle(index) - Math.PI / 2;\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tx: Math.round(Math.cos(thisAngle) * distanceFromCenter) + me.xCenter,\n\t\t\t\t\t\t\ty: Math.round(Math.sin(thisAngle) * distanceFromCenter) + me.yCenter\n\t\t\t\t\t\t};\n\t\t\t\t\t},\n\t\t\t\t\tgetPointPositionForValue: function getPointPositionForValue(index, value) {\n\t\t\t\t\t\treturn this.getPointPosition(index, this.getDistanceFromCenterForValue(value));\n\t\t\t\t\t},\n\n\t\t\t\t\tgetBasePosition: function getBasePosition() {\n\t\t\t\t\t\tvar me = this;\n\t\t\t\t\t\tvar min = me.min;\n\t\t\t\t\t\tvar max = me.max;\n\n\t\t\t\t\t\treturn me.getPointPositionForValue(0, me.beginAtZero ? 0 : min < 0 && max < 0 ? max : min > 0 && max > 0 ? min : 0);\n\t\t\t\t\t},\n\n\t\t\t\t\tdraw: function draw() {\n\t\t\t\t\t\tvar me = this;\n\t\t\t\t\t\tvar opts = me.options;\n\t\t\t\t\t\tvar gridLineOpts = opts.gridLines;\n\t\t\t\t\t\tvar tickOpts = opts.ticks;\n\t\t\t\t\t\tvar getValueOrDefault = helpers.getValueOrDefault;\n\n\t\t\t\t\t\tif (opts.display) {\n\t\t\t\t\t\t\tvar ctx = me.ctx;\n\n\t\t\t\t\t\t\t// Tick Font\n\t\t\t\t\t\t\tvar tickFontSize = getValueOrDefault(tickOpts.fontSize, globalDefaults.defaultFontSize);\n\t\t\t\t\t\t\tvar tickFontStyle = getValueOrDefault(tickOpts.fontStyle, globalDefaults.defaultFontStyle);\n\t\t\t\t\t\t\tvar tickFontFamily = getValueOrDefault(tickOpts.fontFamily, globalDefaults.defaultFontFamily);\n\t\t\t\t\t\t\tvar tickLabelFont = helpers.fontString(tickFontSize, tickFontStyle, tickFontFamily);\n\n\t\t\t\t\t\t\thelpers.each(me.ticks, function (label, index) {\n\t\t\t\t\t\t\t\t// Don't draw a centre value (if it is minimum)\n\t\t\t\t\t\t\t\tif (index > 0 || opts.reverse) {\n\t\t\t\t\t\t\t\t\tvar yCenterOffset = me.getDistanceFromCenterForValue(me.ticksAsNumbers[index]);\n\t\t\t\t\t\t\t\t\tvar yHeight = me.yCenter - yCenterOffset;\n\n\t\t\t\t\t\t\t\t\t// Draw circular lines around the scale\n\t\t\t\t\t\t\t\t\tif (gridLineOpts.display && index !== 0) {\n\t\t\t\t\t\t\t\t\t\tdrawRadiusLine(me, gridLineOpts, yCenterOffset, index);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif (tickOpts.display) {\n\t\t\t\t\t\t\t\t\t\tvar tickFontColor = getValueOrDefault(tickOpts.fontColor, globalDefaults.defaultFontColor);\n\t\t\t\t\t\t\t\t\t\tctx.font = tickLabelFont;\n\n\t\t\t\t\t\t\t\t\t\tif (tickOpts.showLabelBackdrop) {\n\t\t\t\t\t\t\t\t\t\t\tvar labelWidth = ctx.measureText(label).width;\n\t\t\t\t\t\t\t\t\t\t\tctx.fillStyle = tickOpts.backdropColor;\n\t\t\t\t\t\t\t\t\t\t\tctx.fillRect(me.xCenter - labelWidth / 2 - tickOpts.backdropPaddingX, yHeight - tickFontSize / 2 - tickOpts.backdropPaddingY, labelWidth + tickOpts.backdropPaddingX * 2, tickFontSize + tickOpts.backdropPaddingY * 2);\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tctx.textAlign = 'center';\n\t\t\t\t\t\t\t\t\t\tctx.textBaseline = 'middle';\n\t\t\t\t\t\t\t\t\t\tctx.fillStyle = tickFontColor;\n\t\t\t\t\t\t\t\t\t\tctx.fillText(label, me.xCenter, yHeight);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\tif (!opts.lineArc) {\n\t\t\t\t\t\t\t\tdrawPointLabels(me);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tChart.scaleService.registerScaleType('radialLinear', LinearRadialScale, defaultConfig);\n\t\t\t};\n\t\t}, {}], 48: [function (require, module, exports) {\n\t\t\t/* global window: false */\n\t\t\t'use strict';\n\n\t\t\tvar moment = require(1);\n\t\t\tmoment = typeof moment === 'function' ? moment : window.moment;\n\n\t\t\tmodule.exports = function (Chart) {\n\n\t\t\t\tvar helpers = Chart.helpers;\n\t\t\t\tvar time = {\n\t\t\t\t\tunits: [{\n\t\t\t\t\t\tname: 'millisecond',\n\t\t\t\t\t\tsteps: [1, 2, 5, 10, 20, 50, 100, 250, 500]\n\t\t\t\t\t}, {\n\t\t\t\t\t\tname: 'second',\n\t\t\t\t\t\tsteps: [1, 2, 5, 10, 30]\n\t\t\t\t\t}, {\n\t\t\t\t\t\tname: 'minute',\n\t\t\t\t\t\tsteps: [1, 2, 5, 10, 30]\n\t\t\t\t\t}, {\n\t\t\t\t\t\tname: 'hour',\n\t\t\t\t\t\tsteps: [1, 2, 3, 6, 12]\n\t\t\t\t\t}, {\n\t\t\t\t\t\tname: 'day',\n\t\t\t\t\t\tsteps: [1, 2, 5]\n\t\t\t\t\t}, {\n\t\t\t\t\t\tname: 'week',\n\t\t\t\t\t\tmaxStep: 4\n\t\t\t\t\t}, {\n\t\t\t\t\t\tname: 'month',\n\t\t\t\t\t\tmaxStep: 3\n\t\t\t\t\t}, {\n\t\t\t\t\t\tname: 'quarter',\n\t\t\t\t\t\tmaxStep: 4\n\t\t\t\t\t}, {\n\t\t\t\t\t\tname: 'year',\n\t\t\t\t\t\tmaxStep: false\n\t\t\t\t\t}]\n\t\t\t\t};\n\n\t\t\t\tvar defaultConfig = {\n\t\t\t\t\tposition: 'bottom',\n\n\t\t\t\t\ttime: {\n\t\t\t\t\t\tparser: false, // false == a pattern string from http://momentjs.com/docs/#/parsing/string-format/ or a custom callback that converts its argument to a moment\n\t\t\t\t\t\tformat: false, // DEPRECATED false == date objects, moment object, callback or a pattern string from http://momentjs.com/docs/#/parsing/string-format/\n\t\t\t\t\t\tunit: false, // false == automatic or override with week, month, year, etc.\n\t\t\t\t\t\tround: false, // none, or override with week, month, year, etc.\n\t\t\t\t\t\tdisplayFormat: false, // DEPRECATED\n\t\t\t\t\t\tisoWeekday: false, // override week start day - see http://momentjs.com/docs/#/get-set/iso-weekday/\n\t\t\t\t\t\tminUnit: 'millisecond',\n\n\t\t\t\t\t\t// defaults to unit's corresponding unitFormat below or override using pattern string from http://momentjs.com/docs/#/displaying/format/\n\t\t\t\t\t\tdisplayFormats: {\n\t\t\t\t\t\t\tmillisecond: 'h:mm:ss.SSS a', // 11:20:01.123 AM,\n\t\t\t\t\t\t\tsecond: 'h:mm:ss a', // 11:20:01 AM\n\t\t\t\t\t\t\tminute: 'h:mm:ss a', // 11:20:01 AM\n\t\t\t\t\t\t\thour: 'MMM D, hA', // Sept 4, 5PM\n\t\t\t\t\t\t\tday: 'll', // Sep 4 2015\n\t\t\t\t\t\t\tweek: 'll', // Week 46, or maybe \"[W]WW - YYYY\" ?\n\t\t\t\t\t\t\tmonth: 'MMM YYYY', // Sept 2015\n\t\t\t\t\t\t\tquarter: '[Q]Q - YYYY', // Q3\n\t\t\t\t\t\t\tyear: 'YYYY' // 2015\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tticks: {\n\t\t\t\t\t\tautoSkip: false\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\tvar TimeScale = Chart.Scale.extend({\n\t\t\t\t\tinitialize: function initialize() {\n\t\t\t\t\t\tif (!moment) {\n\t\t\t\t\t\t\tthrow new Error('Chart.js - Moment.js could not be found! You must include it before Chart.js to use the time scale. Download at https://momentjs.com');\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tChart.Scale.prototype.initialize.call(this);\n\t\t\t\t\t},\n\t\t\t\t\tgetLabelMoment: function getLabelMoment(datasetIndex, index) {\n\t\t\t\t\t\tif (datasetIndex === null || index === null) {\n\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (typeof this.labelMoments[datasetIndex] !== 'undefined') {\n\t\t\t\t\t\t\treturn this.labelMoments[datasetIndex][index];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t},\n\t\t\t\t\tgetLabelDiff: function getLabelDiff(datasetIndex, index) {\n\t\t\t\t\t\tvar me = this;\n\t\t\t\t\t\tif (datasetIndex === null || index === null) {\n\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (me.labelDiffs === undefined) {\n\t\t\t\t\t\t\tme.buildLabelDiffs();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (typeof me.labelDiffs[datasetIndex] !== 'undefined') {\n\t\t\t\t\t\t\treturn me.labelDiffs[datasetIndex][index];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t},\n\t\t\t\t\tgetMomentStartOf: function getMomentStartOf(tick) {\n\t\t\t\t\t\tvar me = this;\n\t\t\t\t\t\tif (me.options.time.unit === 'week' && me.options.time.isoWeekday !== false) {\n\t\t\t\t\t\t\treturn tick.clone().startOf('isoWeek').isoWeekday(me.options.time.isoWeekday);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn tick.clone().startOf(me.tickUnit);\n\t\t\t\t\t},\n\t\t\t\t\tdetermineDataLimits: function determineDataLimits() {\n\t\t\t\t\t\tvar me = this;\n\t\t\t\t\t\tme.labelMoments = [];\n\n\t\t\t\t\t\t// Only parse these once. If the dataset does not have data as x,y pairs, we will use\n\t\t\t\t\t\t// these\n\t\t\t\t\t\tvar scaleLabelMoments = [];\n\t\t\t\t\t\tif (me.chart.data.labels && me.chart.data.labels.length > 0) {\n\t\t\t\t\t\t\thelpers.each(me.chart.data.labels, function (label) {\n\t\t\t\t\t\t\t\tvar labelMoment = me.parseTime(label);\n\n\t\t\t\t\t\t\t\tif (labelMoment.isValid()) {\n\t\t\t\t\t\t\t\t\tif (me.options.time.round) {\n\t\t\t\t\t\t\t\t\t\tlabelMoment.startOf(me.options.time.round);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tscaleLabelMoments.push(labelMoment);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}, me);\n\n\t\t\t\t\t\t\tme.firstTick = moment.min.call(me, scaleLabelMoments);\n\t\t\t\t\t\t\tme.lastTick = moment.max.call(me, scaleLabelMoments);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tme.firstTick = null;\n\t\t\t\t\t\t\tme.lastTick = null;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\thelpers.each(me.chart.data.datasets, function (dataset, datasetIndex) {\n\t\t\t\t\t\t\tvar momentsForDataset = [];\n\t\t\t\t\t\t\tvar datasetVisible = me.chart.isDatasetVisible(datasetIndex);\n\n\t\t\t\t\t\t\tif (_typeof(dataset.data[0]) === 'object' && dataset.data[0] !== null) {\n\t\t\t\t\t\t\t\thelpers.each(dataset.data, function (value) {\n\t\t\t\t\t\t\t\t\tvar labelMoment = me.parseTime(me.getRightValue(value));\n\n\t\t\t\t\t\t\t\t\tif (labelMoment.isValid()) {\n\t\t\t\t\t\t\t\t\t\tif (me.options.time.round) {\n\t\t\t\t\t\t\t\t\t\t\tlabelMoment.startOf(me.options.time.round);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tmomentsForDataset.push(labelMoment);\n\n\t\t\t\t\t\t\t\t\t\tif (datasetVisible) {\n\t\t\t\t\t\t\t\t\t\t\t// May have gone outside the scale ranges, make sure we keep the first and last ticks updated\n\t\t\t\t\t\t\t\t\t\t\tme.firstTick = me.firstTick !== null ? moment.min(me.firstTick, labelMoment) : labelMoment;\n\t\t\t\t\t\t\t\t\t\t\tme.lastTick = me.lastTick !== null ? moment.max(me.lastTick, labelMoment) : labelMoment;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}, me);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// We have no labels. Use the ones from the scale\n\t\t\t\t\t\t\t\tmomentsForDataset = scaleLabelMoments;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tme.labelMoments.push(momentsForDataset);\n\t\t\t\t\t\t}, me);\n\n\t\t\t\t\t\t// Set these after we've done all the data\n\t\t\t\t\t\tif (me.options.time.min) {\n\t\t\t\t\t\t\tme.firstTick = me.parseTime(me.options.time.min);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (me.options.time.max) {\n\t\t\t\t\t\t\tme.lastTick = me.parseTime(me.options.time.max);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// We will modify these, so clone for later\n\t\t\t\t\t\tme.firstTick = (me.firstTick || moment()).clone();\n\t\t\t\t\t\tme.lastTick = (me.lastTick || moment()).clone();\n\t\t\t\t\t},\n\t\t\t\t\tbuildLabelDiffs: function buildLabelDiffs() {\n\t\t\t\t\t\tvar me = this;\n\t\t\t\t\t\tme.labelDiffs = [];\n\t\t\t\t\t\tvar scaleLabelDiffs = [];\n\t\t\t\t\t\t// Parse common labels once\n\t\t\t\t\t\tif (me.chart.data.labels && me.chart.data.labels.length > 0) {\n\t\t\t\t\t\t\thelpers.each(me.chart.data.labels, function (label) {\n\t\t\t\t\t\t\t\tvar labelMoment = me.parseTime(label);\n\n\t\t\t\t\t\t\t\tif (labelMoment.isValid()) {\n\t\t\t\t\t\t\t\t\tif (me.options.time.round) {\n\t\t\t\t\t\t\t\t\t\tlabelMoment.startOf(me.options.time.round);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tscaleLabelDiffs.push(labelMoment.diff(me.firstTick, me.tickUnit, true));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}, me);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\thelpers.each(me.chart.data.datasets, function (dataset) {\n\t\t\t\t\t\t\tvar diffsForDataset = [];\n\n\t\t\t\t\t\t\tif (_typeof(dataset.data[0]) === 'object' && dataset.data[0] !== null) {\n\t\t\t\t\t\t\t\thelpers.each(dataset.data, function (value) {\n\t\t\t\t\t\t\t\t\tvar labelMoment = me.parseTime(me.getRightValue(value));\n\n\t\t\t\t\t\t\t\t\tif (labelMoment.isValid()) {\n\t\t\t\t\t\t\t\t\t\tif (me.options.time.round) {\n\t\t\t\t\t\t\t\t\t\t\tlabelMoment.startOf(me.options.time.round);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tdiffsForDataset.push(labelMoment.diff(me.firstTick, me.tickUnit, true));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}, me);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// We have no labels. Use common ones\n\t\t\t\t\t\t\t\tdiffsForDataset = scaleLabelDiffs;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tme.labelDiffs.push(diffsForDataset);\n\t\t\t\t\t\t}, me);\n\t\t\t\t\t},\n\t\t\t\t\tbuildTicks: function buildTicks() {\n\t\t\t\t\t\tvar me = this;\n\n\t\t\t\t\t\tme.ctx.save();\n\t\t\t\t\t\tvar tickFontSize = helpers.getValueOrDefault(me.options.ticks.fontSize, Chart.defaults.global.defaultFontSize);\n\t\t\t\t\t\tvar tickFontStyle = helpers.getValueOrDefault(me.options.ticks.fontStyle, Chart.defaults.global.defaultFontStyle);\n\t\t\t\t\t\tvar tickFontFamily = helpers.getValueOrDefault(me.options.ticks.fontFamily, Chart.defaults.global.defaultFontFamily);\n\t\t\t\t\t\tvar tickLabelFont = helpers.fontString(tickFontSize, tickFontStyle, tickFontFamily);\n\t\t\t\t\t\tme.ctx.font = tickLabelFont;\n\n\t\t\t\t\t\tme.ticks = [];\n\t\t\t\t\t\tme.unitScale = 1; // How much we scale the unit by, ie 2 means 2x unit per step\n\t\t\t\t\t\tme.scaleSizeInUnits = 0; // How large the scale is in the base unit (seconds, minutes, etc)\n\n\t\t\t\t\t\t// Set unit override if applicable\n\t\t\t\t\t\tif (me.options.time.unit) {\n\t\t\t\t\t\t\tme.tickUnit = me.options.time.unit || 'day';\n\t\t\t\t\t\t\tme.displayFormat = me.options.time.displayFormats[me.tickUnit];\n\t\t\t\t\t\t\tme.scaleSizeInUnits = me.lastTick.diff(me.firstTick, me.tickUnit, true);\n\t\t\t\t\t\t\tme.unitScale = helpers.getValueOrDefault(me.options.time.unitStepSize, 1);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Determine the smallest needed unit of the time\n\t\t\t\t\t\t\tvar innerWidth = me.isHorizontal() ? me.width : me.height;\n\n\t\t\t\t\t\t\t// Crude approximation of what the label length might be\n\t\t\t\t\t\t\tvar tempFirstLabel = me.tickFormatFunction(me.firstTick, 0, []);\n\t\t\t\t\t\t\tvar tickLabelWidth = me.ctx.measureText(tempFirstLabel).width;\n\t\t\t\t\t\t\tvar cosRotation = Math.cos(helpers.toRadians(me.options.ticks.maxRotation));\n\t\t\t\t\t\t\tvar sinRotation = Math.sin(helpers.toRadians(me.options.ticks.maxRotation));\n\t\t\t\t\t\t\ttickLabelWidth = tickLabelWidth * cosRotation + tickFontSize * sinRotation;\n\t\t\t\t\t\t\tvar labelCapacity = innerWidth / tickLabelWidth;\n\n\t\t\t\t\t\t\t// Start as small as possible\n\t\t\t\t\t\t\tme.tickUnit = me.options.time.minUnit;\n\t\t\t\t\t\t\tme.scaleSizeInUnits = me.lastTick.diff(me.firstTick, me.tickUnit, true);\n\t\t\t\t\t\t\tme.displayFormat = me.options.time.displayFormats[me.tickUnit];\n\n\t\t\t\t\t\t\tvar unitDefinitionIndex = 0;\n\t\t\t\t\t\t\tvar unitDefinition = time.units[unitDefinitionIndex];\n\n\t\t\t\t\t\t\t// While we aren't ideal and we don't have units left\n\t\t\t\t\t\t\twhile (unitDefinitionIndex < time.units.length) {\n\t\t\t\t\t\t\t\t// Can we scale this unit. If `false` we can scale infinitely\n\t\t\t\t\t\t\t\tme.unitScale = 1;\n\n\t\t\t\t\t\t\t\tif (helpers.isArray(unitDefinition.steps) && Math.ceil(me.scaleSizeInUnits / labelCapacity) < helpers.max(unitDefinition.steps)) {\n\t\t\t\t\t\t\t\t\t// Use one of the predefined steps\n\t\t\t\t\t\t\t\t\tfor (var idx = 0; idx < unitDefinition.steps.length; ++idx) {\n\t\t\t\t\t\t\t\t\t\tif (unitDefinition.steps[idx] >= Math.ceil(me.scaleSizeInUnits / labelCapacity)) {\n\t\t\t\t\t\t\t\t\t\t\tme.unitScale = helpers.getValueOrDefault(me.options.time.unitStepSize, unitDefinition.steps[idx]);\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t} else if (unitDefinition.maxStep === false || Math.ceil(me.scaleSizeInUnits / labelCapacity) < unitDefinition.maxStep) {\n\t\t\t\t\t\t\t\t\t// We have a max step. Scale this unit\n\t\t\t\t\t\t\t\t\tme.unitScale = helpers.getValueOrDefault(me.options.time.unitStepSize, Math.ceil(me.scaleSizeInUnits / labelCapacity));\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t// Move to the next unit up\n\t\t\t\t\t\t\t\t\t++unitDefinitionIndex;\n\t\t\t\t\t\t\t\t\tunitDefinition = time.units[unitDefinitionIndex];\n\n\t\t\t\t\t\t\t\t\tme.tickUnit = unitDefinition.name;\n\t\t\t\t\t\t\t\t\tvar leadingUnitBuffer = me.firstTick.diff(me.getMomentStartOf(me.firstTick), me.tickUnit, true);\n\t\t\t\t\t\t\t\t\tvar trailingUnitBuffer = me.getMomentStartOf(me.lastTick.clone().add(1, me.tickUnit)).diff(me.lastTick, me.tickUnit, true);\n\t\t\t\t\t\t\t\t\tme.scaleSizeInUnits = me.lastTick.diff(me.firstTick, me.tickUnit, true) + leadingUnitBuffer + trailingUnitBuffer;\n\t\t\t\t\t\t\t\t\tme.displayFormat = me.options.time.displayFormats[unitDefinition.name];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar roundedStart;\n\n\t\t\t\t\t\t// Only round the first tick if we have no hard minimum\n\t\t\t\t\t\tif (!me.options.time.min) {\n\t\t\t\t\t\t\tme.firstTick = me.getMomentStartOf(me.firstTick);\n\t\t\t\t\t\t\troundedStart = me.firstTick;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\troundedStart = me.getMomentStartOf(me.firstTick);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Only round the last tick if we have no hard maximum\n\t\t\t\t\t\tif (!me.options.time.max) {\n\t\t\t\t\t\t\tvar roundedEnd = me.getMomentStartOf(me.lastTick);\n\t\t\t\t\t\t\tvar delta = roundedEnd.diff(me.lastTick, me.tickUnit, true);\n\t\t\t\t\t\t\tif (delta < 0) {\n\t\t\t\t\t\t\t\t// Do not use end of because we need me to be in the next time unit\n\t\t\t\t\t\t\t\tme.lastTick = me.getMomentStartOf(me.lastTick.add(1, me.tickUnit));\n\t\t\t\t\t\t\t} else if (delta >= 0) {\n\t\t\t\t\t\t\t\tme.lastTick = roundedEnd;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tme.scaleSizeInUnits = me.lastTick.diff(me.firstTick, me.tickUnit, true);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Tick displayFormat override\n\t\t\t\t\t\tif (me.options.time.displayFormat) {\n\t\t\t\t\t\t\tme.displayFormat = me.options.time.displayFormat;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// first tick. will have been rounded correctly if options.time.min is not specified\n\t\t\t\t\t\tme.ticks.push(me.firstTick.clone());\n\n\t\t\t\t\t\t// For every unit in between the first and last moment, create a moment and add it to the ticks tick\n\t\t\t\t\t\tfor (var i = me.unitScale; i <= me.scaleSizeInUnits; i += me.unitScale) {\n\t\t\t\t\t\t\tvar newTick = roundedStart.clone().add(i, me.tickUnit);\n\n\t\t\t\t\t\t\t// Are we greater than the max time\n\t\t\t\t\t\t\tif (me.options.time.max && newTick.diff(me.lastTick, me.tickUnit, true) >= 0) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tme.ticks.push(newTick);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Always show the right tick\n\t\t\t\t\t\tvar diff = me.ticks[me.ticks.length - 1].diff(me.lastTick, me.tickUnit);\n\t\t\t\t\t\tif (diff !== 0 || me.scaleSizeInUnits === 0) {\n\t\t\t\t\t\t\t// this is a weird case. If the <max> option is the same as the end option, we can't just diff the times because the tick was created from the roundedStart\n\t\t\t\t\t\t\t// but the last tick was not rounded.\n\t\t\t\t\t\t\tif (me.options.time.max) {\n\t\t\t\t\t\t\t\tme.ticks.push(me.lastTick.clone());\n\t\t\t\t\t\t\t\tme.scaleSizeInUnits = me.lastTick.diff(me.ticks[0], me.tickUnit, true);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tme.ticks.push(me.lastTick.clone());\n\t\t\t\t\t\t\t\tme.scaleSizeInUnits = me.lastTick.diff(me.firstTick, me.tickUnit, true);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tme.ctx.restore();\n\n\t\t\t\t\t\t// Invalidate label diffs cache\n\t\t\t\t\t\tme.labelDiffs = undefined;\n\t\t\t\t\t},\n\t\t\t\t\t// Get tooltip label\n\t\t\t\t\tgetLabelForIndex: function getLabelForIndex(index, datasetIndex) {\n\t\t\t\t\t\tvar me = this;\n\t\t\t\t\t\tvar label = me.chart.data.labels && index < me.chart.data.labels.length ? me.chart.data.labels[index] : '';\n\t\t\t\t\t\tvar value = me.chart.data.datasets[datasetIndex].data[index];\n\n\t\t\t\t\t\tif (value !== null && (typeof value === \"undefined\" ? \"undefined\" : _typeof(value)) === 'object') {\n\t\t\t\t\t\t\tlabel = me.getRightValue(value);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Format nicely\n\t\t\t\t\t\tif (me.options.time.tooltipFormat) {\n\t\t\t\t\t\t\tlabel = me.parseTime(label).format(me.options.time.tooltipFormat);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn label;\n\t\t\t\t\t},\n\t\t\t\t\t// Function to format an individual tick mark\n\t\t\t\t\ttickFormatFunction: function tickFormatFunction(tick, index, ticks) {\n\t\t\t\t\t\tvar formattedTick = tick.format(this.displayFormat);\n\t\t\t\t\t\tvar tickOpts = this.options.ticks;\n\t\t\t\t\t\tvar callback = helpers.getValueOrDefault(tickOpts.callback, tickOpts.userCallback);\n\n\t\t\t\t\t\tif (callback) {\n\t\t\t\t\t\t\treturn callback(formattedTick, index, ticks);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn formattedTick;\n\t\t\t\t\t},\n\t\t\t\t\tconvertTicksToLabels: function convertTicksToLabels() {\n\t\t\t\t\t\tvar me = this;\n\t\t\t\t\t\tme.tickMoments = me.ticks;\n\t\t\t\t\t\tme.ticks = me.ticks.map(me.tickFormatFunction, me);\n\t\t\t\t\t},\n\t\t\t\t\tgetPixelForValue: function getPixelForValue(value, index, datasetIndex) {\n\t\t\t\t\t\tvar me = this;\n\t\t\t\t\t\tvar offset = null;\n\t\t\t\t\t\tif (index !== undefined && datasetIndex !== undefined) {\n\t\t\t\t\t\t\toffset = me.getLabelDiff(datasetIndex, index);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (offset === null) {\n\t\t\t\t\t\t\tif (!value || !value.isValid) {\n\t\t\t\t\t\t\t\t// not already a moment object\n\t\t\t\t\t\t\t\tvalue = me.parseTime(me.getRightValue(value));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (value && value.isValid && value.isValid()) {\n\t\t\t\t\t\t\t\toffset = value.diff(me.firstTick, me.tickUnit, true);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (offset !== null) {\n\t\t\t\t\t\t\tvar decimal = offset !== 0 ? offset / me.scaleSizeInUnits : offset;\n\n\t\t\t\t\t\t\tif (me.isHorizontal()) {\n\t\t\t\t\t\t\t\tvar valueOffset = me.width * decimal;\n\t\t\t\t\t\t\t\treturn me.left + Math.round(valueOffset);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tvar heightOffset = me.height * decimal;\n\t\t\t\t\t\t\treturn me.top + Math.round(heightOffset);\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tgetPixelForTick: function getPixelForTick(index) {\n\t\t\t\t\t\treturn this.getPixelForValue(this.tickMoments[index], null, null);\n\t\t\t\t\t},\n\t\t\t\t\tgetValueForPixel: function getValueForPixel(pixel) {\n\t\t\t\t\t\tvar me = this;\n\t\t\t\t\t\tvar innerDimension = me.isHorizontal() ? me.width : me.height;\n\t\t\t\t\t\tvar offset = (pixel - (me.isHorizontal() ? me.left : me.top)) / innerDimension;\n\t\t\t\t\t\toffset *= me.scaleSizeInUnits;\n\t\t\t\t\t\treturn me.firstTick.clone().add(moment.duration(offset, me.tickUnit).asSeconds(), 'seconds');\n\t\t\t\t\t},\n\t\t\t\t\tparseTime: function parseTime(label) {\n\t\t\t\t\t\tvar me = this;\n\t\t\t\t\t\tif (typeof me.options.time.parser === 'string') {\n\t\t\t\t\t\t\treturn moment(label, me.options.time.parser);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (typeof me.options.time.parser === 'function') {\n\t\t\t\t\t\t\treturn me.options.time.parser(label);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Date objects\n\t\t\t\t\t\tif (typeof label.getMonth === 'function' || typeof label === 'number') {\n\t\t\t\t\t\t\treturn moment(label);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Moment support\n\t\t\t\t\t\tif (label.isValid && label.isValid()) {\n\t\t\t\t\t\t\treturn label;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Custom parsing (return an instance of moment)\n\t\t\t\t\t\tif (typeof me.options.time.format !== 'string' && me.options.time.format.call) {\n\t\t\t\t\t\t\tconsole.warn('options.time.format is deprecated and replaced by options.time.parser. See http://nnnick.github.io/Chart.js/docs-v2/#scales-time-scale');\n\t\t\t\t\t\t\treturn me.options.time.format(label);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Moment format parsing\n\t\t\t\t\t\treturn moment(label, me.options.time.format);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tChart.scaleService.registerScaleType('time', TimeScale, defaultConfig);\n\t\t\t};\n\t\t}, { \"1\": 1 }] }, {}, [7])(7);\n});\n'use strict';\n\n(function ($) {\n\n\t$(document).ready(function () {\n\n\t\t// Clicking the Legend to remove things from view is weird\n\t\tChart.defaults.pie.legend.onClick = function () {};\n\n\t\t$('.chart-container').each(function (index, container) {\n\n\t\t\tvar $chart = $(container).find('canvas'),\n\t\t\t    chartData = $chart.data('chart_data');\n\n\t\t\tif (chartData.length > 0) {\n\n\t\t\t\tvar labels = [],\n\t\t\t\t    values = [],\n\t\t\t\t    colors = [];\n\n\t\t\t\tfor (var index in chartData) {\n\n\t\t\t\t\tlabels.push(chartData[index].label);\n\t\t\t\t\tvalues.push(chartData[index].percentage);\n\t\t\t\t\tcolors.push(chartData[index].color);\n\t\t\t\t}\n\n\t\t\t\tvar chart = new Chart($chart, {\n\t\t\t\t\ttype: 'pie',\n\t\t\t\t\tdata: {\n\t\t\t\t\t\tlabels: labels,\n\t\t\t\t\t\tdatasets: [{\n\t\t\t\t\t\t\tdata: values,\n\t\t\t\t\t\t\tbackgroundColor: colors\n\t\t\t\t\t\t}]\n\t\t\t\t\t},\n\t\t\t\t\toptions: {\n\t\t\t\t\t\ttooltips: {\n\t\t\t\t\t\t\tcallbacks: {\n\t\t\t\t\t\t\t\tlabel: function label(tooltipItem, data) {\n\n\t\t\t\t\t\t\t\t\tvar allData = data.datasets[tooltipItem.datasetIndex].data,\n\t\t\t\t\t\t\t\t\t    tooltipLabel = data.labels[tooltipItem.index],\n\t\t\t\t\t\t\t\t\t    tooltipData = allData[tooltipItem.index];\n\n\t\t\t\t\t\t\t\t\treturn ' ' + tooltipLabel + ': ' + tooltipData + '%';\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t});\n})(jQuery);\n\"use strict\";\n\n(function ($) {\n\n    $(document).ready(function () {\n\n        $(document).foundation();\n    });\n})(jQuery);","!function($) {\n\n\"use strict\";\n\nvar FOUNDATION_VERSION = '6.3.1';\n\n// Global Foundation object\n// This is attached to the window, or used as a module for AMD/Browserify\nvar Foundation = {\n  version: FOUNDATION_VERSION,\n\n  /**\n   * Stores initialized plugins.\n   */\n  _plugins: {},\n\n  /**\n   * Stores generated unique ids for plugin instances\n   */\n  _uuids: [],\n\n  /**\n   * Returns a boolean for RTL support\n   */\n  rtl: function(){\n    return $('html').attr('dir') === 'rtl';\n  },\n  /**\n   * Defines a Foundation plugin, adding it to the `Foundation` namespace and the list of plugins to initialize when reflowing.\n   * @param {Object} plugin - The constructor of the plugin.\n   */\n  plugin: function(plugin, name) {\n    // Object key to use when adding to global Foundation object\n    // Examples: Foundation.Reveal, Foundation.OffCanvas\n    var className = (name || functionName(plugin));\n    // Object key to use when storing the plugin, also used to create the identifying data attribute for the plugin\n    // Examples: data-reveal, data-off-canvas\n    var attrName  = hyphenate(className);\n\n    // Add to the Foundation object and the plugins list (for reflowing)\n    this._plugins[attrName] = this[className] = plugin;\n  },\n  /**\n   * @function\n   * Populates the _uuids array with pointers to each individual plugin instance.\n   * Adds the `zfPlugin` data-attribute to programmatically created plugins to allow use of $(selector).foundation(method) calls.\n   * Also fires the initialization event for each plugin, consolidating repetitive code.\n   * @param {Object} plugin - an instance of a plugin, usually `this` in context.\n   * @param {String} name - the name of the plugin, passed as a camelCased string.\n   * @fires Plugin#init\n   */\n  registerPlugin: function(plugin, name){\n    var pluginName = name ? hyphenate(name) : functionName(plugin.constructor).toLowerCase();\n    plugin.uuid = this.GetYoDigits(6, pluginName);\n\n    if(!plugin.$element.attr(`data-${pluginName}`)){ plugin.$element.attr(`data-${pluginName}`, plugin.uuid); }\n    if(!plugin.$element.data('zfPlugin')){ plugin.$element.data('zfPlugin', plugin); }\n          /**\n           * Fires when the plugin has initialized.\n           * @event Plugin#init\n           */\n    plugin.$element.trigger(`init.zf.${pluginName}`);\n\n    this._uuids.push(plugin.uuid);\n\n    return;\n  },\n  /**\n   * @function\n   * Removes the plugins uuid from the _uuids array.\n   * Removes the zfPlugin data attribute, as well as the data-plugin-name attribute.\n   * Also fires the destroyed event for the plugin, consolidating repetitive code.\n   * @param {Object} plugin - an instance of a plugin, usually `this` in context.\n   * @fires Plugin#destroyed\n   */\n  unregisterPlugin: function(plugin){\n    var pluginName = hyphenate(functionName(plugin.$element.data('zfPlugin').constructor));\n\n    this._uuids.splice(this._uuids.indexOf(plugin.uuid), 1);\n    plugin.$element.removeAttr(`data-${pluginName}`).removeData('zfPlugin')\n          /**\n           * Fires when the plugin has been destroyed.\n           * @event Plugin#destroyed\n           */\n          .trigger(`destroyed.zf.${pluginName}`);\n    for(var prop in plugin){\n      plugin[prop] = null;//clean up script to prep for garbage collection.\n    }\n    return;\n  },\n\n  /**\n   * @function\n   * Causes one or more active plugins to re-initialize, resetting event listeners, recalculating positions, etc.\n   * @param {String} plugins - optional string of an individual plugin key, attained by calling `$(element).data('pluginName')`, or string of a plugin class i.e. `'dropdown'`\n   * @default If no argument is passed, reflow all currently active plugins.\n   */\n   reInit: function(plugins){\n     var isJQ = plugins instanceof $;\n     try{\n       if(isJQ){\n         plugins.each(function(){\n           $(this).data('zfPlugin')._init();\n         });\n       }else{\n         var type = typeof plugins,\n         _this = this,\n         fns = {\n           'object': function(plgs){\n             plgs.forEach(function(p){\n               p = hyphenate(p);\n               $('[data-'+ p +']').foundation('_init');\n             });\n           },\n           'string': function(){\n             plugins = hyphenate(plugins);\n             $('[data-'+ plugins +']').foundation('_init');\n           },\n           'undefined': function(){\n             this['object'](Object.keys(_this._plugins));\n           }\n         };\n         fns[type](plugins);\n       }\n     }catch(err){\n       console.error(err);\n     }finally{\n       return plugins;\n     }\n   },\n\n  /**\n   * returns a random base-36 uid with namespacing\n   * @function\n   * @param {Number} length - number of random base-36 digits desired. Increase for more random strings.\n   * @param {String} namespace - name of plugin to be incorporated in uid, optional.\n   * @default {String} '' - if no plugin name is provided, nothing is appended to the uid.\n   * @returns {String} - unique id\n   */\n  GetYoDigits: function(length, namespace){\n    length = length || 6;\n    return Math.round((Math.pow(36, length + 1) - Math.random() * Math.pow(36, length))).toString(36).slice(1) + (namespace ? `-${namespace}` : '');\n  },\n  /**\n   * Initialize plugins on any elements within `elem` (and `elem` itself) that aren't already initialized.\n   * @param {Object} elem - jQuery object containing the element to check inside. Also checks the element itself, unless it's the `document` object.\n   * @param {String|Array} plugins - A list of plugins to initialize. Leave this out to initialize everything.\n   */\n  reflow: function(elem, plugins) {\n\n    // If plugins is undefined, just grab everything\n    if (typeof plugins === 'undefined') {\n      plugins = Object.keys(this._plugins);\n    }\n    // If plugins is a string, convert it to an array with one item\n    else if (typeof plugins === 'string') {\n      plugins = [plugins];\n    }\n\n    var _this = this;\n\n    // Iterate through each plugin\n    $.each(plugins, function(i, name) {\n      // Get the current plugin\n      var plugin = _this._plugins[name];\n\n      // Localize the search to all elements inside elem, as well as elem itself, unless elem === document\n      var $elem = $(elem).find('[data-'+name+']').addBack('[data-'+name+']');\n\n      // For each plugin found, initialize it\n      $elem.each(function() {\n        var $el = $(this),\n            opts = {};\n        // Don't double-dip on plugins\n        if ($el.data('zfPlugin')) {\n          console.warn(\"Tried to initialize \"+name+\" on an element that already has a Foundation plugin.\");\n          return;\n        }\n\n        if($el.attr('data-options')){\n          var thing = $el.attr('data-options').split(';').forEach(function(e, i){\n            var opt = e.split(':').map(function(el){ return el.trim(); });\n            if(opt[0]) opts[opt[0]] = parseValue(opt[1]);\n          });\n        }\n        try{\n          $el.data('zfPlugin', new plugin($(this), opts));\n        }catch(er){\n          console.error(er);\n        }finally{\n          return;\n        }\n      });\n    });\n  },\n  getFnName: functionName,\n  transitionend: function($elem){\n    var transitions = {\n      'transition': 'transitionend',\n      'WebkitTransition': 'webkitTransitionEnd',\n      'MozTransition': 'transitionend',\n      'OTransition': 'otransitionend'\n    };\n    var elem = document.createElement('div'),\n        end;\n\n    for (var t in transitions){\n      if (typeof elem.style[t] !== 'undefined'){\n        end = transitions[t];\n      }\n    }\n    if(end){\n      return end;\n    }else{\n      end = setTimeout(function(){\n        $elem.triggerHandler('transitionend', [$elem]);\n      }, 1);\n      return 'transitionend';\n    }\n  }\n};\n\nFoundation.util = {\n  /**\n   * Function for applying a debounce effect to a function call.\n   * @function\n   * @param {Function} func - Function to be called at end of timeout.\n   * @param {Number} delay - Time in ms to delay the call of `func`.\n   * @returns function\n   */\n  throttle: function (func, delay) {\n    var timer = null;\n\n    return function () {\n      var context = this, args = arguments;\n\n      if (timer === null) {\n        timer = setTimeout(function () {\n          func.apply(context, args);\n          timer = null;\n        }, delay);\n      }\n    };\n  }\n};\n\n// TODO: consider not making this a jQuery function\n// TODO: need way to reflow vs. re-initialize\n/**\n * The Foundation jQuery method.\n * @param {String|Array} method - An action to perform on the current jQuery object.\n */\nvar foundation = function(method) {\n  var type = typeof method,\n      $meta = $('meta.foundation-mq'),\n      $noJS = $('.no-js');\n\n  if(!$meta.length){\n    $('<meta class=\"foundation-mq\">').appendTo(document.head);\n  }\n  if($noJS.length){\n    $noJS.removeClass('no-js');\n  }\n\n  if(type === 'undefined'){//needs to initialize the Foundation object, or an individual plugin.\n    Foundation.MediaQuery._init();\n    Foundation.reflow(this);\n  }else if(type === 'string'){//an individual method to invoke on a plugin or group of plugins\n    var args = Array.prototype.slice.call(arguments, 1);//collect all the arguments, if necessary\n    var plugClass = this.data('zfPlugin');//determine the class of plugin\n\n    if(plugClass !== undefined && plugClass[method] !== undefined){//make sure both the class and method exist\n      if(this.length === 1){//if there's only one, call it directly.\n          plugClass[method].apply(plugClass, args);\n      }else{\n        this.each(function(i, el){//otherwise loop through the jQuery collection and invoke the method on each\n          plugClass[method].apply($(el).data('zfPlugin'), args);\n        });\n      }\n    }else{//error for no class or no method\n      throw new ReferenceError(\"We're sorry, '\" + method + \"' is not an available method for \" + (plugClass ? functionName(plugClass) : 'this element') + '.');\n    }\n  }else{//error for invalid argument type\n    throw new TypeError(`We're sorry, ${type} is not a valid parameter. You must use a string representing the method you wish to invoke.`);\n  }\n  return this;\n};\n\nwindow.Foundation = Foundation;\n$.fn.foundation = foundation;\n\n// Polyfill for requestAnimationFrame\n(function() {\n  if (!Date.now || !window.Date.now)\n    window.Date.now = Date.now = function() { return new Date().getTime(); };\n\n  var vendors = ['webkit', 'moz'];\n  for (var i = 0; i < vendors.length && !window.requestAnimationFrame; ++i) {\n      var vp = vendors[i];\n      window.requestAnimationFrame = window[vp+'RequestAnimationFrame'];\n      window.cancelAnimationFrame = (window[vp+'CancelAnimationFrame']\n                                 || window[vp+'CancelRequestAnimationFrame']);\n  }\n  if (/iP(ad|hone|od).*OS 6/.test(window.navigator.userAgent)\n    || !window.requestAnimationFrame || !window.cancelAnimationFrame) {\n    var lastTime = 0;\n    window.requestAnimationFrame = function(callback) {\n        var now = Date.now();\n        var nextTime = Math.max(lastTime + 16, now);\n        return setTimeout(function() { callback(lastTime = nextTime); },\n                          nextTime - now);\n    };\n    window.cancelAnimationFrame = clearTimeout;\n  }\n  /**\n   * Polyfill for performance.now, required by rAF\n   */\n  if(!window.performance || !window.performance.now){\n    window.performance = {\n      start: Date.now(),\n      now: function(){ return Date.now() - this.start; }\n    };\n  }\n})();\nif (!Function.prototype.bind) {\n  Function.prototype.bind = function(oThis) {\n    if (typeof this !== 'function') {\n      // closest thing possible to the ECMAScript 5\n      // internal IsCallable function\n      throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');\n    }\n\n    var aArgs   = Array.prototype.slice.call(arguments, 1),\n        fToBind = this,\n        fNOP    = function() {},\n        fBound  = function() {\n          return fToBind.apply(this instanceof fNOP\n                 ? this\n                 : oThis,\n                 aArgs.concat(Array.prototype.slice.call(arguments)));\n        };\n\n    if (this.prototype) {\n      // native functions don't have a prototype\n      fNOP.prototype = this.prototype;\n    }\n    fBound.prototype = new fNOP();\n\n    return fBound;\n  };\n}\n// Polyfill to get the name of a function in IE9\nfunction functionName(fn) {\n  if (Function.prototype.name === undefined) {\n    var funcNameRegex = /function\\s([^(]{1,})\\(/;\n    var results = (funcNameRegex).exec((fn).toString());\n    return (results && results.length > 1) ? results[1].trim() : \"\";\n  }\n  else if (fn.prototype === undefined) {\n    return fn.constructor.name;\n  }\n  else {\n    return fn.prototype.constructor.name;\n  }\n}\nfunction parseValue(str){\n  if ('true' === str) return true;\n  else if ('false' === str) return false;\n  else if (!isNaN(str * 1)) return parseFloat(str);\n  return str;\n}\n// Convert PascalCase to kebab-case\n// Thank you: http://stackoverflow.com/a/8955580\nfunction hyphenate(str) {\n  return str.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();\n}\n\n}(jQuery);\n","/*******************************************\n *                                         *\n * This util was created by Marius Olbertz *\n * Please thank Marius on GitHub /owlbertz *\n * or the web http://www.mariusolbertz.de/ *\n *                                         *\n ******************************************/\n\n'use strict';\n\n!function($) {\n\nconst keyCodes = {\n  9: 'TAB',\n  13: 'ENTER',\n  27: 'ESCAPE',\n  32: 'SPACE',\n  37: 'ARROW_LEFT',\n  38: 'ARROW_UP',\n  39: 'ARROW_RIGHT',\n  40: 'ARROW_DOWN'\n}\n\nvar commands = {}\n\nvar Keyboard = {\n  keys: getKeyCodes(keyCodes),\n\n  /**\n   * Parses the (keyboard) event and returns a String that represents its key\n   * Can be used like Foundation.parseKey(event) === Foundation.keys.SPACE\n   * @param {Event} event - the event generated by the event handler\n   * @return String key - String that represents the key pressed\n   */\n  parseKey(event) {\n    var key = keyCodes[event.which || event.keyCode] || String.fromCharCode(event.which).toUpperCase();\n\n    // Remove un-printable characters, e.g. for `fromCharCode` calls for CTRL only events\n    key = key.replace(/\\W+/, '');\n\n    if (event.shiftKey) key = `SHIFT_${key}`;\n    if (event.ctrlKey) key = `CTRL_${key}`;\n    if (event.altKey) key = `ALT_${key}`;\n\n    // Remove trailing underscore, in case only modifiers were used (e.g. only `CTRL_ALT`)\n    key = key.replace(/_$/, '');\n\n    return key;\n  },\n\n  /**\n   * Handles the given (keyboard) event\n   * @param {Event} event - the event generated by the event handler\n   * @param {String} component - Foundation component's name, e.g. Slider or Reveal\n   * @param {Objects} functions - collection of functions that are to be executed\n   */\n  handleKey(event, component, functions) {\n    var commandList = commands[component],\n      keyCode = this.parseKey(event),\n      cmds,\n      command,\n      fn;\n\n    if (!commandList) return console.warn('Component not defined!');\n\n    if (typeof commandList.ltr === 'undefined') { // this component does not differentiate between ltr and rtl\n        cmds = commandList; // use plain list\n    } else { // merge ltr and rtl: if document is rtl, rtl overwrites ltr and vice versa\n        if (Foundation.rtl()) cmds = $.extend({}, commandList.ltr, commandList.rtl);\n\n        else cmds = $.extend({}, commandList.rtl, commandList.ltr);\n    }\n    command = cmds[keyCode];\n\n    fn = functions[command];\n    if (fn && typeof fn === 'function') { // execute function  if exists\n      var returnValue = fn.apply();\n      if (functions.handled || typeof functions.handled === 'function') { // execute function when event was handled\n          functions.handled(returnValue);\n      }\n    } else {\n      if (functions.unhandled || typeof functions.unhandled === 'function') { // execute function when event was not handled\n          functions.unhandled();\n      }\n    }\n  },\n\n  /**\n   * Finds all focusable elements within the given `$element`\n   * @param {jQuery} $element - jQuery object to search within\n   * @return {jQuery} $focusable - all focusable elements within `$element`\n   */\n  findFocusable($element) {\n    if(!$element) {return false; }\n    return $element.find('a[href], area[href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), button:not([disabled]), iframe, object, embed, *[tabindex], *[contenteditable]').filter(function() {\n      if (!$(this).is(':visible') || $(this).attr('tabindex') < 0) { return false; } //only have visible elements and those that have a tabindex greater or equal 0\n      return true;\n    });\n  },\n\n  /**\n   * Returns the component name name\n   * @param {Object} component - Foundation component, e.g. Slider or Reveal\n   * @return String componentName\n   */\n\n  register(componentName, cmds) {\n    commands[componentName] = cmds;\n  },  \n\n  /**\n   * Traps the focus in the given element.\n   * @param  {jQuery} $element  jQuery object to trap the foucs into.\n   */\n  trapFocus($element) {\n    var $focusable = Foundation.Keyboard.findFocusable($element),\n        $firstFocusable = $focusable.eq(0),\n        $lastFocusable = $focusable.eq(-1);\n\n    $element.on('keydown.zf.trapfocus', function(event) {\n      if (event.target === $lastFocusable[0] && Foundation.Keyboard.parseKey(event) === 'TAB') {\n        event.preventDefault();\n        $firstFocusable.focus();\n      }\n      else if (event.target === $firstFocusable[0] && Foundation.Keyboard.parseKey(event) === 'SHIFT_TAB') {\n        event.preventDefault();\n        $lastFocusable.focus();\n      }\n    });\n  },\n  /**\n   * Releases the trapped focus from the given element.\n   * @param  {jQuery} $element  jQuery object to release the focus for.\n   */\n  releaseFocus($element) {\n    $element.off('keydown.zf.trapfocus');\n  }\n}\n\n/*\n * Constants for easier comparing.\n * Can be used like Foundation.parseKey(event) === Foundation.keys.SPACE\n */\nfunction getKeyCodes(kcs) {\n  var k = {};\n  for (var kc in kcs) k[kcs[kc]] = kcs[kc];\n  return k;\n}\n\nFoundation.Keyboard = Keyboard;\n\n}(jQuery);\n","'use strict';\n\n!function($) {\n\nFoundation.Box = {\n  ImNotTouchingYou: ImNotTouchingYou,\n  GetDimensions: GetDimensions,\n  GetOffsets: GetOffsets\n}\n\n/**\n * Compares the dimensions of an element to a container and determines collision events with container.\n * @function\n * @param {jQuery} element - jQuery object to test for collisions.\n * @param {jQuery} parent - jQuery object to use as bounding container.\n * @param {Boolean} lrOnly - set to true to check left and right values only.\n * @param {Boolean} tbOnly - set to true to check top and bottom values only.\n * @default if no parent object passed, detects collisions with `window`.\n * @returns {Boolean} - true if collision free, false if a collision in any direction.\n */\nfunction ImNotTouchingYou(element, parent, lrOnly, tbOnly) {\n  var eleDims = GetDimensions(element),\n      top, bottom, left, right;\n\n  if (parent) {\n    var parDims = GetDimensions(parent);\n\n    bottom = (eleDims.offset.top + eleDims.height <= parDims.height + parDims.offset.top);\n    top    = (eleDims.offset.top >= parDims.offset.top);\n    left   = (eleDims.offset.left >= parDims.offset.left);\n    right  = (eleDims.offset.left + eleDims.width <= parDims.width + parDims.offset.left);\n  }\n  else {\n    bottom = (eleDims.offset.top + eleDims.height <= eleDims.windowDims.height + eleDims.windowDims.offset.top);\n    top    = (eleDims.offset.top >= eleDims.windowDims.offset.top);\n    left   = (eleDims.offset.left >= eleDims.windowDims.offset.left);\n    right  = (eleDims.offset.left + eleDims.width <= eleDims.windowDims.width);\n  }\n\n  var allDirs = [bottom, top, left, right];\n\n  if (lrOnly) {\n    return left === right === true;\n  }\n\n  if (tbOnly) {\n    return top === bottom === true;\n  }\n\n  return allDirs.indexOf(false) === -1;\n};\n\n/**\n * Uses native methods to return an object of dimension values.\n * @function\n * @param {jQuery || HTML} element - jQuery object or DOM element for which to get the dimensions. Can be any element other that document or window.\n * @returns {Object} - nested object of integer pixel values\n * TODO - if element is window, return only those values.\n */\nfunction GetDimensions(elem, test){\n  elem = elem.length ? elem[0] : elem;\n\n  if (elem === window || elem === document) {\n    throw new Error(\"I'm sorry, Dave. I'm afraid I can't do that.\");\n  }\n\n  var rect = elem.getBoundingClientRect(),\n      parRect = elem.parentNode.getBoundingClientRect(),\n      winRect = document.body.getBoundingClientRect(),\n      winY = window.pageYOffset,\n      winX = window.pageXOffset;\n\n  return {\n    width: rect.width,\n    height: rect.height,\n    offset: {\n      top: rect.top + winY,\n      left: rect.left + winX\n    },\n    parentDims: {\n      width: parRect.width,\n      height: parRect.height,\n      offset: {\n        top: parRect.top + winY,\n        left: parRect.left + winX\n      }\n    },\n    windowDims: {\n      width: winRect.width,\n      height: winRect.height,\n      offset: {\n        top: winY,\n        left: winX\n      }\n    }\n  }\n}\n\n/**\n * Returns an object of top and left integer pixel values for dynamically rendered elements,\n * such as: Tooltip, Reveal, and Dropdown\n * @function\n * @param {jQuery} element - jQuery object for the element being positioned.\n * @param {jQuery} anchor - jQuery object for the element's anchor point.\n * @param {String} position - a string relating to the desired position of the element, relative to it's anchor\n * @param {Number} vOffset - integer pixel value of desired vertical separation between anchor and element.\n * @param {Number} hOffset - integer pixel value of desired horizontal separation between anchor and element.\n * @param {Boolean} isOverflow - if a collision event is detected, sets to true to default the element to full width - any desired offset.\n * TODO alter/rewrite to work with `em` values as well/instead of pixels\n */\nfunction GetOffsets(element, anchor, position, vOffset, hOffset, isOverflow) {\n  var $eleDims = GetDimensions(element),\n      $anchorDims = anchor ? GetDimensions(anchor) : null;\n\n  switch (position) {\n    case 'top':\n      return {\n        left: (Foundation.rtl() ? $anchorDims.offset.left - $eleDims.width + $anchorDims.width : $anchorDims.offset.left),\n        top: $anchorDims.offset.top - ($eleDims.height + vOffset)\n      }\n      break;\n    case 'left':\n      return {\n        left: $anchorDims.offset.left - ($eleDims.width + hOffset),\n        top: $anchorDims.offset.top\n      }\n      break;\n    case 'right':\n      return {\n        left: $anchorDims.offset.left + $anchorDims.width + hOffset,\n        top: $anchorDims.offset.top\n      }\n      break;\n    case 'center top':\n      return {\n        left: ($anchorDims.offset.left + ($anchorDims.width / 2)) - ($eleDims.width / 2),\n        top: $anchorDims.offset.top - ($eleDims.height + vOffset)\n      }\n      break;\n    case 'center bottom':\n      return {\n        left: isOverflow ? hOffset : (($anchorDims.offset.left + ($anchorDims.width / 2)) - ($eleDims.width / 2)),\n        top: $anchorDims.offset.top + $anchorDims.height + vOffset\n      }\n      break;\n    case 'center left':\n      return {\n        left: $anchorDims.offset.left - ($eleDims.width + hOffset),\n        top: ($anchorDims.offset.top + ($anchorDims.height / 2)) - ($eleDims.height / 2)\n      }\n      break;\n    case 'center right':\n      return {\n        left: $anchorDims.offset.left + $anchorDims.width + hOffset + 1,\n        top: ($anchorDims.offset.top + ($anchorDims.height / 2)) - ($eleDims.height / 2)\n      }\n      break;\n    case 'center':\n      return {\n        left: ($eleDims.windowDims.offset.left + ($eleDims.windowDims.width / 2)) - ($eleDims.width / 2),\n        top: ($eleDims.windowDims.offset.top + ($eleDims.windowDims.height / 2)) - ($eleDims.height / 2)\n      }\n      break;\n    case 'reveal':\n      return {\n        left: ($eleDims.windowDims.width - $eleDims.width) / 2,\n        top: $eleDims.windowDims.offset.top + vOffset\n      }\n    case 'reveal full':\n      return {\n        left: $eleDims.windowDims.offset.left,\n        top: $eleDims.windowDims.offset.top\n      }\n      break;\n    case 'left bottom':\n      return {\n        left: $anchorDims.offset.left,\n        top: $anchorDims.offset.top + $anchorDims.height + vOffset\n      };\n      break;\n    case 'right bottom':\n      return {\n        left: $anchorDims.offset.left + $anchorDims.width + hOffset - $eleDims.width,\n        top: $anchorDims.offset.top + $anchorDims.height + vOffset\n      };\n      break;\n    default:\n      return {\n        left: (Foundation.rtl() ? $anchorDims.offset.left - $eleDims.width + $anchorDims.width : $anchorDims.offset.left + hOffset),\n        top: $anchorDims.offset.top + $anchorDims.height + vOffset\n      }\n  }\n}\n\n}(jQuery);\n","'use strict';\n\n!function($) {\n\nconst Nest = {\n  Feather(menu, type = 'zf') {\n    menu.attr('role', 'menubar');\n\n    var items = menu.find('li').attr({'role': 'menuitem'}),\n        subMenuClass = `is-${type}-submenu`,\n        subItemClass = `${subMenuClass}-item`,\n        hasSubClass = `is-${type}-submenu-parent`;\n\n    items.each(function() {\n      var $item = $(this),\n          $sub = $item.children('ul');\n\n      if ($sub.length) {\n        $item\n          .addClass(hasSubClass)\n          .attr({\n            'aria-haspopup': true,\n            'aria-label': $item.children('a:first').text()\n          });\n          // Note:  Drilldowns behave differently in how they hide, and so need\n          // additional attributes.  We should look if this possibly over-generalized\n          // utility (Nest) is appropriate when we rework menus in 6.4\n          if(type === 'drilldown') {\n            $item.attr({'aria-expanded': false});\n          }\n\n        $sub\n          .addClass(`submenu ${subMenuClass}`)\n          .attr({\n            'data-submenu': '',\n            'role': 'menu'\n          });\n        if(type === 'drilldown') {\n          $sub.attr({'aria-hidden': true});\n        }\n      }\n\n      if ($item.parent('[data-submenu]').length) {\n        $item.addClass(`is-submenu-item ${subItemClass}`);\n      }\n    });\n\n    return;\n  },\n\n  Burn(menu, type) {\n    var //items = menu.find('li'),\n        subMenuClass = `is-${type}-submenu`,\n        subItemClass = `${subMenuClass}-item`,\n        hasSubClass = `is-${type}-submenu-parent`;\n\n    menu\n      .find('>li, .menu, .menu > li')\n      .removeClass(`${subMenuClass} ${subItemClass} ${hasSubClass} is-submenu-item submenu is-active`)\n      .removeAttr('data-submenu').css('display', '');\n\n    // console.log(      menu.find('.' + subMenuClass + ', .' + subItemClass + ', .has-submenu, .is-submenu-item, .submenu, [data-submenu]')\n    //           .removeClass(subMenuClass + ' ' + subItemClass + ' has-submenu is-submenu-item submenu')\n    //           .removeAttr('data-submenu'));\n    // items.each(function(){\n    //   var $item = $(this),\n    //       $sub = $item.children('ul');\n    //   if($item.parent('[data-submenu]').length){\n    //     $item.removeClass('is-submenu-item ' + subItemClass);\n    //   }\n    //   if($sub.length){\n    //     $item.removeClass('has-submenu');\n    //     $sub.removeClass('submenu ' + subMenuClass).removeAttr('data-submenu');\n    //   }\n    // });\n  }\n}\n\nFoundation.Nest = Nest;\n\n}(jQuery);\n","'use strict';\n\n!function($) {\n\n// Default set of media queries\nconst defaultQueries = {\n  'default' : 'only screen',\n  landscape : 'only screen and (orientation: landscape)',\n  portrait : 'only screen and (orientation: portrait)',\n  retina : 'only screen and (-webkit-min-device-pixel-ratio: 2),' +\n    'only screen and (min--moz-device-pixel-ratio: 2),' +\n    'only screen and (-o-min-device-pixel-ratio: 2/1),' +\n    'only screen and (min-device-pixel-ratio: 2),' +\n    'only screen and (min-resolution: 192dpi),' +\n    'only screen and (min-resolution: 2dppx)'\n};\n\nvar MediaQuery = {\n  queries: [],\n\n  current: '',\n\n  /**\n   * Initializes the media query helper, by extracting the breakpoint list from the CSS and activating the breakpoint watcher.\n   * @function\n   * @private\n   */\n  _init() {\n    var self = this;\n    var extractedStyles = $('.foundation-mq').css('font-family');\n    var namedQueries;\n\n    namedQueries = parseStyleToObject(extractedStyles);\n\n    for (var key in namedQueries) {\n      if(namedQueries.hasOwnProperty(key)) {\n        self.queries.push({\n          name: key,\n          value: `only screen and (min-width: ${namedQueries[key]})`\n        });\n      }\n    }\n\n    this.current = this._getCurrentSize();\n\n    this._watcher();\n  },\n\n  /**\n   * Checks if the screen is at least as wide as a breakpoint.\n   * @function\n   * @param {String} size - Name of the breakpoint to check.\n   * @returns {Boolean} `true` if the breakpoint matches, `false` if it's smaller.\n   */\n  atLeast(size) {\n    var query = this.get(size);\n\n    if (query) {\n      return window.matchMedia(query).matches;\n    }\n\n    return false;\n  },\n\n  /**\n   * Checks if the screen matches to a breakpoint.\n   * @function\n   * @param {String} size - Name of the breakpoint to check, either 'small only' or 'small'. Omitting 'only' falls back to using atLeast() method.\n   * @returns {Boolean} `true` if the breakpoint matches, `false` if it does not.\n   */\n  is(size) {\n    size = size.trim().split(' ');\n    if(size.length > 1 && size[1] === 'only') {\n      if(size[0] === this._getCurrentSize()) return true;\n    } else {\n      return this.atLeast(size[0]);\n    }\n    return false;\n  },\n\n  /**\n   * Gets the media query of a breakpoint.\n   * @function\n   * @param {String} size - Name of the breakpoint to get.\n   * @returns {String|null} - The media query of the breakpoint, or `null` if the breakpoint doesn't exist.\n   */\n  get(size) {\n    for (var i in this.queries) {\n      if(this.queries.hasOwnProperty(i)) {\n        var query = this.queries[i];\n        if (size === query.name) return query.value;\n      }\n    }\n\n    return null;\n  },\n\n  /**\n   * Gets the current breakpoint name by testing every breakpoint and returning the last one to match (the biggest one).\n   * @function\n   * @private\n   * @returns {String} Name of the current breakpoint.\n   */\n  _getCurrentSize() {\n    var matched;\n\n    for (var i = 0; i < this.queries.length; i++) {\n      var query = this.queries[i];\n\n      if (window.matchMedia(query.value).matches) {\n        matched = query;\n      }\n    }\n\n    if (typeof matched === 'object') {\n      return matched.name;\n    } else {\n      return matched;\n    }\n  },\n\n  /**\n   * Activates the breakpoint watcher, which fires an event on the window whenever the breakpoint changes.\n   * @function\n   * @private\n   */\n  _watcher() {\n    $(window).on('resize.zf.mediaquery', () => {\n      var newSize = this._getCurrentSize(), currentSize = this.current;\n\n      if (newSize !== currentSize) {\n        // Change the current media query\n        this.current = newSize;\n\n        // Broadcast the media query change on the window\n        $(window).trigger('changed.zf.mediaquery', [newSize, currentSize]);\n      }\n    });\n  }\n};\n\nFoundation.MediaQuery = MediaQuery;\n\n// matchMedia() polyfill - Test a CSS media type/query in JS.\n// Authors & copyright (c) 2012: Scott Jehl, Paul Irish, Nicholas Zakas, David Knight. Dual MIT/BSD license\nwindow.matchMedia || (window.matchMedia = function() {\n  'use strict';\n\n  // For browsers that support matchMedium api such as IE 9 and webkit\n  var styleMedia = (window.styleMedia || window.media);\n\n  // For those that don't support matchMedium\n  if (!styleMedia) {\n    var style   = document.createElement('style'),\n    script      = document.getElementsByTagName('script')[0],\n    info        = null;\n\n    style.type  = 'text/css';\n    style.id    = 'matchmediajs-test';\n\n    script && script.parentNode && script.parentNode.insertBefore(style, script);\n\n    // 'style.currentStyle' is used by IE <= 8 and 'window.getComputedStyle' for all other browsers\n    info = ('getComputedStyle' in window) && window.getComputedStyle(style, null) || style.currentStyle;\n\n    styleMedia = {\n      matchMedium(media) {\n        var text = `@media ${media}{ #matchmediajs-test { width: 1px; } }`;\n\n        // 'style.styleSheet' is used by IE <= 8 and 'style.textContent' for all other browsers\n        if (style.styleSheet) {\n          style.styleSheet.cssText = text;\n        } else {\n          style.textContent = text;\n        }\n\n        // Test if media query is true or false\n        return info.width === '1px';\n      }\n    }\n  }\n\n  return function(media) {\n    return {\n      matches: styleMedia.matchMedium(media || 'all'),\n      media: media || 'all'\n    };\n  }\n}());\n\n// Thank you: https://github.com/sindresorhus/query-string\nfunction parseStyleToObject(str) {\n  var styleObject = {};\n\n  if (typeof str !== 'string') {\n    return styleObject;\n  }\n\n  str = str.trim().slice(1, -1); // browsers re-quote string style values\n\n  if (!str) {\n    return styleObject;\n  }\n\n  styleObject = str.split('&').reduce(function(ret, param) {\n    var parts = param.replace(/\\+/g, ' ').split('=');\n    var key = parts[0];\n    var val = parts[1];\n    key = decodeURIComponent(key);\n\n    // missing `=` should be `null`:\n    // http://w3.org/TR/2012/WD-url-20120524/#collect-url-parameters\n    val = val === undefined ? null : decodeURIComponent(val);\n\n    if (!ret.hasOwnProperty(key)) {\n      ret[key] = val;\n    } else if (Array.isArray(ret[key])) {\n      ret[key].push(val);\n    } else {\n      ret[key] = [ret[key], val];\n    }\n    return ret;\n  }, {});\n\n  return styleObject;\n}\n\nFoundation.MediaQuery = MediaQuery;\n\n}(jQuery);\n","'use strict';\n\n!function($) {\n\nconst MutationObserver = (function () {\n  var prefixes = ['WebKit', 'Moz', 'O', 'Ms', ''];\n  for (var i=0; i < prefixes.length; i++) {\n    if (`${prefixes[i]}MutationObserver` in window) {\n      return window[`${prefixes[i]}MutationObserver`];\n    }\n  }\n  return false;\n}());\n\nconst triggers = (el, type) => {\n  el.data(type).split(' ').forEach(id => {\n    $(`#${id}`)[ type === 'close' ? 'trigger' : 'triggerHandler'](`${type}.zf.trigger`, [el]);\n  });\n};\n// Elements with [data-open] will reveal a plugin that supports it when clicked.\n$(document).on('click.zf.trigger', '[data-open]', function() {\n  triggers($(this), 'open');\n});\n\n// Elements with [data-close] will close a plugin that supports it when clicked.\n// If used without a value on [data-close], the event will bubble, allowing it to close a parent component.\n$(document).on('click.zf.trigger', '[data-close]', function() {\n  let id = $(this).data('close');\n  if (id) {\n    triggers($(this), 'close');\n  }\n  else {\n    $(this).trigger('close.zf.trigger');\n  }\n});\n\n// Elements with [data-toggle] will toggle a plugin that supports it when clicked.\n$(document).on('click.zf.trigger', '[data-toggle]', function() {\n  let id = $(this).data('toggle');\n  if (id) {\n    triggers($(this), 'toggle');\n  } else {\n    $(this).trigger('toggle.zf.trigger');\n  }\n});\n\n// Elements with [data-closable] will respond to close.zf.trigger events.\n$(document).on('close.zf.trigger', '[data-closable]', function(e){\n  e.stopPropagation();\n  let animation = $(this).data('closable');\n\n  if(animation !== ''){\n    Foundation.Motion.animateOut($(this), animation, function() {\n      $(this).trigger('closed.zf');\n    });\n  }else{\n    $(this).fadeOut().trigger('closed.zf');\n  }\n});\n\n$(document).on('focus.zf.trigger blur.zf.trigger', '[data-toggle-focus]', function() {\n  let id = $(this).data('toggle-focus');\n  $(`#${id}`).triggerHandler('toggle.zf.trigger', [$(this)]);\n});\n\n/**\n* Fires once after all other scripts have loaded\n* @function\n* @private\n*/\n$(window).on('load', () => {\n  checkListeners();\n});\n\nfunction checkListeners() {\n  eventsListener();\n  resizeListener();\n  scrollListener();\n  closemeListener();\n}\n\n//******** only fires this function once on load, if there's something to watch ********\nfunction closemeListener(pluginName) {\n  var yetiBoxes = $('[data-yeti-box]'),\n      plugNames = ['dropdown', 'tooltip', 'reveal'];\n\n  if(pluginName){\n    if(typeof pluginName === 'string'){\n      plugNames.push(pluginName);\n    }else if(typeof pluginName === 'object' && typeof pluginName[0] === 'string'){\n      plugNames.concat(pluginName);\n    }else{\n      console.error('Plugin names must be strings');\n    }\n  }\n  if(yetiBoxes.length){\n    let listeners = plugNames.map((name) => {\n      return `closeme.zf.${name}`;\n    }).join(' ');\n\n    $(window).off(listeners).on(listeners, function(e, pluginId){\n      let plugin = e.namespace.split('.')[0];\n      let plugins = $(`[data-${plugin}]`).not(`[data-yeti-box=\"${pluginId}\"]`);\n\n      plugins.each(function(){\n        let _this = $(this);\n\n        _this.triggerHandler('close.zf.trigger', [_this]);\n      });\n    });\n  }\n}\n\nfunction resizeListener(debounce){\n  let timer,\n      $nodes = $('[data-resize]');\n  if($nodes.length){\n    $(window).off('resize.zf.trigger')\n    .on('resize.zf.trigger', function(e) {\n      if (timer) { clearTimeout(timer); }\n\n      timer = setTimeout(function(){\n\n        if(!MutationObserver){//fallback for IE 9\n          $nodes.each(function(){\n            $(this).triggerHandler('resizeme.zf.trigger');\n          });\n        }\n        //trigger all listening elements and signal a resize event\n        $nodes.attr('data-events', \"resize\");\n      }, debounce || 10);//default time to emit resize event\n    });\n  }\n}\n\nfunction scrollListener(debounce){\n  let timer,\n      $nodes = $('[data-scroll]');\n  if($nodes.length){\n    $(window).off('scroll.zf.trigger')\n    .on('scroll.zf.trigger', function(e){\n      if(timer){ clearTimeout(timer); }\n\n      timer = setTimeout(function(){\n\n        if(!MutationObserver){//fallback for IE 9\n          $nodes.each(function(){\n            $(this).triggerHandler('scrollme.zf.trigger');\n          });\n        }\n        //trigger all listening elements and signal a scroll event\n        $nodes.attr('data-events', \"scroll\");\n      }, debounce || 10);//default time to emit scroll event\n    });\n  }\n}\n\nfunction eventsListener() {\n  if(!MutationObserver){ return false; }\n  let nodes = document.querySelectorAll('[data-resize], [data-scroll], [data-mutate]');\n\n  //element callback\n  var listeningElementsMutation = function (mutationRecordsList) {\n      var $target = $(mutationRecordsList[0].target);\n\n\t  //trigger the event handler for the element depending on type\n      switch (mutationRecordsList[0].type) {\n\n        case \"attributes\":\n          if ($target.attr(\"data-events\") === \"scroll\" && mutationRecordsList[0].attributeName === \"data-events\") {\n\t\t  \t$target.triggerHandler('scrollme.zf.trigger', [$target, window.pageYOffset]);\n\t\t  }\n\t\t  if ($target.attr(\"data-events\") === \"resize\" && mutationRecordsList[0].attributeName === \"data-events\") {\n\t\t  \t$target.triggerHandler('resizeme.zf.trigger', [$target]);\n\t\t   }\n\t\t  if (mutationRecordsList[0].attributeName === \"style\") {\n\t\t\t  $target.closest(\"[data-mutate]\").attr(\"data-events\",\"mutate\");\n\t\t\t  $target.closest(\"[data-mutate]\").triggerHandler('mutateme.zf.trigger', [$target.closest(\"[data-mutate]\")]);\n\t\t  }\n\t\t  break;\n\n        case \"childList\":\n\t\t  $target.closest(\"[data-mutate]\").attr(\"data-events\",\"mutate\");\n\t\t  $target.closest(\"[data-mutate]\").triggerHandler('mutateme.zf.trigger', [$target.closest(\"[data-mutate]\")]);\n          break;\n\n        default:\n          return false;\n        //nothing\n      }\n    };\n\n    if (nodes.length) {\n      //for each element that needs to listen for resizing, scrolling, or mutation add a single observer\n      for (var i = 0; i <= nodes.length - 1; i++) {\n        var elementObserver = new MutationObserver(listeningElementsMutation);\n        elementObserver.observe(nodes[i], { attributes: true, childList: true, characterData: false, subtree: true, attributeFilter: [\"data-events\", \"style\"] });\n      }\n    }\n  }\n\n// ------------------------------------\n\n// [PH]\n// Foundation.CheckWatchers = checkWatchers;\nFoundation.IHearYou = checkListeners;\n// Foundation.ISeeYou = scrollListener;\n// Foundation.IFeelYou = closemeListener;\n\n}(jQuery);\n","'use strict';\n\n!function($) {\n\n/**\n * Motion module.\n * @module foundation.motion\n */\n\nconst initClasses   = ['mui-enter', 'mui-leave'];\nconst activeClasses = ['mui-enter-active', 'mui-leave-active'];\n\nconst Motion = {\n  animateIn: function(element, animation, cb) {\n    animate(true, element, animation, cb);\n  },\n\n  animateOut: function(element, animation, cb) {\n    animate(false, element, animation, cb);\n  }\n}\n\nfunction Move(duration, elem, fn){\n  var anim, prog, start = null;\n  // console.log('called');\n\n  if (duration === 0) {\n    fn.apply(elem);\n    elem.trigger('finished.zf.animate', [elem]).triggerHandler('finished.zf.animate', [elem]);\n    return;\n  }\n\n  function move(ts){\n    if(!start) start = ts;\n    // console.log(start, ts);\n    prog = ts - start;\n    fn.apply(elem);\n\n    if(prog < duration){ anim = window.requestAnimationFrame(move, elem); }\n    else{\n      window.cancelAnimationFrame(anim);\n      elem.trigger('finished.zf.animate', [elem]).triggerHandler('finished.zf.animate', [elem]);\n    }\n  }\n  anim = window.requestAnimationFrame(move);\n}\n\n/**\n * Animates an element in or out using a CSS transition class.\n * @function\n * @private\n * @param {Boolean} isIn - Defines if the animation is in or out.\n * @param {Object} element - jQuery or HTML object to animate.\n * @param {String} animation - CSS class to use.\n * @param {Function} cb - Callback to run when animation is finished.\n */\nfunction animate(isIn, element, animation, cb) {\n  element = $(element).eq(0);\n\n  if (!element.length) return;\n\n  var initClass = isIn ? initClasses[0] : initClasses[1];\n  var activeClass = isIn ? activeClasses[0] : activeClasses[1];\n\n  // Set up the animation\n  reset();\n\n  element\n    .addClass(animation)\n    .css('transition', 'none');\n\n  requestAnimationFrame(() => {\n    element.addClass(initClass);\n    if (isIn) element.show();\n  });\n\n  // Start the animation\n  requestAnimationFrame(() => {\n    element[0].offsetWidth;\n    element\n      .css('transition', '')\n      .addClass(activeClass);\n  });\n\n  // Clean up the animation when it finishes\n  element.one(Foundation.transitionend(element), finish);\n\n  // Hides the element (for out animations), resets the element, and runs a callback\n  function finish() {\n    if (!isIn) element.hide();\n    reset();\n    if (cb) cb.apply(element);\n  }\n\n  // Resets transitions and removes motion-specific classes\n  function reset() {\n    element[0].style.transitionDuration = 0;\n    element.removeClass(`${initClass} ${activeClass} ${animation}`);\n  }\n}\n\nFoundation.Move = Move;\nFoundation.Motion = Motion;\n\n}(jQuery);\n","'use strict';\n\n!function($) {\n\n/**\n * DropdownMenu module.\n * @module foundation.dropdown-menu\n * @requires foundation.util.keyboard\n * @requires foundation.util.box\n * @requires foundation.util.nest\n */\n\nclass DropdownMenu {\n  /**\n   * Creates a new instance of DropdownMenu.\n   * @class\n   * @fires DropdownMenu#init\n   * @param {jQuery} element - jQuery object to make into a dropdown menu.\n   * @param {Object} options - Overrides to the default plugin settings.\n   */\n  constructor(element, options) {\n    this.$element = element;\n    this.options = $.extend({}, DropdownMenu.defaults, this.$element.data(), options);\n\n    Foundation.Nest.Feather(this.$element, 'dropdown');\n    this._init();\n\n    Foundation.registerPlugin(this, 'DropdownMenu');\n    Foundation.Keyboard.register('DropdownMenu', {\n      'ENTER': 'open',\n      'SPACE': 'open',\n      'ARROW_RIGHT': 'next',\n      'ARROW_UP': 'up',\n      'ARROW_DOWN': 'down',\n      'ARROW_LEFT': 'previous',\n      'ESCAPE': 'close'\n    });\n  }\n\n  /**\n   * Initializes the plugin, and calls _prepareMenu\n   * @private\n   * @function\n   */\n  _init() {\n    var subs = this.$element.find('li.is-dropdown-submenu-parent');\n    this.$element.children('.is-dropdown-submenu-parent').children('.is-dropdown-submenu').addClass('first-sub');\n\n    this.$menuItems = this.$element.find('[role=\"menuitem\"]');\n    this.$tabs = this.$element.children('[role=\"menuitem\"]');\n    this.$tabs.find('ul.is-dropdown-submenu').addClass(this.options.verticalClass);\n\n    if (this.$element.hasClass(this.options.rightClass) || this.options.alignment === 'right' || Foundation.rtl() || this.$element.parents('.top-bar-right').is('*')) {\n      this.options.alignment = 'right';\n      subs.addClass('opens-left');\n    } else {\n      subs.addClass('opens-right');\n    }\n    this.changed = false;\n    this._events();\n  };\n\n  _isVertical() {\n    return this.$tabs.css('display') === 'block';\n  }\n\n  /**\n   * Adds event listeners to elements within the menu\n   * @private\n   * @function\n   */\n  _events() {\n    var _this = this,\n        hasTouch = 'ontouchstart' in window || (typeof window.ontouchstart !== 'undefined'),\n        parClass = 'is-dropdown-submenu-parent';\n\n    // used for onClick and in the keyboard handlers\n    var handleClickFn = function(e) {\n      var $elem = $(e.target).parentsUntil('ul', `.${parClass}`),\n          hasSub = $elem.hasClass(parClass),\n          hasClicked = $elem.attr('data-is-click') === 'true',\n          $sub = $elem.children('.is-dropdown-submenu');\n\n      if (hasSub) {\n        if (hasClicked) {\n          if (!_this.options.closeOnClick || (!_this.options.clickOpen && !hasTouch) || (_this.options.forceFollow && hasTouch)) { return; }\n          else {\n            e.stopImmediatePropagation();\n            e.preventDefault();\n            _this._hide($elem);\n          }\n        } else {\n          e.preventDefault();\n          e.stopImmediatePropagation();\n          _this._show($sub);\n          $elem.add($elem.parentsUntil(_this.$element, `.${parClass}`)).attr('data-is-click', true);\n        }\n      }\n    };\n\n    if (this.options.clickOpen || hasTouch) {\n      this.$menuItems.on('click.zf.dropdownmenu touchstart.zf.dropdownmenu', handleClickFn);\n    }\n\n    // Handle Leaf element Clicks\n    if(_this.options.closeOnClickInside){\n      this.$menuItems.on('click.zf.dropdownmenu', function(e) {\n        var $elem = $(this),\n            hasSub = $elem.hasClass(parClass);\n        if(!hasSub){\n          _this._hide();\n        }\n      });\n    }\n\n    if (!this.options.disableHover) {\n      this.$menuItems.on('mouseenter.zf.dropdownmenu', function(e) {\n        var $elem = $(this),\n            hasSub = $elem.hasClass(parClass);\n\n        if (hasSub) {\n          clearTimeout($elem.data('_delay'));\n          $elem.data('_delay', setTimeout(function() {\n            _this._show($elem.children('.is-dropdown-submenu'));\n          }, _this.options.hoverDelay));\n        }\n      }).on('mouseleave.zf.dropdownmenu', function(e) {\n        var $elem = $(this),\n            hasSub = $elem.hasClass(parClass);\n        if (hasSub && _this.options.autoclose) {\n          if ($elem.attr('data-is-click') === 'true' && _this.options.clickOpen) { return false; }\n\n          clearTimeout($elem.data('_delay'));\n          $elem.data('_delay', setTimeout(function() {\n            _this._hide($elem);\n          }, _this.options.closingTime));\n        }\n      });\n    }\n    this.$menuItems.on('keydown.zf.dropdownmenu', function(e) {\n      var $element = $(e.target).parentsUntil('ul', '[role=\"menuitem\"]'),\n          isTab = _this.$tabs.index($element) > -1,\n          $elements = isTab ? _this.$tabs : $element.siblings('li').add($element),\n          $prevElement,\n          $nextElement;\n\n      $elements.each(function(i) {\n        if ($(this).is($element)) {\n          $prevElement = $elements.eq(i-1);\n          $nextElement = $elements.eq(i+1);\n          return;\n        }\n      });\n\n      var nextSibling = function() {\n        if (!$element.is(':last-child')) {\n          $nextElement.children('a:first').focus();\n          e.preventDefault();\n        }\n      }, prevSibling = function() {\n        $prevElement.children('a:first').focus();\n        e.preventDefault();\n      }, openSub = function() {\n        var $sub = $element.children('ul.is-dropdown-submenu');\n        if ($sub.length) {\n          _this._show($sub);\n          $element.find('li > a:first').focus();\n          e.preventDefault();\n        } else { return; }\n      }, closeSub = function() {\n        //if ($element.is(':first-child')) {\n        var close = $element.parent('ul').parent('li');\n        close.children('a:first').focus();\n        _this._hide(close);\n        e.preventDefault();\n        //}\n      };\n      var functions = {\n        open: openSub,\n        close: function() {\n          _this._hide(_this.$element);\n          _this.$menuItems.find('a:first').focus(); // focus to first element\n          e.preventDefault();\n        },\n        handled: function() {\n          e.stopImmediatePropagation();\n        }\n      };\n\n      if (isTab) {\n        if (_this._isVertical()) { // vertical menu\n          if (Foundation.rtl()) { // right aligned\n            $.extend(functions, {\n              down: nextSibling,\n              up: prevSibling,\n              next: closeSub,\n              previous: openSub\n            });\n          } else { // left aligned\n            $.extend(functions, {\n              down: nextSibling,\n              up: prevSibling,\n              next: openSub,\n              previous: closeSub\n            });\n          }\n        } else { // horizontal menu\n          if (Foundation.rtl()) { // right aligned\n            $.extend(functions, {\n              next: prevSibling,\n              previous: nextSibling,\n              down: openSub,\n              up: closeSub\n            });\n          } else { // left aligned\n            $.extend(functions, {\n              next: nextSibling,\n              previous: prevSibling,\n              down: openSub,\n              up: closeSub\n            });\n          }\n        }\n      } else { // not tabs -> one sub\n        if (Foundation.rtl()) { // right aligned\n          $.extend(functions, {\n            next: closeSub,\n            previous: openSub,\n            down: nextSibling,\n            up: prevSibling\n          });\n        } else { // left aligned\n          $.extend(functions, {\n            next: openSub,\n            previous: closeSub,\n            down: nextSibling,\n            up: prevSibling\n          });\n        }\n      }\n      Foundation.Keyboard.handleKey(e, 'DropdownMenu', functions);\n\n    });\n  }\n\n  /**\n   * Adds an event handler to the body to close any dropdowns on a click.\n   * @function\n   * @private\n   */\n  _addBodyHandler() {\n    var $body = $(document.body),\n        _this = this;\n    $body.off('mouseup.zf.dropdownmenu touchend.zf.dropdownmenu')\n         .on('mouseup.zf.dropdownmenu touchend.zf.dropdownmenu', function(e) {\n           var $link = _this.$element.find(e.target);\n           if ($link.length) { return; }\n\n           _this._hide();\n           $body.off('mouseup.zf.dropdownmenu touchend.zf.dropdownmenu');\n         });\n  }\n\n  /**\n   * Opens a dropdown pane, and checks for collisions first.\n   * @param {jQuery} $sub - ul element that is a submenu to show\n   * @function\n   * @private\n   * @fires DropdownMenu#show\n   */\n  _show($sub) {\n    var idx = this.$tabs.index(this.$tabs.filter(function(i, el) {\n      return $(el).find($sub).length > 0;\n    }));\n    var $sibs = $sub.parent('li.is-dropdown-submenu-parent').siblings('li.is-dropdown-submenu-parent');\n    this._hide($sibs, idx);\n    $sub.css('visibility', 'hidden').addClass('js-dropdown-active')\n        .parent('li.is-dropdown-submenu-parent').addClass('is-active');\n    var clear = Foundation.Box.ImNotTouchingYou($sub, null, true);\n    if (!clear) {\n      var oldClass = this.options.alignment === 'left' ? '-right' : '-left',\n          $parentLi = $sub.parent('.is-dropdown-submenu-parent');\n      $parentLi.removeClass(`opens${oldClass}`).addClass(`opens-${this.options.alignment}`);\n      clear = Foundation.Box.ImNotTouchingYou($sub, null, true);\n      if (!clear) {\n        $parentLi.removeClass(`opens-${this.options.alignment}`).addClass('opens-inner');\n      }\n      this.changed = true;\n    }\n    $sub.css('visibility', '');\n    if (this.options.closeOnClick) { this._addBodyHandler(); }\n    /**\n     * Fires when the new dropdown pane is visible.\n     * @event DropdownMenu#show\n     */\n    this.$element.trigger('show.zf.dropdownmenu', [$sub]);\n  }\n\n  /**\n   * Hides a single, currently open dropdown pane, if passed a parameter, otherwise, hides everything.\n   * @function\n   * @param {jQuery} $elem - element with a submenu to hide\n   * @param {Number} idx - index of the $tabs collection to hide\n   * @private\n   */\n  _hide($elem, idx) {\n    var $toClose;\n    if ($elem && $elem.length) {\n      $toClose = $elem;\n    } else if (idx !== undefined) {\n      $toClose = this.$tabs.not(function(i, el) {\n        return i === idx;\n      });\n    }\n    else {\n      $toClose = this.$element;\n    }\n    var somethingToClose = $toClose.hasClass('is-active') || $toClose.find('.is-active').length > 0;\n\n    if (somethingToClose) {\n      $toClose.find('li.is-active').add($toClose).attr({\n        'data-is-click': false\n      }).removeClass('is-active');\n\n      $toClose.find('ul.js-dropdown-active').removeClass('js-dropdown-active');\n\n      if (this.changed || $toClose.find('opens-inner').length) {\n        var oldClass = this.options.alignment === 'left' ? 'right' : 'left';\n        $toClose.find('li.is-dropdown-submenu-parent').add($toClose)\n                .removeClass(`opens-inner opens-${this.options.alignment}`)\n                .addClass(`opens-${oldClass}`);\n        this.changed = false;\n      }\n      /**\n       * Fires when the open menus are closed.\n       * @event DropdownMenu#hide\n       */\n      this.$element.trigger('hide.zf.dropdownmenu', [$toClose]);\n    }\n  }\n\n  /**\n   * Destroys the plugin.\n   * @function\n   */\n  destroy() {\n    this.$menuItems.off('.zf.dropdownmenu').removeAttr('data-is-click')\n        .removeClass('is-right-arrow is-left-arrow is-down-arrow opens-right opens-left opens-inner');\n    $(document.body).off('.zf.dropdownmenu');\n    Foundation.Nest.Burn(this.$element, 'dropdown');\n    Foundation.unregisterPlugin(this);\n  }\n}\n\n/**\n * Default settings for plugin\n */\nDropdownMenu.defaults = {\n  /**\n   * Disallows hover events from opening submenus\n   * @option\n   * @type {boolean}\n   * @default false\n   */\n  disableHover: false,\n  /**\n   * Allow a submenu to automatically close on a mouseleave event, if not clicked open.\n   * @option\n   * @type {boolean}\n   * @default true\n   */\n  autoclose: true,\n  /**\n   * Amount of time to delay opening a submenu on hover event.\n   * @option\n   * @type {number}\n   * @default 50\n   */\n  hoverDelay: 50,\n  /**\n   * Allow a submenu to open/remain open on parent click event. Allows cursor to move away from menu.\n   * @option\n   * @type {boolean}\n   * @default false\n   */\n  clickOpen: false,\n  /**\n   * Amount of time to delay closing a submenu on a mouseleave event.\n   * @option\n   * @type {number}\n   * @default 500\n   */\n\n  closingTime: 500,\n  /**\n   * Position of the menu relative to what direction the submenus should open. Handled by JS. Can be `'left'` or `'right'`.\n   * @option\n   * @type {string}\n   * @default 'left'\n   */\n  alignment: 'left',\n  /**\n   * Allow clicks on the body to close any open submenus.\n   * @option\n   * @type {boolean}\n   * @default true\n   */\n  closeOnClick: true,\n  /**\n   * Allow clicks on leaf anchor links to close any open submenus.\n   * @option\n   * @type {boolean}\n   * @default true\n   */\n  closeOnClickInside: true,\n  /**\n   * Class applied to vertical oriented menus, Foundation default is `vertical`. Update this if using your own class.\n   * @option\n   * @type {string}\n   * @default 'vertical'\n   */\n  verticalClass: 'vertical',\n  /**\n   * Class applied to right-side oriented menus, Foundation default is `align-right`. Update this if using your own class.\n   * @option\n   * @type {string}\n   * @default 'align-right'\n   */\n  rightClass: 'align-right',\n  /**\n   * Boolean to force overide the clicking of links to perform default action, on second touch event for mobile.\n   * @option\n   * @type {boolean}\n   * @default true\n   */\n  forceFollow: true\n};\n\n// Window exports\nFoundation.plugin(DropdownMenu, 'DropdownMenu');\n\n}(jQuery);\n","'use strict';\n\n!function($) {\n\n/**\n * OffCanvas module.\n * @module foundation.offcanvas\n * @requires foundation.util.keyboard\n * @requires foundation.util.mediaQuery\n * @requires foundation.util.triggers\n * @requires foundation.util.motion\n */\n\nclass OffCanvas {\n  /**\n   * Creates a new instance of an off-canvas wrapper.\n   * @class\n   * @fires OffCanvas#init\n   * @param {Object} element - jQuery object to initialize.\n   * @param {Object} options - Overrides to the default plugin settings.\n   */\n  constructor(element, options) {\n    this.$element = element;\n    this.options = $.extend({}, OffCanvas.defaults, this.$element.data(), options);\n    this.$lastTrigger = $();\n    this.$triggers = $();\n\n    this._init();\n    this._events();\n\n    Foundation.registerPlugin(this, 'OffCanvas')\n    Foundation.Keyboard.register('OffCanvas', {\n      'ESCAPE': 'close'\n    });\n\n  }\n\n  /**\n   * Initializes the off-canvas wrapper by adding the exit overlay (if needed).\n   * @function\n   * @private\n   */\n  _init() {\n    var id = this.$element.attr('id');\n\n    this.$element.attr('aria-hidden', 'true');\n\n    this.$element.addClass(`is-transition-${this.options.transition}`);\n\n    // Find triggers that affect this element and add aria-expanded to them\n    this.$triggers = $(document)\n      .find('[data-open=\"'+id+'\"], [data-close=\"'+id+'\"], [data-toggle=\"'+id+'\"]')\n      .attr('aria-expanded', 'false')\n      .attr('aria-controls', id);\n\n    // Add an overlay over the content if necessary\n    if (this.options.contentOverlay === true) {\n      var overlay = document.createElement('div');\n      var overlayPosition = $(this.$element).css(\"position\") === 'fixed' ? 'is-overlay-fixed' : 'is-overlay-absolute';\n      overlay.setAttribute('class', 'js-off-canvas-overlay ' + overlayPosition);\n      this.$overlay = $(overlay);\n      if(overlayPosition === 'is-overlay-fixed') {\n        $('body').append(this.$overlay);\n      } else {\n        this.$element.siblings('[data-off-canvas-content]').append(this.$overlay);\n      }\n    }\n\n    this.options.isRevealed = this.options.isRevealed || new RegExp(this.options.revealClass, 'g').test(this.$element[0].className);\n\n    if (this.options.isRevealed === true) {\n      this.options.revealOn = this.options.revealOn || this.$element[0].className.match(/(reveal-for-medium|reveal-for-large)/g)[0].split('-')[2];\n      this._setMQChecker();\n    }\n    if (!this.options.transitionTime === true) {\n      this.options.transitionTime = parseFloat(window.getComputedStyle($('[data-off-canvas]')[0]).transitionDuration) * 1000;\n    }\n  }\n\n  /**\n   * Adds event handlers to the off-canvas wrapper and the exit overlay.\n   * @function\n   * @private\n   */\n  _events() {\n    this.$element.off('.zf.trigger .zf.offcanvas').on({\n      'open.zf.trigger': this.open.bind(this),\n      'close.zf.trigger': this.close.bind(this),\n      'toggle.zf.trigger': this.toggle.bind(this),\n      'keydown.zf.offcanvas': this._handleKeyboard.bind(this)\n    });\n\n    if (this.options.closeOnClick === true) {\n      var $target = this.options.contentOverlay ? this.$overlay : $('[data-off-canvas-content]');\n      $target.on({'click.zf.offcanvas': this.close.bind(this)});\n    }\n  }\n\n  /**\n   * Applies event listener for elements that will reveal at certain breakpoints.\n   * @private\n   */\n  _setMQChecker() {\n    var _this = this;\n\n    $(window).on('changed.zf.mediaquery', function() {\n      if (Foundation.MediaQuery.atLeast(_this.options.revealOn)) {\n        _this.reveal(true);\n      } else {\n        _this.reveal(false);\n      }\n    }).one('load.zf.offcanvas', function() {\n      if (Foundation.MediaQuery.atLeast(_this.options.revealOn)) {\n        _this.reveal(true);\n      }\n    });\n  }\n\n  /**\n   * Handles the revealing/hiding the off-canvas at breakpoints, not the same as open.\n   * @param {Boolean} isRevealed - true if element should be revealed.\n   * @function\n   */\n  reveal(isRevealed) {\n    var $closer = this.$element.find('[data-close]');\n    if (isRevealed) {\n      this.close();\n      this.isRevealed = true;\n      this.$element.attr('aria-hidden', 'false');\n      this.$element.off('open.zf.trigger toggle.zf.trigger');\n      if ($closer.length) { $closer.hide(); }\n    } else {\n      this.isRevealed = false;\n      this.$element.attr('aria-hidden', 'true');\n      this.$element.off('open.zf.trigger toggle.zf.trigger').on({\n        'open.zf.trigger': this.open.bind(this),\n        'toggle.zf.trigger': this.toggle.bind(this)\n      });\n      if ($closer.length) {\n        $closer.show();\n      }\n    }\n  }\n\n  /**\n   * Stops scrolling of the body when offcanvas is open on mobile Safari and other troublesome browsers.\n   * @private\n   */\n  _stopScrolling(event) {\n    return false;\n  }\n\n  // Taken and adapted from http://stackoverflow.com/questions/16889447/prevent-full-page-scrolling-ios\n  // Only really works for y, not sure how to extend to x or if we need to.\n  _recordScrollable(event) {\n    let elem = this; // called from event handler context with this as elem\n\n     // If the element is scrollable (content overflows), then...\n    if (elem.scrollHeight !== elem.clientHeight) {\n      // If we're at the top, scroll down one pixel to allow scrolling up\n      if (elem.scrollTop === 0) {\n        elem.scrollTop = 1;\n      }\n      // If we're at the bottom, scroll up one pixel to allow scrolling down\n      if (elem.scrollTop === elem.scrollHeight - elem.clientHeight) {\n        elem.scrollTop = elem.scrollHeight - elem.clientHeight - 1;\n      }\n    }\n    elem.allowUp = elem.scrollTop > 0;\n    elem.allowDown = elem.scrollTop < (elem.scrollHeight - elem.clientHeight);\n    elem.lastY = event.originalEvent.pageY;\n  }\n\n  _stopScrollPropagation(event) {\n    let elem = this; // called from event handler context with this as elem\n    let up = event.pageY < elem.lastY;\n    let down = !up;\n    elem.lastY = event.pageY;\n\n    if((up && elem.allowUp) || (down && elem.allowDown)) {\n      event.stopPropagation();\n    } else {\n      event.preventDefault();\n    }\n  }\n\n  /**\n   * Opens the off-canvas menu.\n   * @function\n   * @param {Object} event - Event object passed from listener.\n   * @param {jQuery} trigger - element that triggered the off-canvas to open.\n   * @fires OffCanvas#opened\n   */\n  open(event, trigger) {\n    if (this.$element.hasClass('is-open') || this.isRevealed) { return; }\n    var _this = this;\n\n    if (trigger) {\n      this.$lastTrigger = trigger;\n    }\n\n    if (this.options.forceTo === 'top') {\n      window.scrollTo(0, 0);\n    } else if (this.options.forceTo === 'bottom') {\n      window.scrollTo(0,document.body.scrollHeight);\n    }\n\n    /**\n     * Fires when the off-canvas menu opens.\n     * @event OffCanvas#opened\n     */\n    _this.$element.addClass('is-open')\n\n    this.$triggers.attr('aria-expanded', 'true');\n    this.$element.attr('aria-hidden', 'false')\n        .trigger('opened.zf.offcanvas');\n\n    // If `contentScroll` is set to false, add class and disable scrolling on touch devices.\n    if (this.options.contentScroll === false) {\n      $('body').addClass('is-off-canvas-open').on('touchmove', this._stopScrolling);\n      this.$element.on('touchstart', this._recordScrollable);\n      this.$element.on('touchmove', this._stopScrollPropagation);\n    }\n\n    if (this.options.contentOverlay === true) {\n      this.$overlay.addClass('is-visible');\n    }\n\n    if (this.options.closeOnClick === true && this.options.contentOverlay === true) {\n      this.$overlay.addClass('is-closable');\n    }\n\n    if (this.options.autoFocus === true) {\n      this.$element.one(Foundation.transitionend(this.$element), function() {\n        var canvasFocus = _this.$element.find('[data-autofocus]');\n        if (canvasFocus.length) {\n            canvasFocus.eq(0).focus();\n        } else {\n            _this.$element.find('a, button').eq(0).focus();\n        }\n      });\n    }\n\n    if (this.options.trapFocus === true) {\n      this.$element.siblings('[data-off-canvas-content]').attr('tabindex', '-1');\n      Foundation.Keyboard.trapFocus(this.$element);\n    }\n  }\n\n  /**\n   * Closes the off-canvas menu.\n   * @function\n   * @param {Function} cb - optional cb to fire after closure.\n   * @fires OffCanvas#closed\n   */\n  close(cb) {\n    if (!this.$element.hasClass('is-open') || this.isRevealed) { return; }\n\n    var _this = this;\n\n    _this.$element.removeClass('is-open');\n\n    this.$element.attr('aria-hidden', 'true')\n      /**\n       * Fires when the off-canvas menu opens.\n       * @event OffCanvas#closed\n       */\n        .trigger('closed.zf.offcanvas');\n\n    // If `contentScroll` is set to false, remove class and re-enable scrolling on touch devices.\n    if (this.options.contentScroll === false) {\n      $('body').removeClass('is-off-canvas-open').off('touchmove', this._stopScrolling);\n      this.$element.off('touchstart', this._recordScrollable);\n      this.$element.off('touchmove', this._stopScrollPropagation);\n    }\n\n    if (this.options.contentOverlay === true) {\n      this.$overlay.removeClass('is-visible');\n    }\n\n    if (this.options.closeOnClick === true && this.options.contentOverlay === true) {\n      this.$overlay.removeClass('is-closable');\n    }\n\n    this.$triggers.attr('aria-expanded', 'false');\n\n    if (this.options.trapFocus === true) {\n      this.$element.siblings('[data-off-canvas-content]').removeAttr('tabindex');\n      Foundation.Keyboard.releaseFocus(this.$element);\n    }\n  }\n\n  /**\n   * Toggles the off-canvas menu open or closed.\n   * @function\n   * @param {Object} event - Event object passed from listener.\n   * @param {jQuery} trigger - element that triggered the off-canvas to open.\n   */\n  toggle(event, trigger) {\n    if (this.$element.hasClass('is-open')) {\n      this.close(event, trigger);\n    }\n    else {\n      this.open(event, trigger);\n    }\n  }\n\n  /**\n   * Handles keyboard input when detected. When the escape key is pressed, the off-canvas menu closes, and focus is restored to the element that opened the menu.\n   * @function\n   * @private\n   */\n  _handleKeyboard(e) {\n    Foundation.Keyboard.handleKey(e, 'OffCanvas', {\n      close: () => {\n        this.close();\n        this.$lastTrigger.focus();\n        return true;\n      },\n      handled: () => {\n        e.stopPropagation();\n        e.preventDefault();\n      }\n    });\n  }\n\n  /**\n   * Destroys the offcanvas plugin.\n   * @function\n   */\n  destroy() {\n    this.close();\n    this.$element.off('.zf.trigger .zf.offcanvas');\n    this.$overlay.off('.zf.offcanvas');\n\n    Foundation.unregisterPlugin(this);\n  }\n}\n\nOffCanvas.defaults = {\n  /**\n   * Allow the user to click outside of the menu to close it.\n   * @option\n   * @type {boolean}\n   * @default true\n   */\n  closeOnClick: true,\n\n  /**\n   * Adds an overlay on top of `[data-off-canvas-content]`.\n   * @option\n   * @type {boolean}\n   * @default true\n   */\n  contentOverlay: true,\n\n  /**\n   * Enable/disable scrolling of the main content when an off canvas panel is open.\n   * @option\n   * @type {boolean}\n   * @default true\n   */\n  contentScroll: true,\n\n  /**\n   * Amount of time in ms the open and close transition requires. If none selected, pulls from body style.\n   * @option\n   * @type {number}\n   * @default 0\n   */\n  transitionTime: 0,\n\n  /**\n   * Type of transition for the offcanvas menu. Options are 'push', 'detached' or 'slide'.\n   * @option\n   * @type {string}\n   * @default push\n   */\n  transition: 'push',\n\n  /**\n   * Force the page to scroll to top or bottom on open.\n   * @option\n   * @type {?string}\n   * @default null\n   */\n  forceTo: null,\n\n  /**\n   * Allow the offcanvas to remain open for certain breakpoints.\n   * @option\n   * @type {boolean}\n   * @default false\n   */\n  isRevealed: false,\n\n  /**\n   * Breakpoint at which to reveal. JS will use a RegExp to target standard classes, if changing classnames, pass your class with the `revealClass` option.\n   * @option\n   * @type {?string}\n   * @default null\n   */\n  revealOn: null,\n\n  /**\n   * Force focus to the offcanvas on open. If true, will focus the opening trigger on close.\n   * @option\n   * @type {boolean}\n   * @default true\n   */\n  autoFocus: true,\n\n  /**\n   * Class used to force an offcanvas to remain open. Foundation defaults for this are `reveal-for-large` & `reveal-for-medium`.\n   * @option\n   * @type {string}\n   * @default reveal-for-\n   * @todo improve the regex testing for this.\n   */\n  revealClass: 'reveal-for-',\n\n  /**\n   * Triggers optional focus trapping when opening an offcanvas. Sets tabindex of [data-off-canvas-content] to -1 for accessibility purposes.\n   * @option\n   * @type {boolean}\n   * @default false\n   */\n  trapFocus: false\n}\n\n// Window exports\nFoundation.plugin(OffCanvas, 'OffCanvas');\n\n}(jQuery);\n","/*!\n * Chart.js\n * http://chartjs.org/\n * Version: 2.5.0\n *\n * Copyright 2017 Nick Downie\n * Released under the MIT license\n * https://github.com/chartjs/Chart.js/blob/master/LICENSE.md\n */\n(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.Chart = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n\n},{}],2:[function(require,module,exports){\n/* MIT license */\r\nvar colorNames = require(6);\r\n\r\nmodule.exports = {\r\n   getRgba: getRgba,\r\n   getHsla: getHsla,\r\n   getRgb: getRgb,\r\n   getHsl: getHsl,\r\n   getHwb: getHwb,\r\n   getAlpha: getAlpha,\r\n\r\n   hexString: hexString,\r\n   rgbString: rgbString,\r\n   rgbaString: rgbaString,\r\n   percentString: percentString,\r\n   percentaString: percentaString,\r\n   hslString: hslString,\r\n   hslaString: hslaString,\r\n   hwbString: hwbString,\r\n   keyword: keyword\r\n}\r\n\r\nfunction getRgba(string) {\r\n   if (!string) {\r\n      return;\r\n   }\r\n   var abbr =  /^#([a-fA-F0-9]{3})$/,\r\n       hex =  /^#([a-fA-F0-9]{6})$/,\r\n       rgba = /^rgba?\\(\\s*([+-]?\\d+)\\s*,\\s*([+-]?\\d+)\\s*,\\s*([+-]?\\d+)\\s*(?:,\\s*([+-]?[\\d\\.]+)\\s*)?\\)$/,\r\n       per = /^rgba?\\(\\s*([+-]?[\\d\\.]+)\\%\\s*,\\s*([+-]?[\\d\\.]+)\\%\\s*,\\s*([+-]?[\\d\\.]+)\\%\\s*(?:,\\s*([+-]?[\\d\\.]+)\\s*)?\\)$/,\r\n       keyword = /(\\w+)/;\r\n\r\n   var rgb = [0, 0, 0],\r\n       a = 1,\r\n       match = string.match(abbr);\r\n   if (match) {\r\n      match = match[1];\r\n      for (var i = 0; i < rgb.length; i++) {\r\n         rgb[i] = parseInt(match[i] + match[i], 16);\r\n      }\r\n   }\r\n   else if (match = string.match(hex)) {\r\n      match = match[1];\r\n      for (var i = 0; i < rgb.length; i++) {\r\n         rgb[i] = parseInt(match.slice(i * 2, i * 2 + 2), 16);\r\n      }\r\n   }\r\n   else if (match = string.match(rgba)) {\r\n      for (var i = 0; i < rgb.length; i++) {\r\n         rgb[i] = parseInt(match[i + 1]);\r\n      }\r\n      a = parseFloat(match[4]);\r\n   }\r\n   else if (match = string.match(per)) {\r\n      for (var i = 0; i < rgb.length; i++) {\r\n         rgb[i] = Math.round(parseFloat(match[i + 1]) * 2.55);\r\n      }\r\n      a = parseFloat(match[4]);\r\n   }\r\n   else if (match = string.match(keyword)) {\r\n      if (match[1] == \"transparent\") {\r\n         return [0, 0, 0, 0];\r\n      }\r\n      rgb = colorNames[match[1]];\r\n      if (!rgb) {\r\n         return;\r\n      }\r\n   }\r\n\r\n   for (var i = 0; i < rgb.length; i++) {\r\n      rgb[i] = scale(rgb[i], 0, 255);\r\n   }\r\n   if (!a && a != 0) {\r\n      a = 1;\r\n   }\r\n   else {\r\n      a = scale(a, 0, 1);\r\n   }\r\n   rgb[3] = a;\r\n   return rgb;\r\n}\r\n\r\nfunction getHsla(string) {\r\n   if (!string) {\r\n      return;\r\n   }\r\n   var hsl = /^hsla?\\(\\s*([+-]?\\d+)(?:deg)?\\s*,\\s*([+-]?[\\d\\.]+)%\\s*,\\s*([+-]?[\\d\\.]+)%\\s*(?:,\\s*([+-]?[\\d\\.]+)\\s*)?\\)/;\r\n   var match = string.match(hsl);\r\n   if (match) {\r\n      var alpha = parseFloat(match[4]);\r\n      var h = scale(parseInt(match[1]), 0, 360),\r\n          s = scale(parseFloat(match[2]), 0, 100),\r\n          l = scale(parseFloat(match[3]), 0, 100),\r\n          a = scale(isNaN(alpha) ? 1 : alpha, 0, 1);\r\n      return [h, s, l, a];\r\n   }\r\n}\r\n\r\nfunction getHwb(string) {\r\n   if (!string) {\r\n      return;\r\n   }\r\n   var hwb = /^hwb\\(\\s*([+-]?\\d+)(?:deg)?\\s*,\\s*([+-]?[\\d\\.]+)%\\s*,\\s*([+-]?[\\d\\.]+)%\\s*(?:,\\s*([+-]?[\\d\\.]+)\\s*)?\\)/;\r\n   var match = string.match(hwb);\r\n   if (match) {\r\n    var alpha = parseFloat(match[4]);\r\n      var h = scale(parseInt(match[1]), 0, 360),\r\n          w = scale(parseFloat(match[2]), 0, 100),\r\n          b = scale(parseFloat(match[3]), 0, 100),\r\n          a = scale(isNaN(alpha) ? 1 : alpha, 0, 1);\r\n      return [h, w, b, a];\r\n   }\r\n}\r\n\r\nfunction getRgb(string) {\r\n   var rgba = getRgba(string);\r\n   return rgba && rgba.slice(0, 3);\r\n}\r\n\r\nfunction getHsl(string) {\r\n  var hsla = getHsla(string);\r\n  return hsla && hsla.slice(0, 3);\r\n}\r\n\r\nfunction getAlpha(string) {\r\n   var vals = getRgba(string);\r\n   if (vals) {\r\n      return vals[3];\r\n   }\r\n   else if (vals = getHsla(string)) {\r\n      return vals[3];\r\n   }\r\n   else if (vals = getHwb(string)) {\r\n      return vals[3];\r\n   }\r\n}\r\n\r\n// generators\r\nfunction hexString(rgb) {\r\n   return \"#\" + hexDouble(rgb[0]) + hexDouble(rgb[1])\r\n              + hexDouble(rgb[2]);\r\n}\r\n\r\nfunction rgbString(rgba, alpha) {\r\n   if (alpha < 1 || (rgba[3] && rgba[3] < 1)) {\r\n      return rgbaString(rgba, alpha);\r\n   }\r\n   return \"rgb(\" + rgba[0] + \", \" + rgba[1] + \", \" + rgba[2] + \")\";\r\n}\r\n\r\nfunction rgbaString(rgba, alpha) {\r\n   if (alpha === undefined) {\r\n      alpha = (rgba[3] !== undefined ? rgba[3] : 1);\r\n   }\r\n   return \"rgba(\" + rgba[0] + \", \" + rgba[1] + \", \" + rgba[2]\r\n           + \", \" + alpha + \")\";\r\n}\r\n\r\nfunction percentString(rgba, alpha) {\r\n   if (alpha < 1 || (rgba[3] && rgba[3] < 1)) {\r\n      return percentaString(rgba, alpha);\r\n   }\r\n   var r = Math.round(rgba[0]/255 * 100),\r\n       g = Math.round(rgba[1]/255 * 100),\r\n       b = Math.round(rgba[2]/255 * 100);\r\n\r\n   return \"rgb(\" + r + \"%, \" + g + \"%, \" + b + \"%)\";\r\n}\r\n\r\nfunction percentaString(rgba, alpha) {\r\n   var r = Math.round(rgba[0]/255 * 100),\r\n       g = Math.round(rgba[1]/255 * 100),\r\n       b = Math.round(rgba[2]/255 * 100);\r\n   return \"rgba(\" + r + \"%, \" + g + \"%, \" + b + \"%, \" + (alpha || rgba[3] || 1) + \")\";\r\n}\r\n\r\nfunction hslString(hsla, alpha) {\r\n   if (alpha < 1 || (hsla[3] && hsla[3] < 1)) {\r\n      return hslaString(hsla, alpha);\r\n   }\r\n   return \"hsl(\" + hsla[0] + \", \" + hsla[1] + \"%, \" + hsla[2] + \"%)\";\r\n}\r\n\r\nfunction hslaString(hsla, alpha) {\r\n   if (alpha === undefined) {\r\n      alpha = (hsla[3] !== undefined ? hsla[3] : 1);\r\n   }\r\n   return \"hsla(\" + hsla[0] + \", \" + hsla[1] + \"%, \" + hsla[2] + \"%, \"\r\n           + alpha + \")\";\r\n}\r\n\r\n// hwb is a bit different than rgb(a) & hsl(a) since there is no alpha specific syntax\r\n// (hwb have alpha optional & 1 is default value)\r\nfunction hwbString(hwb, alpha) {\r\n   if (alpha === undefined) {\r\n      alpha = (hwb[3] !== undefined ? hwb[3] : 1);\r\n   }\r\n   return \"hwb(\" + hwb[0] + \", \" + hwb[1] + \"%, \" + hwb[2] + \"%\"\r\n           + (alpha !== undefined && alpha !== 1 ? \", \" + alpha : \"\") + \")\";\r\n}\r\n\r\nfunction keyword(rgb) {\r\n  return reverseNames[rgb.slice(0, 3)];\r\n}\r\n\r\n// helpers\r\nfunction scale(num, min, max) {\r\n   return Math.min(Math.max(min, num), max);\r\n}\r\n\r\nfunction hexDouble(num) {\r\n  var str = num.toString(16).toUpperCase();\r\n  return (str.length < 2) ? \"0\" + str : str;\r\n}\r\n\r\n\r\n//create a list of reverse color names\r\nvar reverseNames = {};\r\nfor (var name in colorNames) {\r\n   reverseNames[colorNames[name]] = name;\r\n}\r\n\n},{\"6\":6}],3:[function(require,module,exports){\n/* MIT license */\r\nvar convert = require(5);\r\nvar string = require(2);\r\n\r\nvar Color = function (obj) {\r\n\tif (obj instanceof Color) {\r\n\t\treturn obj;\r\n\t}\r\n\tif (!(this instanceof Color)) {\r\n\t\treturn new Color(obj);\r\n\t}\r\n\r\n\tthis.values = {\r\n\t\trgb: [0, 0, 0],\r\n\t\thsl: [0, 0, 0],\r\n\t\thsv: [0, 0, 0],\r\n\t\thwb: [0, 0, 0],\r\n\t\tcmyk: [0, 0, 0, 0],\r\n\t\talpha: 1\r\n\t};\r\n\r\n\t// parse Color() argument\r\n\tvar vals;\r\n\tif (typeof obj === 'string') {\r\n\t\tvals = string.getRgba(obj);\r\n\t\tif (vals) {\r\n\t\t\tthis.setValues('rgb', vals);\r\n\t\t} else if (vals = string.getHsla(obj)) {\r\n\t\t\tthis.setValues('hsl', vals);\r\n\t\t} else if (vals = string.getHwb(obj)) {\r\n\t\t\tthis.setValues('hwb', vals);\r\n\t\t} else {\r\n\t\t\tthrow new Error('Unable to parse color from string \"' + obj + '\"');\r\n\t\t}\r\n\t} else if (typeof obj === 'object') {\r\n\t\tvals = obj;\r\n\t\tif (vals.r !== undefined || vals.red !== undefined) {\r\n\t\t\tthis.setValues('rgb', vals);\r\n\t\t} else if (vals.l !== undefined || vals.lightness !== undefined) {\r\n\t\t\tthis.setValues('hsl', vals);\r\n\t\t} else if (vals.v !== undefined || vals.value !== undefined) {\r\n\t\t\tthis.setValues('hsv', vals);\r\n\t\t} else if (vals.w !== undefined || vals.whiteness !== undefined) {\r\n\t\t\tthis.setValues('hwb', vals);\r\n\t\t} else if (vals.c !== undefined || vals.cyan !== undefined) {\r\n\t\t\tthis.setValues('cmyk', vals);\r\n\t\t} else {\r\n\t\t\tthrow new Error('Unable to parse color from object ' + JSON.stringify(obj));\r\n\t\t}\r\n\t}\r\n};\r\n\r\nColor.prototype = {\r\n\trgb: function () {\r\n\t\treturn this.setSpace('rgb', arguments);\r\n\t},\r\n\thsl: function () {\r\n\t\treturn this.setSpace('hsl', arguments);\r\n\t},\r\n\thsv: function () {\r\n\t\treturn this.setSpace('hsv', arguments);\r\n\t},\r\n\thwb: function () {\r\n\t\treturn this.setSpace('hwb', arguments);\r\n\t},\r\n\tcmyk: function () {\r\n\t\treturn this.setSpace('cmyk', arguments);\r\n\t},\r\n\r\n\trgbArray: function () {\r\n\t\treturn this.values.rgb;\r\n\t},\r\n\thslArray: function () {\r\n\t\treturn this.values.hsl;\r\n\t},\r\n\thsvArray: function () {\r\n\t\treturn this.values.hsv;\r\n\t},\r\n\thwbArray: function () {\r\n\t\tvar values = this.values;\r\n\t\tif (values.alpha !== 1) {\r\n\t\t\treturn values.hwb.concat([values.alpha]);\r\n\t\t}\r\n\t\treturn values.hwb;\r\n\t},\r\n\tcmykArray: function () {\r\n\t\treturn this.values.cmyk;\r\n\t},\r\n\trgbaArray: function () {\r\n\t\tvar values = this.values;\r\n\t\treturn values.rgb.concat([values.alpha]);\r\n\t},\r\n\thslaArray: function () {\r\n\t\tvar values = this.values;\r\n\t\treturn values.hsl.concat([values.alpha]);\r\n\t},\r\n\talpha: function (val) {\r\n\t\tif (val === undefined) {\r\n\t\t\treturn this.values.alpha;\r\n\t\t}\r\n\t\tthis.setValues('alpha', val);\r\n\t\treturn this;\r\n\t},\r\n\r\n\tred: function (val) {\r\n\t\treturn this.setChannel('rgb', 0, val);\r\n\t},\r\n\tgreen: function (val) {\r\n\t\treturn this.setChannel('rgb', 1, val);\r\n\t},\r\n\tblue: function (val) {\r\n\t\treturn this.setChannel('rgb', 2, val);\r\n\t},\r\n\thue: function (val) {\r\n\t\tif (val) {\r\n\t\t\tval %= 360;\r\n\t\t\tval = val < 0 ? 360 + val : val;\r\n\t\t}\r\n\t\treturn this.setChannel('hsl', 0, val);\r\n\t},\r\n\tsaturation: function (val) {\r\n\t\treturn this.setChannel('hsl', 1, val);\r\n\t},\r\n\tlightness: function (val) {\r\n\t\treturn this.setChannel('hsl', 2, val);\r\n\t},\r\n\tsaturationv: function (val) {\r\n\t\treturn this.setChannel('hsv', 1, val);\r\n\t},\r\n\twhiteness: function (val) {\r\n\t\treturn this.setChannel('hwb', 1, val);\r\n\t},\r\n\tblackness: function (val) {\r\n\t\treturn this.setChannel('hwb', 2, val);\r\n\t},\r\n\tvalue: function (val) {\r\n\t\treturn this.setChannel('hsv', 2, val);\r\n\t},\r\n\tcyan: function (val) {\r\n\t\treturn this.setChannel('cmyk', 0, val);\r\n\t},\r\n\tmagenta: function (val) {\r\n\t\treturn this.setChannel('cmyk', 1, val);\r\n\t},\r\n\tyellow: function (val) {\r\n\t\treturn this.setChannel('cmyk', 2, val);\r\n\t},\r\n\tblack: function (val) {\r\n\t\treturn this.setChannel('cmyk', 3, val);\r\n\t},\r\n\r\n\thexString: function () {\r\n\t\treturn string.hexString(this.values.rgb);\r\n\t},\r\n\trgbString: function () {\r\n\t\treturn string.rgbString(this.values.rgb, this.values.alpha);\r\n\t},\r\n\trgbaString: function () {\r\n\t\treturn string.rgbaString(this.values.rgb, this.values.alpha);\r\n\t},\r\n\tpercentString: function () {\r\n\t\treturn string.percentString(this.values.rgb, this.values.alpha);\r\n\t},\r\n\thslString: function () {\r\n\t\treturn string.hslString(this.values.hsl, this.values.alpha);\r\n\t},\r\n\thslaString: function () {\r\n\t\treturn string.hslaString(this.values.hsl, this.values.alpha);\r\n\t},\r\n\thwbString: function () {\r\n\t\treturn string.hwbString(this.values.hwb, this.values.alpha);\r\n\t},\r\n\tkeyword: function () {\r\n\t\treturn string.keyword(this.values.rgb, this.values.alpha);\r\n\t},\r\n\r\n\trgbNumber: function () {\r\n\t\tvar rgb = this.values.rgb;\r\n\t\treturn (rgb[0] << 16) | (rgb[1] << 8) | rgb[2];\r\n\t},\r\n\r\n\tluminosity: function () {\r\n\t\t// http://www.w3.org/TR/WCAG20/#relativeluminancedef\r\n\t\tvar rgb = this.values.rgb;\r\n\t\tvar lum = [];\r\n\t\tfor (var i = 0; i < rgb.length; i++) {\r\n\t\t\tvar chan = rgb[i] / 255;\r\n\t\t\tlum[i] = (chan <= 0.03928) ? chan / 12.92 : Math.pow(((chan + 0.055) / 1.055), 2.4);\r\n\t\t}\r\n\t\treturn 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];\r\n\t},\r\n\r\n\tcontrast: function (color2) {\r\n\t\t// http://www.w3.org/TR/WCAG20/#contrast-ratiodef\r\n\t\tvar lum1 = this.luminosity();\r\n\t\tvar lum2 = color2.luminosity();\r\n\t\tif (lum1 > lum2) {\r\n\t\t\treturn (lum1 + 0.05) / (lum2 + 0.05);\r\n\t\t}\r\n\t\treturn (lum2 + 0.05) / (lum1 + 0.05);\r\n\t},\r\n\r\n\tlevel: function (color2) {\r\n\t\tvar contrastRatio = this.contrast(color2);\r\n\t\tif (contrastRatio >= 7.1) {\r\n\t\t\treturn 'AAA';\r\n\t\t}\r\n\r\n\t\treturn (contrastRatio >= 4.5) ? 'AA' : '';\r\n\t},\r\n\r\n\tdark: function () {\r\n\t\t// YIQ equation from http://24ways.org/2010/calculating-color-contrast\r\n\t\tvar rgb = this.values.rgb;\r\n\t\tvar yiq = (rgb[0] * 299 + rgb[1] * 587 + rgb[2] * 114) / 1000;\r\n\t\treturn yiq < 128;\r\n\t},\r\n\r\n\tlight: function () {\r\n\t\treturn !this.dark();\r\n\t},\r\n\r\n\tnegate: function () {\r\n\t\tvar rgb = [];\r\n\t\tfor (var i = 0; i < 3; i++) {\r\n\t\t\trgb[i] = 255 - this.values.rgb[i];\r\n\t\t}\r\n\t\tthis.setValues('rgb', rgb);\r\n\t\treturn this;\r\n\t},\r\n\r\n\tlighten: function (ratio) {\r\n\t\tvar hsl = this.values.hsl;\r\n\t\thsl[2] += hsl[2] * ratio;\r\n\t\tthis.setValues('hsl', hsl);\r\n\t\treturn this;\r\n\t},\r\n\r\n\tdarken: function (ratio) {\r\n\t\tvar hsl = this.values.hsl;\r\n\t\thsl[2] -= hsl[2] * ratio;\r\n\t\tthis.setValues('hsl', hsl);\r\n\t\treturn this;\r\n\t},\r\n\r\n\tsaturate: function (ratio) {\r\n\t\tvar hsl = this.values.hsl;\r\n\t\thsl[1] += hsl[1] * ratio;\r\n\t\tthis.setValues('hsl', hsl);\r\n\t\treturn this;\r\n\t},\r\n\r\n\tdesaturate: function (ratio) {\r\n\t\tvar hsl = this.values.hsl;\r\n\t\thsl[1] -= hsl[1] * ratio;\r\n\t\tthis.setValues('hsl', hsl);\r\n\t\treturn this;\r\n\t},\r\n\r\n\twhiten: function (ratio) {\r\n\t\tvar hwb = this.values.hwb;\r\n\t\thwb[1] += hwb[1] * ratio;\r\n\t\tthis.setValues('hwb', hwb);\r\n\t\treturn this;\r\n\t},\r\n\r\n\tblacken: function (ratio) {\r\n\t\tvar hwb = this.values.hwb;\r\n\t\thwb[2] += hwb[2] * ratio;\r\n\t\tthis.setValues('hwb', hwb);\r\n\t\treturn this;\r\n\t},\r\n\r\n\tgreyscale: function () {\r\n\t\tvar rgb = this.values.rgb;\r\n\t\t// http://en.wikipedia.org/wiki/Grayscale#Converting_color_to_grayscale\r\n\t\tvar val = rgb[0] * 0.3 + rgb[1] * 0.59 + rgb[2] * 0.11;\r\n\t\tthis.setValues('rgb', [val, val, val]);\r\n\t\treturn this;\r\n\t},\r\n\r\n\tclearer: function (ratio) {\r\n\t\tvar alpha = this.values.alpha;\r\n\t\tthis.setValues('alpha', alpha - (alpha * ratio));\r\n\t\treturn this;\r\n\t},\r\n\r\n\topaquer: function (ratio) {\r\n\t\tvar alpha = this.values.alpha;\r\n\t\tthis.setValues('alpha', alpha + (alpha * ratio));\r\n\t\treturn this;\r\n\t},\r\n\r\n\trotate: function (degrees) {\r\n\t\tvar hsl = this.values.hsl;\r\n\t\tvar hue = (hsl[0] + degrees) % 360;\r\n\t\thsl[0] = hue < 0 ? 360 + hue : hue;\r\n\t\tthis.setValues('hsl', hsl);\r\n\t\treturn this;\r\n\t},\r\n\r\n\t/**\r\n\t * Ported from sass implementation in C\r\n\t * https://github.com/sass/libsass/blob/0e6b4a2850092356aa3ece07c6b249f0221caced/functions.cpp#L209\r\n\t */\r\n\tmix: function (mixinColor, weight) {\r\n\t\tvar color1 = this;\r\n\t\tvar color2 = mixinColor;\r\n\t\tvar p = weight === undefined ? 0.5 : weight;\r\n\r\n\t\tvar w = 2 * p - 1;\r\n\t\tvar a = color1.alpha() - color2.alpha();\r\n\r\n\t\tvar w1 = (((w * a === -1) ? w : (w + a) / (1 + w * a)) + 1) / 2.0;\r\n\t\tvar w2 = 1 - w1;\r\n\r\n\t\treturn this\r\n\t\t\t.rgb(\r\n\t\t\t\tw1 * color1.red() + w2 * color2.red(),\r\n\t\t\t\tw1 * color1.green() + w2 * color2.green(),\r\n\t\t\t\tw1 * color1.blue() + w2 * color2.blue()\r\n\t\t\t)\r\n\t\t\t.alpha(color1.alpha() * p + color2.alpha() * (1 - p));\r\n\t},\r\n\r\n\ttoJSON: function () {\r\n\t\treturn this.rgb();\r\n\t},\r\n\r\n\tclone: function () {\r\n\t\t// NOTE(SB): using node-clone creates a dependency to Buffer when using browserify,\r\n\t\t// making the final build way to big to embed in Chart.js. So let's do it manually,\r\n\t\t// assuming that values to clone are 1 dimension arrays containing only numbers,\r\n\t\t// except 'alpha' which is a number.\r\n\t\tvar result = new Color();\r\n\t\tvar source = this.values;\r\n\t\tvar target = result.values;\r\n\t\tvar value, type;\r\n\r\n\t\tfor (var prop in source) {\r\n\t\t\tif (source.hasOwnProperty(prop)) {\r\n\t\t\t\tvalue = source[prop];\r\n\t\t\t\ttype = ({}).toString.call(value);\r\n\t\t\t\tif (type === '[object Array]') {\r\n\t\t\t\t\ttarget[prop] = value.slice(0);\r\n\t\t\t\t} else if (type === '[object Number]') {\r\n\t\t\t\t\ttarget[prop] = value;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tconsole.error('unexpected color value:', value);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\t}\r\n};\r\n\r\nColor.prototype.spaces = {\r\n\trgb: ['red', 'green', 'blue'],\r\n\thsl: ['hue', 'saturation', 'lightness'],\r\n\thsv: ['hue', 'saturation', 'value'],\r\n\thwb: ['hue', 'whiteness', 'blackness'],\r\n\tcmyk: ['cyan', 'magenta', 'yellow', 'black']\r\n};\r\n\r\nColor.prototype.maxes = {\r\n\trgb: [255, 255, 255],\r\n\thsl: [360, 100, 100],\r\n\thsv: [360, 100, 100],\r\n\thwb: [360, 100, 100],\r\n\tcmyk: [100, 100, 100, 100]\r\n};\r\n\r\nColor.prototype.getValues = function (space) {\r\n\tvar values = this.values;\r\n\tvar vals = {};\r\n\r\n\tfor (var i = 0; i < space.length; i++) {\r\n\t\tvals[space.charAt(i)] = values[space][i];\r\n\t}\r\n\r\n\tif (values.alpha !== 1) {\r\n\t\tvals.a = values.alpha;\r\n\t}\r\n\r\n\t// {r: 255, g: 255, b: 255, a: 0.4}\r\n\treturn vals;\r\n};\r\n\r\nColor.prototype.setValues = function (space, vals) {\r\n\tvar values = this.values;\r\n\tvar spaces = this.spaces;\r\n\tvar maxes = this.maxes;\r\n\tvar alpha = 1;\r\n\tvar i;\r\n\r\n\tif (space === 'alpha') {\r\n\t\talpha = vals;\r\n\t} else if (vals.length) {\r\n\t\t// [10, 10, 10]\r\n\t\tvalues[space] = vals.slice(0, space.length);\r\n\t\talpha = vals[space.length];\r\n\t} else if (vals[space.charAt(0)] !== undefined) {\r\n\t\t// {r: 10, g: 10, b: 10}\r\n\t\tfor (i = 0; i < space.length; i++) {\r\n\t\t\tvalues[space][i] = vals[space.charAt(i)];\r\n\t\t}\r\n\r\n\t\talpha = vals.a;\r\n\t} else if (vals[spaces[space][0]] !== undefined) {\r\n\t\t// {red: 10, green: 10, blue: 10}\r\n\t\tvar chans = spaces[space];\r\n\r\n\t\tfor (i = 0; i < space.length; i++) {\r\n\t\t\tvalues[space][i] = vals[chans[i]];\r\n\t\t}\r\n\r\n\t\talpha = vals.alpha;\r\n\t}\r\n\r\n\tvalues.alpha = Math.max(0, Math.min(1, (alpha === undefined ? values.alpha : alpha)));\r\n\r\n\tif (space === 'alpha') {\r\n\t\treturn false;\r\n\t}\r\n\r\n\tvar capped;\r\n\r\n\t// cap values of the space prior converting all values\r\n\tfor (i = 0; i < space.length; i++) {\r\n\t\tcapped = Math.max(0, Math.min(maxes[space][i], values[space][i]));\r\n\t\tvalues[space][i] = Math.round(capped);\r\n\t}\r\n\r\n\t// convert to all the other color spaces\r\n\tfor (var sname in spaces) {\r\n\t\tif (sname !== space) {\r\n\t\t\tvalues[sname] = convert[space][sname](values[space]);\r\n\t\t}\r\n\t}\r\n\r\n\treturn true;\r\n};\r\n\r\nColor.prototype.setSpace = function (space, args) {\r\n\tvar vals = args[0];\r\n\r\n\tif (vals === undefined) {\r\n\t\t// color.rgb()\r\n\t\treturn this.getValues(space);\r\n\t}\r\n\r\n\t// color.rgb(10, 10, 10)\r\n\tif (typeof vals === 'number') {\r\n\t\tvals = Array.prototype.slice.call(args);\r\n\t}\r\n\r\n\tthis.setValues(space, vals);\r\n\treturn this;\r\n};\r\n\r\nColor.prototype.setChannel = function (space, index, val) {\r\n\tvar svalues = this.values[space];\r\n\tif (val === undefined) {\r\n\t\t// color.red()\r\n\t\treturn svalues[index];\r\n\t} else if (val === svalues[index]) {\r\n\t\t// color.red(color.red())\r\n\t\treturn this;\r\n\t}\r\n\r\n\t// color.red(100)\r\n\tsvalues[index] = val;\r\n\tthis.setValues(space, svalues);\r\n\r\n\treturn this;\r\n};\r\n\r\nif (typeof window !== 'undefined') {\r\n\twindow.Color = Color;\r\n}\r\n\r\nmodule.exports = Color;\r\n\n},{\"2\":2,\"5\":5}],4:[function(require,module,exports){\n/* MIT license */\n\nmodule.exports = {\n  rgb2hsl: rgb2hsl,\n  rgb2hsv: rgb2hsv,\n  rgb2hwb: rgb2hwb,\n  rgb2cmyk: rgb2cmyk,\n  rgb2keyword: rgb2keyword,\n  rgb2xyz: rgb2xyz,\n  rgb2lab: rgb2lab,\n  rgb2lch: rgb2lch,\n\n  hsl2rgb: hsl2rgb,\n  hsl2hsv: hsl2hsv,\n  hsl2hwb: hsl2hwb,\n  hsl2cmyk: hsl2cmyk,\n  hsl2keyword: hsl2keyword,\n\n  hsv2rgb: hsv2rgb,\n  hsv2hsl: hsv2hsl,\n  hsv2hwb: hsv2hwb,\n  hsv2cmyk: hsv2cmyk,\n  hsv2keyword: hsv2keyword,\n\n  hwb2rgb: hwb2rgb,\n  hwb2hsl: hwb2hsl,\n  hwb2hsv: hwb2hsv,\n  hwb2cmyk: hwb2cmyk,\n  hwb2keyword: hwb2keyword,\n\n  cmyk2rgb: cmyk2rgb,\n  cmyk2hsl: cmyk2hsl,\n  cmyk2hsv: cmyk2hsv,\n  cmyk2hwb: cmyk2hwb,\n  cmyk2keyword: cmyk2keyword,\n\n  keyword2rgb: keyword2rgb,\n  keyword2hsl: keyword2hsl,\n  keyword2hsv: keyword2hsv,\n  keyword2hwb: keyword2hwb,\n  keyword2cmyk: keyword2cmyk,\n  keyword2lab: keyword2lab,\n  keyword2xyz: keyword2xyz,\n\n  xyz2rgb: xyz2rgb,\n  xyz2lab: xyz2lab,\n  xyz2lch: xyz2lch,\n\n  lab2xyz: lab2xyz,\n  lab2rgb: lab2rgb,\n  lab2lch: lab2lch,\n\n  lch2lab: lch2lab,\n  lch2xyz: lch2xyz,\n  lch2rgb: lch2rgb\n}\n\n\nfunction rgb2hsl(rgb) {\n  var r = rgb[0]/255,\n      g = rgb[1]/255,\n      b = rgb[2]/255,\n      min = Math.min(r, g, b),\n      max = Math.max(r, g, b),\n      delta = max - min,\n      h, s, l;\n\n  if (max == min)\n    h = 0;\n  else if (r == max)\n    h = (g - b) / delta;\n  else if (g == max)\n    h = 2 + (b - r) / delta;\n  else if (b == max)\n    h = 4 + (r - g)/ delta;\n\n  h = Math.min(h * 60, 360);\n\n  if (h < 0)\n    h += 360;\n\n  l = (min + max) / 2;\n\n  if (max == min)\n    s = 0;\n  else if (l <= 0.5)\n    s = delta / (max + min);\n  else\n    s = delta / (2 - max - min);\n\n  return [h, s * 100, l * 100];\n}\n\nfunction rgb2hsv(rgb) {\n  var r = rgb[0],\n      g = rgb[1],\n      b = rgb[2],\n      min = Math.min(r, g, b),\n      max = Math.max(r, g, b),\n      delta = max - min,\n      h, s, v;\n\n  if (max == 0)\n    s = 0;\n  else\n    s = (delta/max * 1000)/10;\n\n  if (max == min)\n    h = 0;\n  else if (r == max)\n    h = (g - b) / delta;\n  else if (g == max)\n    h = 2 + (b - r) / delta;\n  else if (b == max)\n    h = 4 + (r - g) / delta;\n\n  h = Math.min(h * 60, 360);\n\n  if (h < 0)\n    h += 360;\n\n  v = ((max / 255) * 1000) / 10;\n\n  return [h, s, v];\n}\n\nfunction rgb2hwb(rgb) {\n  var r = rgb[0],\n      g = rgb[1],\n      b = rgb[2],\n      h = rgb2hsl(rgb)[0],\n      w = 1/255 * Math.min(r, Math.min(g, b)),\n      b = 1 - 1/255 * Math.max(r, Math.max(g, b));\n\n  return [h, w * 100, b * 100];\n}\n\nfunction rgb2cmyk(rgb) {\n  var r = rgb[0] / 255,\n      g = rgb[1] / 255,\n      b = rgb[2] / 255,\n      c, m, y, k;\n\n  k = Math.min(1 - r, 1 - g, 1 - b);\n  c = (1 - r - k) / (1 - k) || 0;\n  m = (1 - g - k) / (1 - k) || 0;\n  y = (1 - b - k) / (1 - k) || 0;\n  return [c * 100, m * 100, y * 100, k * 100];\n}\n\nfunction rgb2keyword(rgb) {\n  return reverseKeywords[JSON.stringify(rgb)];\n}\n\nfunction rgb2xyz(rgb) {\n  var r = rgb[0] / 255,\n      g = rgb[1] / 255,\n      b = rgb[2] / 255;\n\n  // assume sRGB\n  r = r > 0.04045 ? Math.pow(((r + 0.055) / 1.055), 2.4) : (r / 12.92);\n  g = g > 0.04045 ? Math.pow(((g + 0.055) / 1.055), 2.4) : (g / 12.92);\n  b = b > 0.04045 ? Math.pow(((b + 0.055) / 1.055), 2.4) : (b / 12.92);\n\n  var x = (r * 0.4124) + (g * 0.3576) + (b * 0.1805);\n  var y = (r * 0.2126) + (g * 0.7152) + (b * 0.0722);\n  var z = (r * 0.0193) + (g * 0.1192) + (b * 0.9505);\n\n  return [x * 100, y *100, z * 100];\n}\n\nfunction rgb2lab(rgb) {\n  var xyz = rgb2xyz(rgb),\n        x = xyz[0],\n        y = xyz[1],\n        z = xyz[2],\n        l, a, b;\n\n  x /= 95.047;\n  y /= 100;\n  z /= 108.883;\n\n  x = x > 0.008856 ? Math.pow(x, 1/3) : (7.787 * x) + (16 / 116);\n  y = y > 0.008856 ? Math.pow(y, 1/3) : (7.787 * y) + (16 / 116);\n  z = z > 0.008856 ? Math.pow(z, 1/3) : (7.787 * z) + (16 / 116);\n\n  l = (116 * y) - 16;\n  a = 500 * (x - y);\n  b = 200 * (y - z);\n\n  return [l, a, b];\n}\n\nfunction rgb2lch(args) {\n  return lab2lch(rgb2lab(args));\n}\n\nfunction hsl2rgb(hsl) {\n  var h = hsl[0] / 360,\n      s = hsl[1] / 100,\n      l = hsl[2] / 100,\n      t1, t2, t3, rgb, val;\n\n  if (s == 0) {\n    val = l * 255;\n    return [val, val, val];\n  }\n\n  if (l < 0.5)\n    t2 = l * (1 + s);\n  else\n    t2 = l + s - l * s;\n  t1 = 2 * l - t2;\n\n  rgb = [0, 0, 0];\n  for (var i = 0; i < 3; i++) {\n    t3 = h + 1 / 3 * - (i - 1);\n    t3 < 0 && t3++;\n    t3 > 1 && t3--;\n\n    if (6 * t3 < 1)\n      val = t1 + (t2 - t1) * 6 * t3;\n    else if (2 * t3 < 1)\n      val = t2;\n    else if (3 * t3 < 2)\n      val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;\n    else\n      val = t1;\n\n    rgb[i] = val * 255;\n  }\n\n  return rgb;\n}\n\nfunction hsl2hsv(hsl) {\n  var h = hsl[0],\n      s = hsl[1] / 100,\n      l = hsl[2] / 100,\n      sv, v;\n\n  if(l === 0) {\n      // no need to do calc on black\n      // also avoids divide by 0 error\n      return [0, 0, 0];\n  }\n\n  l *= 2;\n  s *= (l <= 1) ? l : 2 - l;\n  v = (l + s) / 2;\n  sv = (2 * s) / (l + s);\n  return [h, sv * 100, v * 100];\n}\n\nfunction hsl2hwb(args) {\n  return rgb2hwb(hsl2rgb(args));\n}\n\nfunction hsl2cmyk(args) {\n  return rgb2cmyk(hsl2rgb(args));\n}\n\nfunction hsl2keyword(args) {\n  return rgb2keyword(hsl2rgb(args));\n}\n\n\nfunction hsv2rgb(hsv) {\n  var h = hsv[0] / 60,\n      s = hsv[1] / 100,\n      v = hsv[2] / 100,\n      hi = Math.floor(h) % 6;\n\n  var f = h - Math.floor(h),\n      p = 255 * v * (1 - s),\n      q = 255 * v * (1 - (s * f)),\n      t = 255 * v * (1 - (s * (1 - f))),\n      v = 255 * v;\n\n  switch(hi) {\n    case 0:\n      return [v, t, p];\n    case 1:\n      return [q, v, p];\n    case 2:\n      return [p, v, t];\n    case 3:\n      return [p, q, v];\n    case 4:\n      return [t, p, v];\n    case 5:\n      return [v, p, q];\n  }\n}\n\nfunction hsv2hsl(hsv) {\n  var h = hsv[0],\n      s = hsv[1] / 100,\n      v = hsv[2] / 100,\n      sl, l;\n\n  l = (2 - s) * v;\n  sl = s * v;\n  sl /= (l <= 1) ? l : 2 - l;\n  sl = sl || 0;\n  l /= 2;\n  return [h, sl * 100, l * 100];\n}\n\nfunction hsv2hwb(args) {\n  return rgb2hwb(hsv2rgb(args))\n}\n\nfunction hsv2cmyk(args) {\n  return rgb2cmyk(hsv2rgb(args));\n}\n\nfunction hsv2keyword(args) {\n  return rgb2keyword(hsv2rgb(args));\n}\n\n// http://dev.w3.org/csswg/css-color/#hwb-to-rgb\nfunction hwb2rgb(hwb) {\n  var h = hwb[0] / 360,\n      wh = hwb[1] / 100,\n      bl = hwb[2] / 100,\n      ratio = wh + bl,\n      i, v, f, n;\n\n  // wh + bl cant be > 1\n  if (ratio > 1) {\n    wh /= ratio;\n    bl /= ratio;\n  }\n\n  i = Math.floor(6 * h);\n  v = 1 - bl;\n  f = 6 * h - i;\n  if ((i & 0x01) != 0) {\n    f = 1 - f;\n  }\n  n = wh + f * (v - wh);  // linear interpolation\n\n  switch (i) {\n    default:\n    case 6:\n    case 0: r = v; g = n; b = wh; break;\n    case 1: r = n; g = v; b = wh; break;\n    case 2: r = wh; g = v; b = n; break;\n    case 3: r = wh; g = n; b = v; break;\n    case 4: r = n; g = wh; b = v; break;\n    case 5: r = v; g = wh; b = n; break;\n  }\n\n  return [r * 255, g * 255, b * 255];\n}\n\nfunction hwb2hsl(args) {\n  return rgb2hsl(hwb2rgb(args));\n}\n\nfunction hwb2hsv(args) {\n  return rgb2hsv(hwb2rgb(args));\n}\n\nfunction hwb2cmyk(args) {\n  return rgb2cmyk(hwb2rgb(args));\n}\n\nfunction hwb2keyword(args) {\n  return rgb2keyword(hwb2rgb(args));\n}\n\nfunction cmyk2rgb(cmyk) {\n  var c = cmyk[0] / 100,\n      m = cmyk[1] / 100,\n      y = cmyk[2] / 100,\n      k = cmyk[3] / 100,\n      r, g, b;\n\n  r = 1 - Math.min(1, c * (1 - k) + k);\n  g = 1 - Math.min(1, m * (1 - k) + k);\n  b = 1 - Math.min(1, y * (1 - k) + k);\n  return [r * 255, g * 255, b * 255];\n}\n\nfunction cmyk2hsl(args) {\n  return rgb2hsl(cmyk2rgb(args));\n}\n\nfunction cmyk2hsv(args) {\n  return rgb2hsv(cmyk2rgb(args));\n}\n\nfunction cmyk2hwb(args) {\n  return rgb2hwb(cmyk2rgb(args));\n}\n\nfunction cmyk2keyword(args) {\n  return rgb2keyword(cmyk2rgb(args));\n}\n\n\nfunction xyz2rgb(xyz) {\n  var x = xyz[0] / 100,\n      y = xyz[1] / 100,\n      z = xyz[2] / 100,\n      r, g, b;\n\n  r = (x * 3.2406) + (y * -1.5372) + (z * -0.4986);\n  g = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);\n  b = (x * 0.0557) + (y * -0.2040) + (z * 1.0570);\n\n  // assume sRGB\n  r = r > 0.0031308 ? ((1.055 * Math.pow(r, 1.0 / 2.4)) - 0.055)\n    : r = (r * 12.92);\n\n  g = g > 0.0031308 ? ((1.055 * Math.pow(g, 1.0 / 2.4)) - 0.055)\n    : g = (g * 12.92);\n\n  b = b > 0.0031308 ? ((1.055 * Math.pow(b, 1.0 / 2.4)) - 0.055)\n    : b = (b * 12.92);\n\n  r = Math.min(Math.max(0, r), 1);\n  g = Math.min(Math.max(0, g), 1);\n  b = Math.min(Math.max(0, b), 1);\n\n  return [r * 255, g * 255, b * 255];\n}\n\nfunction xyz2lab(xyz) {\n  var x = xyz[0],\n      y = xyz[1],\n      z = xyz[2],\n      l, a, b;\n\n  x /= 95.047;\n  y /= 100;\n  z /= 108.883;\n\n  x = x > 0.008856 ? Math.pow(x, 1/3) : (7.787 * x) + (16 / 116);\n  y = y > 0.008856 ? Math.pow(y, 1/3) : (7.787 * y) + (16 / 116);\n  z = z > 0.008856 ? Math.pow(z, 1/3) : (7.787 * z) + (16 / 116);\n\n  l = (116 * y) - 16;\n  a = 500 * (x - y);\n  b = 200 * (y - z);\n\n  return [l, a, b];\n}\n\nfunction xyz2lch(args) {\n  return lab2lch(xyz2lab(args));\n}\n\nfunction lab2xyz(lab) {\n  var l = lab[0],\n      a = lab[1],\n      b = lab[2],\n      x, y, z, y2;\n\n  if (l <= 8) {\n    y = (l * 100) / 903.3;\n    y2 = (7.787 * (y / 100)) + (16 / 116);\n  } else {\n    y = 100 * Math.pow((l + 16) / 116, 3);\n    y2 = Math.pow(y / 100, 1/3);\n  }\n\n  x = x / 95.047 <= 0.008856 ? x = (95.047 * ((a / 500) + y2 - (16 / 116))) / 7.787 : 95.047 * Math.pow((a / 500) + y2, 3);\n\n  z = z / 108.883 <= 0.008859 ? z = (108.883 * (y2 - (b / 200) - (16 / 116))) / 7.787 : 108.883 * Math.pow(y2 - (b / 200), 3);\n\n  return [x, y, z];\n}\n\nfunction lab2lch(lab) {\n  var l = lab[0],\n      a = lab[1],\n      b = lab[2],\n      hr, h, c;\n\n  hr = Math.atan2(b, a);\n  h = hr * 360 / 2 / Math.PI;\n  if (h < 0) {\n    h += 360;\n  }\n  c = Math.sqrt(a * a + b * b);\n  return [l, c, h];\n}\n\nfunction lab2rgb(args) {\n  return xyz2rgb(lab2xyz(args));\n}\n\nfunction lch2lab(lch) {\n  var l = lch[0],\n      c = lch[1],\n      h = lch[2],\n      a, b, hr;\n\n  hr = h / 360 * 2 * Math.PI;\n  a = c * Math.cos(hr);\n  b = c * Math.sin(hr);\n  return [l, a, b];\n}\n\nfunction lch2xyz(args) {\n  return lab2xyz(lch2lab(args));\n}\n\nfunction lch2rgb(args) {\n  return lab2rgb(lch2lab(args));\n}\n\nfunction keyword2rgb(keyword) {\n  return cssKeywords[keyword];\n}\n\nfunction keyword2hsl(args) {\n  return rgb2hsl(keyword2rgb(args));\n}\n\nfunction keyword2hsv(args) {\n  return rgb2hsv(keyword2rgb(args));\n}\n\nfunction keyword2hwb(args) {\n  return rgb2hwb(keyword2rgb(args));\n}\n\nfunction keyword2cmyk(args) {\n  return rgb2cmyk(keyword2rgb(args));\n}\n\nfunction keyword2lab(args) {\n  return rgb2lab(keyword2rgb(args));\n}\n\nfunction keyword2xyz(args) {\n  return rgb2xyz(keyword2rgb(args));\n}\n\nvar cssKeywords = {\n  aliceblue:  [240,248,255],\n  antiquewhite: [250,235,215],\n  aqua: [0,255,255],\n  aquamarine: [127,255,212],\n  azure:  [240,255,255],\n  beige:  [245,245,220],\n  bisque: [255,228,196],\n  black:  [0,0,0],\n  blanchedalmond: [255,235,205],\n  blue: [0,0,255],\n  blueviolet: [138,43,226],\n  brown:  [165,42,42],\n  burlywood:  [222,184,135],\n  cadetblue:  [95,158,160],\n  chartreuse: [127,255,0],\n  chocolate:  [210,105,30],\n  coral:  [255,127,80],\n  cornflowerblue: [100,149,237],\n  cornsilk: [255,248,220],\n  crimson:  [220,20,60],\n  cyan: [0,255,255],\n  darkblue: [0,0,139],\n  darkcyan: [0,139,139],\n  darkgoldenrod:  [184,134,11],\n  darkgray: [169,169,169],\n  darkgreen:  [0,100,0],\n  darkgrey: [169,169,169],\n  darkkhaki:  [189,183,107],\n  darkmagenta:  [139,0,139],\n  darkolivegreen: [85,107,47],\n  darkorange: [255,140,0],\n  darkorchid: [153,50,204],\n  darkred:  [139,0,0],\n  darksalmon: [233,150,122],\n  darkseagreen: [143,188,143],\n  darkslateblue:  [72,61,139],\n  darkslategray:  [47,79,79],\n  darkslategrey:  [47,79,79],\n  darkturquoise:  [0,206,209],\n  darkviolet: [148,0,211],\n  deeppink: [255,20,147],\n  deepskyblue:  [0,191,255],\n  dimgray:  [105,105,105],\n  dimgrey:  [105,105,105],\n  dodgerblue: [30,144,255],\n  firebrick:  [178,34,34],\n  floralwhite:  [255,250,240],\n  forestgreen:  [34,139,34],\n  fuchsia:  [255,0,255],\n  gainsboro:  [220,220,220],\n  ghostwhite: [248,248,255],\n  gold: [255,215,0],\n  goldenrod:  [218,165,32],\n  gray: [128,128,128],\n  green:  [0,128,0],\n  greenyellow:  [173,255,47],\n  grey: [128,128,128],\n  honeydew: [240,255,240],\n  hotpink:  [255,105,180],\n  indianred:  [205,92,92],\n  indigo: [75,0,130],\n  ivory:  [255,255,240],\n  khaki:  [240,230,140],\n  lavender: [230,230,250],\n  lavenderblush:  [255,240,245],\n  lawngreen:  [124,252,0],\n  lemonchiffon: [255,250,205],\n  lightblue:  [173,216,230],\n  lightcoral: [240,128,128],\n  lightcyan:  [224,255,255],\n  lightgoldenrodyellow: [250,250,210],\n  lightgray:  [211,211,211],\n  lightgreen: [144,238,144],\n  lightgrey:  [211,211,211],\n  lightpink:  [255,182,193],\n  lightsalmon:  [255,160,122],\n  lightseagreen:  [32,178,170],\n  lightskyblue: [135,206,250],\n  lightslategray: [119,136,153],\n  lightslategrey: [119,136,153],\n  lightsteelblue: [176,196,222],\n  lightyellow:  [255,255,224],\n  lime: [0,255,0],\n  limegreen:  [50,205,50],\n  linen:  [250,240,230],\n  magenta:  [255,0,255],\n  maroon: [128,0,0],\n  mediumaquamarine: [102,205,170],\n  mediumblue: [0,0,205],\n  mediumorchid: [186,85,211],\n  mediumpurple: [147,112,219],\n  mediumseagreen: [60,179,113],\n  mediumslateblue:  [123,104,238],\n  mediumspringgreen:  [0,250,154],\n  mediumturquoise:  [72,209,204],\n  mediumvioletred:  [199,21,133],\n  midnightblue: [25,25,112],\n  mintcream:  [245,255,250],\n  mistyrose:  [255,228,225],\n  moccasin: [255,228,181],\n  navajowhite:  [255,222,173],\n  navy: [0,0,128],\n  oldlace:  [253,245,230],\n  olive:  [128,128,0],\n  olivedrab:  [107,142,35],\n  orange: [255,165,0],\n  orangered:  [255,69,0],\n  orchid: [218,112,214],\n  palegoldenrod:  [238,232,170],\n  palegreen:  [152,251,152],\n  paleturquoise:  [175,238,238],\n  palevioletred:  [219,112,147],\n  papayawhip: [255,239,213],\n  peachpuff:  [255,218,185],\n  peru: [205,133,63],\n  pink: [255,192,203],\n  plum: [221,160,221],\n  powderblue: [176,224,230],\n  purple: [128,0,128],\n  rebeccapurple: [102, 51, 153],\n  red:  [255,0,0],\n  rosybrown:  [188,143,143],\n  royalblue:  [65,105,225],\n  saddlebrown:  [139,69,19],\n  salmon: [250,128,114],\n  sandybrown: [244,164,96],\n  seagreen: [46,139,87],\n  seashell: [255,245,238],\n  sienna: [160,82,45],\n  silver: [192,192,192],\n  skyblue:  [135,206,235],\n  slateblue:  [106,90,205],\n  slategray:  [112,128,144],\n  slategrey:  [112,128,144],\n  snow: [255,250,250],\n  springgreen:  [0,255,127],\n  steelblue:  [70,130,180],\n  tan:  [210,180,140],\n  teal: [0,128,128],\n  thistle:  [216,191,216],\n  tomato: [255,99,71],\n  turquoise:  [64,224,208],\n  violet: [238,130,238],\n  wheat:  [245,222,179],\n  white:  [255,255,255],\n  whitesmoke: [245,245,245],\n  yellow: [255,255,0],\n  yellowgreen:  [154,205,50]\n};\n\nvar reverseKeywords = {};\nfor (var key in cssKeywords) {\n  reverseKeywords[JSON.stringify(cssKeywords[key])] = key;\n}\n\n},{}],5:[function(require,module,exports){\nvar conversions = require(4);\n\nvar convert = function() {\n   return new Converter();\n}\n\nfor (var func in conversions) {\n  // export Raw versions\n  convert[func + \"Raw\"] =  (function(func) {\n    // accept array or plain args\n    return function(arg) {\n      if (typeof arg == \"number\")\n        arg = Array.prototype.slice.call(arguments);\n      return conversions[func](arg);\n    }\n  })(func);\n\n  var pair = /(\\w+)2(\\w+)/.exec(func),\n      from = pair[1],\n      to = pair[2];\n\n  // export rgb2hsl and [\"rgb\"][\"hsl\"]\n  convert[from] = convert[from] || {};\n\n  convert[from][to] = convert[func] = (function(func) { \n    return function(arg) {\n      if (typeof arg == \"number\")\n        arg = Array.prototype.slice.call(arguments);\n      \n      var val = conversions[func](arg);\n      if (typeof val == \"string\" || val === undefined)\n        return val; // keyword\n\n      for (var i = 0; i < val.length; i++)\n        val[i] = Math.round(val[i]);\n      return val;\n    }\n  })(func);\n}\n\n\n/* Converter does lazy conversion and caching */\nvar Converter = function() {\n   this.convs = {};\n};\n\n/* Either get the values for a space or\n  set the values for a space, depending on args */\nConverter.prototype.routeSpace = function(space, args) {\n   var values = args[0];\n   if (values === undefined) {\n      // color.rgb()\n      return this.getValues(space);\n   }\n   // color.rgb(10, 10, 10)\n   if (typeof values == \"number\") {\n      values = Array.prototype.slice.call(args);        \n   }\n\n   return this.setValues(space, values);\n};\n  \n/* Set the values for a space, invalidating cache */\nConverter.prototype.setValues = function(space, values) {\n   this.space = space;\n   this.convs = {};\n   this.convs[space] = values;\n   return this;\n};\n\n/* Get the values for a space. If there's already\n  a conversion for the space, fetch it, otherwise\n  compute it */\nConverter.prototype.getValues = function(space) {\n   var vals = this.convs[space];\n   if (!vals) {\n      var fspace = this.space,\n          from = this.convs[fspace];\n      vals = convert[fspace][space](from);\n\n      this.convs[space] = vals;\n   }\n  return vals;\n};\n\n[\"rgb\", \"hsl\", \"hsv\", \"cmyk\", \"keyword\"].forEach(function(space) {\n   Converter.prototype[space] = function(vals) {\n      return this.routeSpace(space, arguments);\n   }\n});\n\nmodule.exports = convert;\n},{\"4\":4}],6:[function(require,module,exports){\nmodule.exports = {\r\n\t\"aliceblue\": [240, 248, 255],\r\n\t\"antiquewhite\": [250, 235, 215],\r\n\t\"aqua\": [0, 255, 255],\r\n\t\"aquamarine\": [127, 255, 212],\r\n\t\"azure\": [240, 255, 255],\r\n\t\"beige\": [245, 245, 220],\r\n\t\"bisque\": [255, 228, 196],\r\n\t\"black\": [0, 0, 0],\r\n\t\"blanchedalmond\": [255, 235, 205],\r\n\t\"blue\": [0, 0, 255],\r\n\t\"blueviolet\": [138, 43, 226],\r\n\t\"brown\": [165, 42, 42],\r\n\t\"burlywood\": [222, 184, 135],\r\n\t\"cadetblue\": [95, 158, 160],\r\n\t\"chartreuse\": [127, 255, 0],\r\n\t\"chocolate\": [210, 105, 30],\r\n\t\"coral\": [255, 127, 80],\r\n\t\"cornflowerblue\": [100, 149, 237],\r\n\t\"cornsilk\": [255, 248, 220],\r\n\t\"crimson\": [220, 20, 60],\r\n\t\"cyan\": [0, 255, 255],\r\n\t\"darkblue\": [0, 0, 139],\r\n\t\"darkcyan\": [0, 139, 139],\r\n\t\"darkgoldenrod\": [184, 134, 11],\r\n\t\"darkgray\": [169, 169, 169],\r\n\t\"darkgreen\": [0, 100, 0],\r\n\t\"darkgrey\": [169, 169, 169],\r\n\t\"darkkhaki\": [189, 183, 107],\r\n\t\"darkmagenta\": [139, 0, 139],\r\n\t\"darkolivegreen\": [85, 107, 47],\r\n\t\"darkorange\": [255, 140, 0],\r\n\t\"darkorchid\": [153, 50, 204],\r\n\t\"darkred\": [139, 0, 0],\r\n\t\"darksalmon\": [233, 150, 122],\r\n\t\"darkseagreen\": [143, 188, 143],\r\n\t\"darkslateblue\": [72, 61, 139],\r\n\t\"darkslategray\": [47, 79, 79],\r\n\t\"darkslategrey\": [47, 79, 79],\r\n\t\"darkturquoise\": [0, 206, 209],\r\n\t\"darkviolet\": [148, 0, 211],\r\n\t\"deeppink\": [255, 20, 147],\r\n\t\"deepskyblue\": [0, 191, 255],\r\n\t\"dimgray\": [105, 105, 105],\r\n\t\"dimgrey\": [105, 105, 105],\r\n\t\"dodgerblue\": [30, 144, 255],\r\n\t\"firebrick\": [178, 34, 34],\r\n\t\"floralwhite\": [255, 250, 240],\r\n\t\"forestgreen\": [34, 139, 34],\r\n\t\"fuchsia\": [255, 0, 255],\r\n\t\"gainsboro\": [220, 220, 220],\r\n\t\"ghostwhite\": [248, 248, 255],\r\n\t\"gold\": [255, 215, 0],\r\n\t\"goldenrod\": [218, 165, 32],\r\n\t\"gray\": [128, 128, 128],\r\n\t\"green\": [0, 128, 0],\r\n\t\"greenyellow\": [173, 255, 47],\r\n\t\"grey\": [128, 128, 128],\r\n\t\"honeydew\": [240, 255, 240],\r\n\t\"hotpink\": [255, 105, 180],\r\n\t\"indianred\": [205, 92, 92],\r\n\t\"indigo\": [75, 0, 130],\r\n\t\"ivory\": [255, 255, 240],\r\n\t\"khaki\": [240, 230, 140],\r\n\t\"lavender\": [230, 230, 250],\r\n\t\"lavenderblush\": [255, 240, 245],\r\n\t\"lawngreen\": [124, 252, 0],\r\n\t\"lemonchiffon\": [255, 250, 205],\r\n\t\"lightblue\": [173, 216, 230],\r\n\t\"lightcoral\": [240, 128, 128],\r\n\t\"lightcyan\": [224, 255, 255],\r\n\t\"lightgoldenrodyellow\": [250, 250, 210],\r\n\t\"lightgray\": [211, 211, 211],\r\n\t\"lightgreen\": [144, 238, 144],\r\n\t\"lightgrey\": [211, 211, 211],\r\n\t\"lightpink\": [255, 182, 193],\r\n\t\"lightsalmon\": [255, 160, 122],\r\n\t\"lightseagreen\": [32, 178, 170],\r\n\t\"lightskyblue\": [135, 206, 250],\r\n\t\"lightslategray\": [119, 136, 153],\r\n\t\"lightslategrey\": [119, 136, 153],\r\n\t\"lightsteelblue\": [176, 196, 222],\r\n\t\"lightyellow\": [255, 255, 224],\r\n\t\"lime\": [0, 255, 0],\r\n\t\"limegreen\": [50, 205, 50],\r\n\t\"linen\": [250, 240, 230],\r\n\t\"magenta\": [255, 0, 255],\r\n\t\"maroon\": [128, 0, 0],\r\n\t\"mediumaquamarine\": [102, 205, 170],\r\n\t\"mediumblue\": [0, 0, 205],\r\n\t\"mediumorchid\": [186, 85, 211],\r\n\t\"mediumpurple\": [147, 112, 219],\r\n\t\"mediumseagreen\": [60, 179, 113],\r\n\t\"mediumslateblue\": [123, 104, 238],\r\n\t\"mediumspringgreen\": [0, 250, 154],\r\n\t\"mediumturquoise\": [72, 209, 204],\r\n\t\"mediumvioletred\": [199, 21, 133],\r\n\t\"midnightblue\": [25, 25, 112],\r\n\t\"mintcream\": [245, 255, 250],\r\n\t\"mistyrose\": [255, 228, 225],\r\n\t\"moccasin\": [255, 228, 181],\r\n\t\"navajowhite\": [255, 222, 173],\r\n\t\"navy\": [0, 0, 128],\r\n\t\"oldlace\": [253, 245, 230],\r\n\t\"olive\": [128, 128, 0],\r\n\t\"olivedrab\": [107, 142, 35],\r\n\t\"orange\": [255, 165, 0],\r\n\t\"orangered\": [255, 69, 0],\r\n\t\"orchid\": [218, 112, 214],\r\n\t\"palegoldenrod\": [238, 232, 170],\r\n\t\"palegreen\": [152, 251, 152],\r\n\t\"paleturquoise\": [175, 238, 238],\r\n\t\"palevioletred\": [219, 112, 147],\r\n\t\"papayawhip\": [255, 239, 213],\r\n\t\"peachpuff\": [255, 218, 185],\r\n\t\"peru\": [205, 133, 63],\r\n\t\"pink\": [255, 192, 203],\r\n\t\"plum\": [221, 160, 221],\r\n\t\"powderblue\": [176, 224, 230],\r\n\t\"purple\": [128, 0, 128],\r\n\t\"rebeccapurple\": [102, 51, 153],\r\n\t\"red\": [255, 0, 0],\r\n\t\"rosybrown\": [188, 143, 143],\r\n\t\"royalblue\": [65, 105, 225],\r\n\t\"saddlebrown\": [139, 69, 19],\r\n\t\"salmon\": [250, 128, 114],\r\n\t\"sandybrown\": [244, 164, 96],\r\n\t\"seagreen\": [46, 139, 87],\r\n\t\"seashell\": [255, 245, 238],\r\n\t\"sienna\": [160, 82, 45],\r\n\t\"silver\": [192, 192, 192],\r\n\t\"skyblue\": [135, 206, 235],\r\n\t\"slateblue\": [106, 90, 205],\r\n\t\"slategray\": [112, 128, 144],\r\n\t\"slategrey\": [112, 128, 144],\r\n\t\"snow\": [255, 250, 250],\r\n\t\"springgreen\": [0, 255, 127],\r\n\t\"steelblue\": [70, 130, 180],\r\n\t\"tan\": [210, 180, 140],\r\n\t\"teal\": [0, 128, 128],\r\n\t\"thistle\": [216, 191, 216],\r\n\t\"tomato\": [255, 99, 71],\r\n\t\"turquoise\": [64, 224, 208],\r\n\t\"violet\": [238, 130, 238],\r\n\t\"wheat\": [245, 222, 179],\r\n\t\"white\": [255, 255, 255],\r\n\t\"whitesmoke\": [245, 245, 245],\r\n\t\"yellow\": [255, 255, 0],\r\n\t\"yellowgreen\": [154, 205, 50]\r\n};\n},{}],7:[function(require,module,exports){\n/**\n * @namespace Chart\n */\nvar Chart = require(28)();\n\nrequire(26)(Chart);\nrequire(42)(Chart);\nrequire(22)(Chart);\nrequire(31)(Chart);\nrequire(25)(Chart);\nrequire(21)(Chart);\nrequire(23)(Chart);\nrequire(24)(Chart);\nrequire(29)(Chart);\nrequire(33)(Chart);\nrequire(34)(Chart);\nrequire(32)(Chart);\nrequire(35)(Chart);\nrequire(30)(Chart);\nrequire(27)(Chart);\nrequire(36)(Chart);\n\nrequire(37)(Chart);\nrequire(38)(Chart);\nrequire(39)(Chart);\nrequire(40)(Chart);\n\nrequire(45)(Chart);\nrequire(43)(Chart);\nrequire(44)(Chart);\nrequire(46)(Chart);\nrequire(47)(Chart);\nrequire(48)(Chart);\n\n// Controllers must be loaded after elements\n// See Chart.core.datasetController.dataElementType\nrequire(15)(Chart);\nrequire(16)(Chart);\nrequire(17)(Chart);\nrequire(18)(Chart);\nrequire(19)(Chart);\nrequire(20)(Chart);\n\nrequire(8)(Chart);\nrequire(9)(Chart);\nrequire(10)(Chart);\nrequire(11)(Chart);\nrequire(12)(Chart);\nrequire(13)(Chart);\nrequire(14)(Chart);\n\nwindow.Chart = module.exports = Chart;\n\n},{\"10\":10,\"11\":11,\"12\":12,\"13\":13,\"14\":14,\"15\":15,\"16\":16,\"17\":17,\"18\":18,\"19\":19,\"20\":20,\"21\":21,\"22\":22,\"23\":23,\"24\":24,\"25\":25,\"26\":26,\"27\":27,\"28\":28,\"29\":29,\"30\":30,\"31\":31,\"32\":32,\"33\":33,\"34\":34,\"35\":35,\"36\":36,\"37\":37,\"38\":38,\"39\":39,\"40\":40,\"42\":42,\"43\":43,\"44\":44,\"45\":45,\"46\":46,\"47\":47,\"48\":48,\"8\":8,\"9\":9}],8:[function(require,module,exports){\n'use strict';\n\nmodule.exports = function(Chart) {\n\n\tChart.Bar = function(context, config) {\n\t\tconfig.type = 'bar';\n\n\t\treturn new Chart(context, config);\n\t};\n\n};\n\n},{}],9:[function(require,module,exports){\n'use strict';\n\nmodule.exports = function(Chart) {\n\n\tChart.Bubble = function(context, config) {\n\t\tconfig.type = 'bubble';\n\t\treturn new Chart(context, config);\n\t};\n\n};\n\n},{}],10:[function(require,module,exports){\n'use strict';\n\nmodule.exports = function(Chart) {\n\n\tChart.Doughnut = function(context, config) {\n\t\tconfig.type = 'doughnut';\n\n\t\treturn new Chart(context, config);\n\t};\n\n};\n\n},{}],11:[function(require,module,exports){\n'use strict';\n\nmodule.exports = function(Chart) {\n\n\tChart.Line = function(context, config) {\n\t\tconfig.type = 'line';\n\n\t\treturn new Chart(context, config);\n\t};\n\n};\n\n},{}],12:[function(require,module,exports){\n'use strict';\n\nmodule.exports = function(Chart) {\n\n\tChart.PolarArea = function(context, config) {\n\t\tconfig.type = 'polarArea';\n\n\t\treturn new Chart(context, config);\n\t};\n\n};\n\n},{}],13:[function(require,module,exports){\n'use strict';\n\nmodule.exports = function(Chart) {\n\n\tChart.Radar = function(context, config) {\n\t\tconfig.type = 'radar';\n\n\t\treturn new Chart(context, config);\n\t};\n\n};\n\n},{}],14:[function(require,module,exports){\n'use strict';\n\nmodule.exports = function(Chart) {\n\n\tvar defaultConfig = {\n\t\thover: {\n\t\t\tmode: 'single'\n\t\t},\n\n\t\tscales: {\n\t\t\txAxes: [{\n\t\t\t\ttype: 'linear', // scatter should not use a category axis\n\t\t\t\tposition: 'bottom',\n\t\t\t\tid: 'x-axis-1' // need an ID so datasets can reference the scale\n\t\t\t}],\n\t\t\tyAxes: [{\n\t\t\t\ttype: 'linear',\n\t\t\t\tposition: 'left',\n\t\t\t\tid: 'y-axis-1'\n\t\t\t}]\n\t\t},\n\n\t\ttooltips: {\n\t\t\tcallbacks: {\n\t\t\t\ttitle: function() {\n\t\t\t\t\t// Title doesn't make sense for scatter since we format the data as a point\n\t\t\t\t\treturn '';\n\t\t\t\t},\n\t\t\t\tlabel: function(tooltipItem) {\n\t\t\t\t\treturn '(' + tooltipItem.xLabel + ', ' + tooltipItem.yLabel + ')';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\t// Register the default config for this type\n\tChart.defaults.scatter = defaultConfig;\n\n\t// Scatter charts use line controllers\n\tChart.controllers.scatter = Chart.controllers.line;\n\n\tChart.Scatter = function(context, config) {\n\t\tconfig.type = 'scatter';\n\t\treturn new Chart(context, config);\n\t};\n\n};\n\n},{}],15:[function(require,module,exports){\n'use strict';\n\nmodule.exports = function(Chart) {\n\n\tvar helpers = Chart.helpers;\n\n\tChart.defaults.bar = {\n\t\thover: {\n\t\t\tmode: 'label'\n\t\t},\n\n\t\tscales: {\n\t\t\txAxes: [{\n\t\t\t\ttype: 'category',\n\n\t\t\t\t// Specific to Bar Controller\n\t\t\t\tcategoryPercentage: 0.8,\n\t\t\t\tbarPercentage: 0.9,\n\n\t\t\t\t// grid line settings\n\t\t\t\tgridLines: {\n\t\t\t\t\toffsetGridLines: true\n\t\t\t\t}\n\t\t\t}],\n\t\t\tyAxes: [{\n\t\t\t\ttype: 'linear'\n\t\t\t}]\n\t\t}\n\t};\n\n\tChart.controllers.bar = Chart.DatasetController.extend({\n\n\t\tdataElementType: Chart.elements.Rectangle,\n\n\t\tinitialize: function(chart, datasetIndex) {\n\t\t\tChart.DatasetController.prototype.initialize.call(this, chart, datasetIndex);\n\n\t\t\tvar me = this;\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar dataset = me.getDataset();\n\n\t\t\tmeta.stack = dataset.stack;\n\t\t\t// Use this to indicate that this is a bar dataset.\n\t\t\tmeta.bar = true;\n\t\t},\n\n\t\t// Correctly calculate the bar width accounting for stacks and the fact that not all bars are visible\n\t\tgetStackCount: function() {\n\t\t\tvar me = this;\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar yScale = me.getScaleForId(meta.yAxisID);\n\n\t\t\tvar stacks = [];\n\t\t\thelpers.each(me.chart.data.datasets, function(dataset, datasetIndex) {\n\t\t\t\tvar dsMeta = me.chart.getDatasetMeta(datasetIndex);\n\t\t\t\tif (dsMeta.bar && me.chart.isDatasetVisible(datasetIndex) &&\n\t\t\t\t\t(yScale.options.stacked === false ||\n\t\t\t\t\t(yScale.options.stacked === true && stacks.indexOf(dsMeta.stack) === -1) ||\n\t\t\t\t\t(yScale.options.stacked === undefined && (dsMeta.stack === undefined || stacks.indexOf(dsMeta.stack) === -1)))) {\n\t\t\t\t\tstacks.push(dsMeta.stack);\n\t\t\t\t}\n\t\t\t}, me);\n\n\t\t\treturn stacks.length;\n\t\t},\n\n\t\tupdate: function(reset) {\n\t\t\tvar me = this;\n\t\t\thelpers.each(me.getMeta().data, function(rectangle, index) {\n\t\t\t\tme.updateElement(rectangle, index, reset);\n\t\t\t}, me);\n\t\t},\n\n\t\tupdateElement: function(rectangle, index, reset) {\n\t\t\tvar me = this;\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar xScale = me.getScaleForId(meta.xAxisID);\n\t\t\tvar yScale = me.getScaleForId(meta.yAxisID);\n\t\t\tvar scaleBase = yScale.getBasePixel();\n\t\t\tvar rectangleElementOptions = me.chart.options.elements.rectangle;\n\t\t\tvar custom = rectangle.custom || {};\n\t\t\tvar dataset = me.getDataset();\n\n\t\t\trectangle._xScale = xScale;\n\t\t\trectangle._yScale = yScale;\n\t\t\trectangle._datasetIndex = me.index;\n\t\t\trectangle._index = index;\n\n\t\t\tvar ruler = me.getRuler(index); // The index argument for compatible\n\t\t\trectangle._model = {\n\t\t\t\tx: me.calculateBarX(index, me.index, ruler),\n\t\t\t\ty: reset ? scaleBase : me.calculateBarY(index, me.index),\n\n\t\t\t\t// Tooltip\n\t\t\t\tlabel: me.chart.data.labels[index],\n\t\t\t\tdatasetLabel: dataset.label,\n\n\t\t\t\t// Appearance\n\t\t\t\thorizontal: false,\n\t\t\t\tbase: reset ? scaleBase : me.calculateBarBase(me.index, index),\n\t\t\t\twidth: me.calculateBarWidth(ruler),\n\t\t\t\tbackgroundColor: custom.backgroundColor ? custom.backgroundColor : helpers.getValueAtIndexOrDefault(dataset.backgroundColor, index, rectangleElementOptions.backgroundColor),\n\t\t\t\tborderSkipped: custom.borderSkipped ? custom.borderSkipped : rectangleElementOptions.borderSkipped,\n\t\t\t\tborderColor: custom.borderColor ? custom.borderColor : helpers.getValueAtIndexOrDefault(dataset.borderColor, index, rectangleElementOptions.borderColor),\n\t\t\t\tborderWidth: custom.borderWidth ? custom.borderWidth : helpers.getValueAtIndexOrDefault(dataset.borderWidth, index, rectangleElementOptions.borderWidth)\n\t\t\t};\n\n\t\t\trectangle.pivot();\n\t\t},\n\n\t\tcalculateBarBase: function(datasetIndex, index) {\n\t\t\tvar me = this;\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar yScale = me.getScaleForId(meta.yAxisID);\n\t\t\tvar base = yScale.getBaseValue();\n\t\t\tvar original = base;\n\n\t\t\tif ((yScale.options.stacked === true) ||\n\t\t\t\t(yScale.options.stacked === undefined && meta.stack !== undefined)) {\n\t\t\t\tvar chart = me.chart;\n\t\t\t\tvar datasets = chart.data.datasets;\n\t\t\t\tvar value = Number(datasets[datasetIndex].data[index]);\n\n\t\t\t\tfor (var i = 0; i < datasetIndex; i++) {\n\t\t\t\t\tvar currentDs = datasets[i];\n\t\t\t\t\tvar currentDsMeta = chart.getDatasetMeta(i);\n\t\t\t\t\tif (currentDsMeta.bar && currentDsMeta.yAxisID === yScale.id && chart.isDatasetVisible(i) &&\n\t\t\t\t\t\tmeta.stack === currentDsMeta.stack) {\n\t\t\t\t\t\tvar currentVal = Number(currentDs.data[index]);\n\t\t\t\t\t\tbase += value < 0 ? Math.min(currentVal, original) : Math.max(currentVal, original);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn yScale.getPixelForValue(base);\n\t\t\t}\n\n\t\t\treturn yScale.getBasePixel();\n\t\t},\n\n\t\tgetRuler: function() {\n\t\t\tvar me = this;\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar xScale = me.getScaleForId(meta.xAxisID);\n\t\t\tvar stackCount = me.getStackCount();\n\n\t\t\tvar tickWidth = xScale.width / xScale.ticks.length;\r\n\t\t\tvar categoryWidth = tickWidth * xScale.options.categoryPercentage;\n\t\t\tvar categorySpacing = (tickWidth - (tickWidth * xScale.options.categoryPercentage)) / 2;\n\t\t\tvar fullBarWidth = categoryWidth / stackCount;\n\n\t\t\tvar barWidth = fullBarWidth * xScale.options.barPercentage;\n\t\t\tvar barSpacing = fullBarWidth - (fullBarWidth * xScale.options.barPercentage);\n\n\t\t\treturn {\n\t\t\t\tstackCount: stackCount,\n\t\t\t\ttickWidth: tickWidth,\n\t\t\t\tcategoryWidth: categoryWidth,\n\t\t\t\tcategorySpacing: categorySpacing,\n\t\t\t\tfullBarWidth: fullBarWidth,\n\t\t\t\tbarWidth: barWidth,\n\t\t\t\tbarSpacing: barSpacing\n\t\t\t};\n\t\t},\n\n\t\tcalculateBarWidth: function(ruler) {\n\t\t\tvar me = this;\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar xScale = me.getScaleForId(meta.xAxisID);\n\t\t\tif (xScale.options.barThickness) {\n\t\t\t\treturn xScale.options.barThickness;\n\t\t\t}\n\t\t\treturn ruler.barWidth;\r\n\t\t},\n\n\t\t// Get stack index from the given dataset index accounting for stacks and the fact that not all bars are visible\n\t\tgetStackIndex: function(datasetIndex) {\n\t\t\tvar me = this;\n\t\t\tvar meta = me.chart.getDatasetMeta(datasetIndex);\n\t\t\tvar yScale = me.getScaleForId(meta.yAxisID);\n\t\t\tvar dsMeta, j;\n\t\t\tvar stacks = [meta.stack];\n\n\t\t\tfor (j = 0; j < datasetIndex; ++j) {\n\t\t\t\tdsMeta = this.chart.getDatasetMeta(j);\n\t\t\t\tif (dsMeta.bar && this.chart.isDatasetVisible(j) &&\n\t\t\t\t\t(yScale.options.stacked === false ||\n\t\t\t\t\t(yScale.options.stacked === true && stacks.indexOf(dsMeta.stack) === -1) ||\n\t\t\t\t\t(yScale.options.stacked === undefined && (dsMeta.stack === undefined || stacks.indexOf(dsMeta.stack) === -1)))) {\n\t\t\t\t\tstacks.push(dsMeta.stack);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn stacks.length - 1;\n\t\t},\n\n\t\tcalculateBarX: function(index, datasetIndex, ruler) {\n\t\t\tvar me = this;\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar xScale = me.getScaleForId(meta.xAxisID);\n\t\t\tvar stackIndex = me.getStackIndex(datasetIndex);\n\t\t\tvar leftTick = xScale.getPixelForValue(null, index, datasetIndex, me.chart.isCombo);\n\t\t\tleftTick -= me.chart.isCombo ? (ruler.tickWidth / 2) : 0;\n\n\t\t\treturn leftTick +\n\t\t\t\t(ruler.barWidth / 2) +\n\t\t\t\truler.categorySpacing +\n\t\t\t\t(ruler.barWidth * stackIndex) +\n\t\t\t\t(ruler.barSpacing / 2) +\n\t\t\t\t(ruler.barSpacing * stackIndex);\n\t\t},\n\n\t\tcalculateBarY: function(index, datasetIndex) {\n\t\t\tvar me = this;\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar yScale = me.getScaleForId(meta.yAxisID);\n\t\t\tvar value = Number(me.getDataset().data[index]);\n\n\t\t\tif (yScale.options.stacked ||\n\t\t\t\t(yScale.options.stacked === undefined && meta.stack !== undefined)) {\n\t\t\t\tvar base = yScale.getBaseValue();\n\t\t\t\tvar sumPos = base,\n\t\t\t\t\tsumNeg = base;\r\n\n\t\t\t\tfor (var i = 0; i < datasetIndex; i++) {\n\t\t\t\t\tvar ds = me.chart.data.datasets[i];\n\t\t\t\t\tvar dsMeta = me.chart.getDatasetMeta(i);\n\t\t\t\t\tif (dsMeta.bar && dsMeta.yAxisID === yScale.id && me.chart.isDatasetVisible(i) &&\n\t\t\t\t\t\tmeta.stack === dsMeta.stack) {\n\t\t\t\t\t\tvar stackedVal = Number(ds.data[index]);\n\t\t\t\t\t\tif (stackedVal < 0) {\n\t\t\t\t\t\t\tsumNeg += stackedVal || 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tsumPos += stackedVal || 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (value < 0) {\n\t\t\t\t\treturn yScale.getPixelForValue(sumNeg + value);\n\t\t\t\t}\n\t\t\t\treturn yScale.getPixelForValue(sumPos + value);\n\t\t\t}\n\n\t\t\treturn yScale.getPixelForValue(value);\n\t\t},\n\n\t\tdraw: function(ease) {\n\t\t\tvar me = this;\n\t\t\tvar easingDecimal = ease || 1;\n\t\t\tvar metaData = me.getMeta().data;\n\t\t\tvar dataset = me.getDataset();\n\t\t\tvar i, len;\n\n\t\t\tChart.canvasHelpers.clipArea(me.chart.chart.ctx, me.chart.chartArea);\n\t\t\tfor (i = 0, len = metaData.length; i < len; ++i) {\n\t\t\t\tvar d = dataset.data[i];\n\t\t\t\tif (d !== null && d !== undefined && !isNaN(d)) {\n\t\t\t\t\tmetaData[i].transition(easingDecimal).draw();\n\t\t\t\t}\n\t\t\t}\n\t\t\tChart.canvasHelpers.unclipArea(me.chart.chart.ctx);\n\t\t},\n\n\t\tsetHoverStyle: function(rectangle) {\n\t\t\tvar dataset = this.chart.data.datasets[rectangle._datasetIndex];\n\t\t\tvar index = rectangle._index;\n\n\t\t\tvar custom = rectangle.custom || {};\n\t\t\tvar model = rectangle._model;\n\t\t\tmodel.backgroundColor = custom.hoverBackgroundColor ? custom.hoverBackgroundColor : helpers.getValueAtIndexOrDefault(dataset.hoverBackgroundColor, index, helpers.getHoverColor(model.backgroundColor));\n\t\t\tmodel.borderColor = custom.hoverBorderColor ? custom.hoverBorderColor : helpers.getValueAtIndexOrDefault(dataset.hoverBorderColor, index, helpers.getHoverColor(model.borderColor));\n\t\t\tmodel.borderWidth = custom.hoverBorderWidth ? custom.hoverBorderWidth : helpers.getValueAtIndexOrDefault(dataset.hoverBorderWidth, index, model.borderWidth);\n\t\t},\n\n\t\tremoveHoverStyle: function(rectangle) {\n\t\t\tvar dataset = this.chart.data.datasets[rectangle._datasetIndex];\n\t\t\tvar index = rectangle._index;\n\t\t\tvar custom = rectangle.custom || {};\n\t\t\tvar model = rectangle._model;\n\t\t\tvar rectangleElementOptions = this.chart.options.elements.rectangle;\n\n\t\t\tmodel.backgroundColor = custom.backgroundColor ? custom.backgroundColor : helpers.getValueAtIndexOrDefault(dataset.backgroundColor, index, rectangleElementOptions.backgroundColor);\n\t\t\tmodel.borderColor = custom.borderColor ? custom.borderColor : helpers.getValueAtIndexOrDefault(dataset.borderColor, index, rectangleElementOptions.borderColor);\n\t\t\tmodel.borderWidth = custom.borderWidth ? custom.borderWidth : helpers.getValueAtIndexOrDefault(dataset.borderWidth, index, rectangleElementOptions.borderWidth);\n\t\t}\n\n\t});\n\n\n\t// including horizontalBar in the bar file, instead of a file of its own\n\t// it extends bar (like pie extends doughnut)\n\tChart.defaults.horizontalBar = {\n\t\thover: {\n\t\t\tmode: 'label'\n\t\t},\n\n\t\tscales: {\n\t\t\txAxes: [{\n\t\t\t\ttype: 'linear',\n\t\t\t\tposition: 'bottom'\n\t\t\t}],\n\t\t\tyAxes: [{\n\t\t\t\tposition: 'left',\n\t\t\t\ttype: 'category',\n\n\t\t\t\t// Specific to Horizontal Bar Controller\n\t\t\t\tcategoryPercentage: 0.8,\n\t\t\t\tbarPercentage: 0.9,\n\n\t\t\t\t// grid line settings\n\t\t\t\tgridLines: {\n\t\t\t\t\toffsetGridLines: true\n\t\t\t\t}\n\t\t\t}]\n\t\t},\n\t\telements: {\n\t\t\trectangle: {\n\t\t\t\tborderSkipped: 'left'\n\t\t\t}\n\t\t},\n\t\ttooltips: {\n\t\t\tcallbacks: {\n\t\t\t\ttitle: function(tooltipItems, data) {\n\t\t\t\t\t// Pick first xLabel for now\n\t\t\t\t\tvar title = '';\n\n\t\t\t\t\tif (tooltipItems.length > 0) {\n\t\t\t\t\t\tif (tooltipItems[0].yLabel) {\n\t\t\t\t\t\t\ttitle = tooltipItems[0].yLabel;\n\t\t\t\t\t\t} else if (data.labels.length > 0 && tooltipItems[0].index < data.labels.length) {\n\t\t\t\t\t\t\ttitle = data.labels[tooltipItems[0].index];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn title;\n\t\t\t\t},\n\t\t\t\tlabel: function(tooltipItem, data) {\n\t\t\t\t\tvar datasetLabel = data.datasets[tooltipItem.datasetIndex].label || '';\n\t\t\t\t\treturn datasetLabel + ': ' + tooltipItem.xLabel;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\tChart.controllers.horizontalBar = Chart.controllers.bar.extend({\n\n\t\t// Correctly calculate the bar width accounting for stacks and the fact that not all bars are visible\n\t\tgetStackCount: function() {\n\t\t\tvar me = this;\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar xScale = me.getScaleForId(meta.xAxisID);\n\n\t\t\tvar stacks = [];\n\t\t\thelpers.each(me.chart.data.datasets, function(dataset, datasetIndex) {\n\t\t\t\tvar dsMeta = me.chart.getDatasetMeta(datasetIndex);\n\t\t\t\tif (dsMeta.bar && me.chart.isDatasetVisible(datasetIndex) &&\n\t\t\t\t\t(xScale.options.stacked === false ||\n\t\t\t\t\t(xScale.options.stacked === true && stacks.indexOf(dsMeta.stack) === -1) ||\n\t\t\t\t\t(xScale.options.stacked === undefined && (dsMeta.stack === undefined || stacks.indexOf(dsMeta.stack) === -1)))) {\n\t\t\t\t\tstacks.push(dsMeta.stack);\n\t\t\t\t}\n\t\t\t}, me);\n\n\t\t\treturn stacks.length;\n\t\t},\n\n\t\tupdateElement: function(rectangle, index, reset) {\n\t\t\tvar me = this;\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar xScale = me.getScaleForId(meta.xAxisID);\n\t\t\tvar yScale = me.getScaleForId(meta.yAxisID);\n\t\t\tvar scaleBase = xScale.getBasePixel();\n\t\t\tvar custom = rectangle.custom || {};\n\t\t\tvar dataset = me.getDataset();\n\t\t\tvar rectangleElementOptions = me.chart.options.elements.rectangle;\n\n\t\t\trectangle._xScale = xScale;\n\t\t\trectangle._yScale = yScale;\n\t\t\trectangle._datasetIndex = me.index;\n\t\t\trectangle._index = index;\n\n\t\t\tvar ruler = me.getRuler(index); // The index argument for compatible\n\t\t\trectangle._model = {\n\t\t\t\tx: reset ? scaleBase : me.calculateBarX(index, me.index),\n\t\t\t\ty: me.calculateBarY(index, me.index, ruler),\n\n\t\t\t\t// Tooltip\n\t\t\t\tlabel: me.chart.data.labels[index],\n\t\t\t\tdatasetLabel: dataset.label,\n\n\t\t\t\t// Appearance\n\t\t\t\thorizontal: true,\n\t\t\t\tbase: reset ? scaleBase : me.calculateBarBase(me.index, index),\n\t\t\t\theight: me.calculateBarHeight(ruler),\n\t\t\t\tbackgroundColor: custom.backgroundColor ? custom.backgroundColor : helpers.getValueAtIndexOrDefault(dataset.backgroundColor, index, rectangleElementOptions.backgroundColor),\n\t\t\t\tborderSkipped: custom.borderSkipped ? custom.borderSkipped : rectangleElementOptions.borderSkipped,\n\t\t\t\tborderColor: custom.borderColor ? custom.borderColor : helpers.getValueAtIndexOrDefault(dataset.borderColor, index, rectangleElementOptions.borderColor),\n\t\t\t\tborderWidth: custom.borderWidth ? custom.borderWidth : helpers.getValueAtIndexOrDefault(dataset.borderWidth, index, rectangleElementOptions.borderWidth)\n\t\t\t};\n\n\t\t\trectangle.pivot();\n\t\t},\n\n\t\tcalculateBarBase: function(datasetIndex, index) {\n\t\t\tvar me = this;\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar xScale = me.getScaleForId(meta.xAxisID);\n\t\t\tvar base = xScale.getBaseValue();\n\t\t\tvar originalBase = base;\n\n\t\t\tif (xScale.options.stacked ||\n\t\t\t\t(xScale.options.stacked === undefined && meta.stack !== undefined)) {\n\t\t\t\tvar chart = me.chart;\n\t\t\t\tvar datasets = chart.data.datasets;\n\t\t\t\tvar value = Number(datasets[datasetIndex].data[index]);\n\n\t\t\t\tfor (var i = 0; i < datasetIndex; i++) {\n\t\t\t\t\tvar currentDs = datasets[i];\n\t\t\t\t\tvar currentDsMeta = chart.getDatasetMeta(i);\n\t\t\t\t\tif (currentDsMeta.bar && currentDsMeta.xAxisID === xScale.id && chart.isDatasetVisible(i) &&\n\t\t\t\t\t\tmeta.stack === currentDsMeta.stack) {\n\t\t\t\t\t\tvar currentVal = Number(currentDs.data[index]);\n\t\t\t\t\t\tbase += value < 0 ? Math.min(currentVal, originalBase) : Math.max(currentVal, originalBase);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn xScale.getPixelForValue(base);\n\t\t\t}\n\n\t\t\treturn xScale.getBasePixel();\n\t\t},\n\n\t\tgetRuler: function() {\n\t\t\tvar me = this;\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar yScale = me.getScaleForId(meta.yAxisID);\n\t\t\tvar stackCount = me.getStackCount();\n\n\t\t\tvar tickHeight = yScale.height / yScale.ticks.length;\n\t\t\tvar categoryHeight = tickHeight * yScale.options.categoryPercentage;\n\t\t\tvar categorySpacing = (tickHeight - (tickHeight * yScale.options.categoryPercentage)) / 2;\n\t\t\tvar fullBarHeight = categoryHeight / stackCount;\n\n\t\t\tvar barHeight = fullBarHeight * yScale.options.barPercentage;\n\t\t\tvar barSpacing = fullBarHeight - (fullBarHeight * yScale.options.barPercentage);\n\n\t\t\treturn {\n\t\t\t\tstackCount: stackCount,\n\t\t\t\ttickHeight: tickHeight,\n\t\t\t\tcategoryHeight: categoryHeight,\n\t\t\t\tcategorySpacing: categorySpacing,\n\t\t\t\tfullBarHeight: fullBarHeight,\n\t\t\t\tbarHeight: barHeight,\n\t\t\t\tbarSpacing: barSpacing\n\t\t\t};\n\t\t},\n\n\t\tcalculateBarHeight: function(ruler) {\n\t\t\tvar me = this;\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar yScale = me.getScaleForId(meta.yAxisID);\n\t\t\tif (yScale.options.barThickness) {\n\t\t\t\treturn yScale.options.barThickness;\n\t\t\t}\n\t\t\treturn ruler.barHeight;\n\t\t},\n\n\t\t// Get stack index from the given dataset index accounting for stacks and the fact that not all bars are visible\n\t\tgetStackIndex: function(datasetIndex) {\n\t\t\tvar me = this;\n\t\t\tvar meta = me.chart.getDatasetMeta(datasetIndex);\n\t\t\tvar xScale = me.getScaleForId(meta.xAxisID);\n\t\t\tvar dsMeta, j;\n\t\t\tvar stacks = [meta.stack];\n\n\t\t\tfor (j = 0; j < datasetIndex; ++j) {\n\t\t\t\tdsMeta = this.chart.getDatasetMeta(j);\n\t\t\t\tif (dsMeta.bar && this.chart.isDatasetVisible(j) &&\n\t\t\t\t\t(xScale.options.stacked === false ||\n\t\t\t\t\t(xScale.options.stacked === true && stacks.indexOf(dsMeta.stack) === -1) ||\n\t\t\t\t\t(xScale.options.stacked === undefined && (dsMeta.stack === undefined || stacks.indexOf(dsMeta.stack) === -1)))) {\n\t\t\t\t\tstacks.push(dsMeta.stack);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn stacks.length - 1;\r\n\t\t},\n\n\t\tcalculateBarX: function(index, datasetIndex) {\n\t\t\tvar me = this;\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar xScale = me.getScaleForId(meta.xAxisID);\n\t\t\tvar value = Number(me.getDataset().data[index]);\n\n\t\t\tif (xScale.options.stacked ||\n\t\t\t\t(xScale.options.stacked === undefined && meta.stack !== undefined)) {\n\t\t\t\tvar base = xScale.getBaseValue();\n\t\t\t\tvar sumPos = base,\n\t\t\t\t\tsumNeg = base;\r\n\n\t\t\t\tfor (var i = 0; i < datasetIndex; i++) {\n\t\t\t\t\tvar ds = me.chart.data.datasets[i];\n\t\t\t\t\tvar dsMeta = me.chart.getDatasetMeta(i);\n\t\t\t\t\tif (dsMeta.bar && dsMeta.xAxisID === xScale.id && me.chart.isDatasetVisible(i) &&\n\t\t\t\t\t\tmeta.stack === dsMeta.stack) {\n\t\t\t\t\t\tvar stackedVal = Number(ds.data[index]);\n\t\t\t\t\t\tif (stackedVal < 0) {\n\t\t\t\t\t\t\tsumNeg += stackedVal || 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tsumPos += stackedVal || 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (value < 0) {\n\t\t\t\t\treturn xScale.getPixelForValue(sumNeg + value);\n\t\t\t\t}\n\t\t\t\treturn xScale.getPixelForValue(sumPos + value);\n\t\t\t}\n\n\t\t\treturn xScale.getPixelForValue(value);\n\t\t},\n\n\t\tcalculateBarY: function(index, datasetIndex, ruler) {\n\t\t\tvar me = this;\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar yScale = me.getScaleForId(meta.yAxisID);\n\t\t\tvar stackIndex = me.getStackIndex(datasetIndex);\n\t\t\tvar topTick = yScale.getPixelForValue(null, index, datasetIndex, me.chart.isCombo);\n\t\t\ttopTick -= me.chart.isCombo ? (ruler.tickHeight / 2) : 0;\n\n\t\t\treturn topTick +\n\t\t\t\t(ruler.barHeight / 2) +\n\t\t\t\truler.categorySpacing +\n\t\t\t\t(ruler.barHeight * stackIndex) +\n\t\t\t\t(ruler.barSpacing / 2) +\n\t\t\t\t(ruler.barSpacing * stackIndex);\n\t\t}\n\t});\n};\n\n},{}],16:[function(require,module,exports){\n'use strict';\n\nmodule.exports = function(Chart) {\n\n\tvar helpers = Chart.helpers;\n\n\tChart.defaults.bubble = {\n\t\thover: {\n\t\t\tmode: 'single'\n\t\t},\n\n\t\tscales: {\n\t\t\txAxes: [{\n\t\t\t\ttype: 'linear', // bubble should probably use a linear scale by default\n\t\t\t\tposition: 'bottom',\n\t\t\t\tid: 'x-axis-0' // need an ID so datasets can reference the scale\n\t\t\t}],\n\t\t\tyAxes: [{\n\t\t\t\ttype: 'linear',\n\t\t\t\tposition: 'left',\n\t\t\t\tid: 'y-axis-0'\n\t\t\t}]\n\t\t},\n\n\t\ttooltips: {\n\t\t\tcallbacks: {\n\t\t\t\ttitle: function() {\n\t\t\t\t\t// Title doesn't make sense for scatter since we format the data as a point\n\t\t\t\t\treturn '';\n\t\t\t\t},\n\t\t\t\tlabel: function(tooltipItem, data) {\n\t\t\t\t\tvar datasetLabel = data.datasets[tooltipItem.datasetIndex].label || '';\n\t\t\t\t\tvar dataPoint = data.datasets[tooltipItem.datasetIndex].data[tooltipItem.index];\n\t\t\t\t\treturn datasetLabel + ': (' + tooltipItem.xLabel + ', ' + tooltipItem.yLabel + ', ' + dataPoint.r + ')';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\tChart.controllers.bubble = Chart.DatasetController.extend({\n\n\t\tdataElementType: Chart.elements.Point,\n\n\t\tupdate: function(reset) {\n\t\t\tvar me = this;\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar points = meta.data;\n\n\t\t\t// Update Points\n\t\t\thelpers.each(points, function(point, index) {\n\t\t\t\tme.updateElement(point, index, reset);\n\t\t\t});\n\t\t},\n\n\t\tupdateElement: function(point, index, reset) {\n\t\t\tvar me = this;\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar xScale = me.getScaleForId(meta.xAxisID);\n\t\t\tvar yScale = me.getScaleForId(meta.yAxisID);\n\n\t\t\tvar custom = point.custom || {};\n\t\t\tvar dataset = me.getDataset();\n\t\t\tvar data = dataset.data[index];\n\t\t\tvar pointElementOptions = me.chart.options.elements.point;\n\t\t\tvar dsIndex = me.index;\n\n\t\t\thelpers.extend(point, {\n\t\t\t\t// Utility\n\t\t\t\t_xScale: xScale,\n\t\t\t\t_yScale: yScale,\n\t\t\t\t_datasetIndex: dsIndex,\n\t\t\t\t_index: index,\n\n\t\t\t\t// Desired view properties\n\t\t\t\t_model: {\n\t\t\t\t\tx: reset ? xScale.getPixelForDecimal(0.5) : xScale.getPixelForValue(typeof data === 'object' ? data : NaN, index, dsIndex, me.chart.isCombo),\n\t\t\t\t\ty: reset ? yScale.getBasePixel() : yScale.getPixelForValue(data, index, dsIndex),\n\t\t\t\t\t// Appearance\n\t\t\t\t\tradius: reset ? 0 : custom.radius ? custom.radius : me.getRadius(data),\n\n\t\t\t\t\t// Tooltip\n\t\t\t\t\thitRadius: custom.hitRadius ? custom.hitRadius : helpers.getValueAtIndexOrDefault(dataset.hitRadius, index, pointElementOptions.hitRadius)\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// Trick to reset the styles of the point\n\t\t\tChart.DatasetController.prototype.removeHoverStyle.call(me, point, pointElementOptions);\n\n\t\t\tvar model = point._model;\n\t\t\tmodel.skip = custom.skip ? custom.skip : (isNaN(model.x) || isNaN(model.y));\n\n\t\t\tpoint.pivot();\n\t\t},\n\n\t\tgetRadius: function(value) {\n\t\t\treturn value.r || this.chart.options.elements.point.radius;\n\t\t},\n\n\t\tsetHoverStyle: function(point) {\n\t\t\tvar me = this;\n\t\t\tChart.DatasetController.prototype.setHoverStyle.call(me, point);\n\n\t\t\t// Radius\n\t\t\tvar dataset = me.chart.data.datasets[point._datasetIndex];\n\t\t\tvar index = point._index;\n\t\t\tvar custom = point.custom || {};\n\t\t\tvar model = point._model;\n\t\t\tmodel.radius = custom.hoverRadius ? custom.hoverRadius : (helpers.getValueAtIndexOrDefault(dataset.hoverRadius, index, me.chart.options.elements.point.hoverRadius)) + me.getRadius(dataset.data[index]);\n\t\t},\n\n\t\tremoveHoverStyle: function(point) {\n\t\t\tvar me = this;\n\t\t\tChart.DatasetController.prototype.removeHoverStyle.call(me, point, me.chart.options.elements.point);\n\n\t\t\tvar dataVal = me.chart.data.datasets[point._datasetIndex].data[point._index];\n\t\t\tvar custom = point.custom || {};\n\t\t\tvar model = point._model;\n\n\t\t\tmodel.radius = custom.radius ? custom.radius : me.getRadius(dataVal);\n\t\t}\n\t});\n};\n\n},{}],17:[function(require,module,exports){\n'use strict';\n\nmodule.exports = function(Chart) {\n\n\tvar helpers = Chart.helpers,\n\t\tdefaults = Chart.defaults;\n\n\tdefaults.doughnut = {\n\t\tanimation: {\n\t\t\t// Boolean - Whether we animate the rotation of the Doughnut\n\t\t\tanimateRotate: true,\n\t\t\t// Boolean - Whether we animate scaling the Doughnut from the centre\n\t\t\tanimateScale: false\n\t\t},\n\t\taspectRatio: 1,\n\t\thover: {\n\t\t\tmode: 'single'\n\t\t},\n\t\tlegendCallback: function(chart) {\n\t\t\tvar text = [];\n\t\t\ttext.push('<ul class=\"' + chart.id + '-legend\">');\n\n\t\t\tvar data = chart.data;\n\t\t\tvar datasets = data.datasets;\n\t\t\tvar labels = data.labels;\n\n\t\t\tif (datasets.length) {\n\t\t\t\tfor (var i = 0; i < datasets[0].data.length; ++i) {\n\t\t\t\t\ttext.push('<li><span style=\"background-color:' + datasets[0].backgroundColor[i] + '\"></span>');\n\t\t\t\t\tif (labels[i]) {\n\t\t\t\t\t\ttext.push(labels[i]);\n\t\t\t\t\t}\n\t\t\t\t\ttext.push('</li>');\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttext.push('</ul>');\n\t\t\treturn text.join('');\n\t\t},\n\t\tlegend: {\n\t\t\tlabels: {\n\t\t\t\tgenerateLabels: function(chart) {\n\t\t\t\t\tvar data = chart.data;\n\t\t\t\t\tif (data.labels.length && data.datasets.length) {\n\t\t\t\t\t\treturn data.labels.map(function(label, i) {\n\t\t\t\t\t\t\tvar meta = chart.getDatasetMeta(0);\n\t\t\t\t\t\t\tvar ds = data.datasets[0];\n\t\t\t\t\t\t\tvar arc = meta.data[i];\n\t\t\t\t\t\t\tvar custom = arc && arc.custom || {};\n\t\t\t\t\t\t\tvar getValueAtIndexOrDefault = helpers.getValueAtIndexOrDefault;\n\t\t\t\t\t\t\tvar arcOpts = chart.options.elements.arc;\n\t\t\t\t\t\t\tvar fill = custom.backgroundColor ? custom.backgroundColor : getValueAtIndexOrDefault(ds.backgroundColor, i, arcOpts.backgroundColor);\n\t\t\t\t\t\t\tvar stroke = custom.borderColor ? custom.borderColor : getValueAtIndexOrDefault(ds.borderColor, i, arcOpts.borderColor);\n\t\t\t\t\t\t\tvar bw = custom.borderWidth ? custom.borderWidth : getValueAtIndexOrDefault(ds.borderWidth, i, arcOpts.borderWidth);\n\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\ttext: label,\n\t\t\t\t\t\t\t\tfillStyle: fill,\n\t\t\t\t\t\t\t\tstrokeStyle: stroke,\n\t\t\t\t\t\t\t\tlineWidth: bw,\n\t\t\t\t\t\t\t\thidden: isNaN(ds.data[i]) || meta.data[i].hidden,\n\n\t\t\t\t\t\t\t\t// Extra data used for toggling the correct item\n\t\t\t\t\t\t\t\tindex: i\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\treturn [];\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tonClick: function(e, legendItem) {\n\t\t\t\tvar index = legendItem.index;\n\t\t\t\tvar chart = this.chart;\n\t\t\t\tvar i, ilen, meta;\n\n\t\t\t\tfor (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {\n\t\t\t\t\tmeta = chart.getDatasetMeta(i);\n\t\t\t\t\t// toggle visibility of index if exists\n\t\t\t\t\tif (meta.data[index]) {\n\t\t\t\t\t\tmeta.data[index].hidden = !meta.data[index].hidden;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tchart.update();\n\t\t\t}\n\t\t},\n\n\t\t// The percentage of the chart that we cut out of the middle.\n\t\tcutoutPercentage: 50,\n\n\t\t// The rotation of the chart, where the first data arc begins.\n\t\trotation: Math.PI * -0.5,\n\n\t\t// The total circumference of the chart.\n\t\tcircumference: Math.PI * 2.0,\n\n\t\t// Need to override these to give a nice default\n\t\ttooltips: {\n\t\t\tcallbacks: {\n\t\t\t\ttitle: function() {\n\t\t\t\t\treturn '';\n\t\t\t\t},\n\t\t\t\tlabel: function(tooltipItem, data) {\n\t\t\t\t\tvar dataLabel = data.labels[tooltipItem.index];\n\t\t\t\t\tvar value = ': ' + data.datasets[tooltipItem.datasetIndex].data[tooltipItem.index];\n\n\t\t\t\t\tif (helpers.isArray(dataLabel)) {\n\t\t\t\t\t\t// show value on first line of multiline label\n\t\t\t\t\t\t// need to clone because we are changing the value\n\t\t\t\t\t\tdataLabel = dataLabel.slice();\n\t\t\t\t\t\tdataLabel[0] += value;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdataLabel += value;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn dataLabel;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\tdefaults.pie = helpers.clone(defaults.doughnut);\n\thelpers.extend(defaults.pie, {\n\t\tcutoutPercentage: 0\n\t});\n\n\n\tChart.controllers.doughnut = Chart.controllers.pie = Chart.DatasetController.extend({\n\n\t\tdataElementType: Chart.elements.Arc,\n\n\t\tlinkScales: helpers.noop,\n\n\t\t// Get index of the dataset in relation to the visible datasets. This allows determining the inner and outer radius correctly\n\t\tgetRingIndex: function(datasetIndex) {\n\t\t\tvar ringIndex = 0;\n\n\t\t\tfor (var j = 0; j < datasetIndex; ++j) {\n\t\t\t\tif (this.chart.isDatasetVisible(j)) {\n\t\t\t\t\t++ringIndex;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn ringIndex;\n\t\t},\n\n\t\tupdate: function(reset) {\n\t\t\tvar me = this;\n\t\t\tvar chart = me.chart,\n\t\t\t\tchartArea = chart.chartArea,\n\t\t\t\topts = chart.options,\n\t\t\t\tarcOpts = opts.elements.arc,\n\t\t\t\tavailableWidth = chartArea.right - chartArea.left - arcOpts.borderWidth,\n\t\t\t\tavailableHeight = chartArea.bottom - chartArea.top - arcOpts.borderWidth,\n\t\t\t\tminSize = Math.min(availableWidth, availableHeight),\n\t\t\t\toffset = {\n\t\t\t\t\tx: 0,\n\t\t\t\t\ty: 0\n\t\t\t\t},\n\t\t\t\tmeta = me.getMeta(),\n\t\t\t\tcutoutPercentage = opts.cutoutPercentage,\n\t\t\t\tcircumference = opts.circumference;\n\n\t\t\t// If the chart's circumference isn't a full circle, calculate minSize as a ratio of the width/height of the arc\n\t\t\tif (circumference < Math.PI * 2.0) {\n\t\t\t\tvar startAngle = opts.rotation % (Math.PI * 2.0);\n\t\t\t\tstartAngle += Math.PI * 2.0 * (startAngle >= Math.PI ? -1 : startAngle < -Math.PI ? 1 : 0);\n\t\t\t\tvar endAngle = startAngle + circumference;\n\t\t\t\tvar start = {x: Math.cos(startAngle), y: Math.sin(startAngle)};\n\t\t\t\tvar end = {x: Math.cos(endAngle), y: Math.sin(endAngle)};\n\t\t\t\tvar contains0 = (startAngle <= 0 && 0 <= endAngle) || (startAngle <= Math.PI * 2.0 && Math.PI * 2.0 <= endAngle);\n\t\t\t\tvar contains90 = (startAngle <= Math.PI * 0.5 && Math.PI * 0.5 <= endAngle) || (startAngle <= Math.PI * 2.5 && Math.PI * 2.5 <= endAngle);\n\t\t\t\tvar contains180 = (startAngle <= -Math.PI && -Math.PI <= endAngle) || (startAngle <= Math.PI && Math.PI <= endAngle);\n\t\t\t\tvar contains270 = (startAngle <= -Math.PI * 0.5 && -Math.PI * 0.5 <= endAngle) || (startAngle <= Math.PI * 1.5 && Math.PI * 1.5 <= endAngle);\n\t\t\t\tvar cutout = cutoutPercentage / 100.0;\n\t\t\t\tvar min = {x: contains180 ? -1 : Math.min(start.x * (start.x < 0 ? 1 : cutout), end.x * (end.x < 0 ? 1 : cutout)), y: contains270 ? -1 : Math.min(start.y * (start.y < 0 ? 1 : cutout), end.y * (end.y < 0 ? 1 : cutout))};\n\t\t\t\tvar max = {x: contains0 ? 1 : Math.max(start.x * (start.x > 0 ? 1 : cutout), end.x * (end.x > 0 ? 1 : cutout)), y: contains90 ? 1 : Math.max(start.y * (start.y > 0 ? 1 : cutout), end.y * (end.y > 0 ? 1 : cutout))};\n\t\t\t\tvar size = {width: (max.x - min.x) * 0.5, height: (max.y - min.y) * 0.5};\n\t\t\t\tminSize = Math.min(availableWidth / size.width, availableHeight / size.height);\n\t\t\t\toffset = {x: (max.x + min.x) * -0.5, y: (max.y + min.y) * -0.5};\n\t\t\t}\n\n\t\t\tchart.borderWidth = me.getMaxBorderWidth(meta.data);\n\t\t\tchart.outerRadius = Math.max((minSize - chart.borderWidth) / 2, 0);\n\t\t\tchart.innerRadius = Math.max(cutoutPercentage ? (chart.outerRadius / 100) * (cutoutPercentage) : 0, 0);\n\t\t\tchart.radiusLength = (chart.outerRadius - chart.innerRadius) / chart.getVisibleDatasetCount();\n\t\t\tchart.offsetX = offset.x * chart.outerRadius;\n\t\t\tchart.offsetY = offset.y * chart.outerRadius;\n\n\t\t\tmeta.total = me.calculateTotal();\n\n\t\t\tme.outerRadius = chart.outerRadius - (chart.radiusLength * me.getRingIndex(me.index));\n\t\t\tme.innerRadius = Math.max(me.outerRadius - chart.radiusLength, 0);\n\n\t\t\thelpers.each(meta.data, function(arc, index) {\n\t\t\t\tme.updateElement(arc, index, reset);\n\t\t\t});\n\t\t},\n\n\t\tupdateElement: function(arc, index, reset) {\n\t\t\tvar me = this;\n\t\t\tvar chart = me.chart,\n\t\t\t\tchartArea = chart.chartArea,\n\t\t\t\topts = chart.options,\n\t\t\t\tanimationOpts = opts.animation,\n\t\t\t\tcenterX = (chartArea.left + chartArea.right) / 2,\n\t\t\t\tcenterY = (chartArea.top + chartArea.bottom) / 2,\n\t\t\t\tstartAngle = opts.rotation, // non reset case handled later\n\t\t\t\tendAngle = opts.rotation, // non reset case handled later\n\t\t\t\tdataset = me.getDataset(),\n\t\t\t\tcircumference = reset && animationOpts.animateRotate ? 0 : arc.hidden ? 0 : me.calculateCircumference(dataset.data[index]) * (opts.circumference / (2.0 * Math.PI)),\n\t\t\t\tinnerRadius = reset && animationOpts.animateScale ? 0 : me.innerRadius,\n\t\t\t\touterRadius = reset && animationOpts.animateScale ? 0 : me.outerRadius,\n\t\t\t\tvalueAtIndexOrDefault = helpers.getValueAtIndexOrDefault;\n\n\t\t\thelpers.extend(arc, {\n\t\t\t\t// Utility\n\t\t\t\t_datasetIndex: me.index,\n\t\t\t\t_index: index,\n\n\t\t\t\t// Desired view properties\n\t\t\t\t_model: {\n\t\t\t\t\tx: centerX + chart.offsetX,\n\t\t\t\t\ty: centerY + chart.offsetY,\n\t\t\t\t\tstartAngle: startAngle,\n\t\t\t\t\tendAngle: endAngle,\n\t\t\t\t\tcircumference: circumference,\n\t\t\t\t\touterRadius: outerRadius,\n\t\t\t\t\tinnerRadius: innerRadius,\n\t\t\t\t\tlabel: valueAtIndexOrDefault(dataset.label, index, chart.data.labels[index])\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tvar model = arc._model;\n\t\t\t// Resets the visual styles\n\t\t\tthis.removeHoverStyle(arc);\n\n\t\t\t// Set correct angles if not resetting\n\t\t\tif (!reset || !animationOpts.animateRotate) {\n\t\t\t\tif (index === 0) {\n\t\t\t\t\tmodel.startAngle = opts.rotation;\n\t\t\t\t} else {\n\t\t\t\t\tmodel.startAngle = me.getMeta().data[index - 1]._model.endAngle;\n\t\t\t\t}\n\n\t\t\t\tmodel.endAngle = model.startAngle + model.circumference;\n\t\t\t}\n\n\t\t\tarc.pivot();\n\t\t},\n\n\t\tremoveHoverStyle: function(arc) {\n\t\t\tChart.DatasetController.prototype.removeHoverStyle.call(this, arc, this.chart.options.elements.arc);\n\t\t},\n\n\t\tcalculateTotal: function() {\n\t\t\tvar dataset = this.getDataset();\n\t\t\tvar meta = this.getMeta();\n\t\t\tvar total = 0;\n\t\t\tvar value;\n\n\t\t\thelpers.each(meta.data, function(element, index) {\n\t\t\t\tvalue = dataset.data[index];\n\t\t\t\tif (!isNaN(value) && !element.hidden) {\n\t\t\t\t\ttotal += Math.abs(value);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t/* if (total === 0) {\n\t\t\t\ttotal = NaN;\n\t\t\t}*/\n\n\t\t\treturn total;\n\t\t},\n\n\t\tcalculateCircumference: function(value) {\n\t\t\tvar total = this.getMeta().total;\n\t\t\tif (total > 0 && !isNaN(value)) {\n\t\t\t\treturn (Math.PI * 2.0) * (value / total);\n\t\t\t}\n\t\t\treturn 0;\n\t\t},\n\n\t\t// gets the max border or hover width to properly scale pie charts\n\t\tgetMaxBorderWidth: function(elements) {\n\t\t\tvar max = 0,\n\t\t\t\tindex = this.index,\n\t\t\t\tlength = elements.length,\n\t\t\t\tborderWidth,\n\t\t\t\thoverWidth;\n\n\t\t\tfor (var i = 0; i < length; i++) {\n\t\t\t\tborderWidth = elements[i]._model ? elements[i]._model.borderWidth : 0;\n\t\t\t\thoverWidth = elements[i]._chart ? elements[i]._chart.config.data.datasets[index].hoverBorderWidth : 0;\n\n\t\t\t\tmax = borderWidth > max ? borderWidth : max;\n\t\t\t\tmax = hoverWidth > max ? hoverWidth : max;\n\t\t\t}\n\t\t\treturn max;\n\t\t}\n\t});\n};\n\n},{}],18:[function(require,module,exports){\n'use strict';\n\nmodule.exports = function(Chart) {\n\n\tvar helpers = Chart.helpers;\n\n\tChart.defaults.line = {\n\t\tshowLines: true,\n\t\tspanGaps: false,\n\n\t\thover: {\n\t\t\tmode: 'label'\n\t\t},\n\n\t\tscales: {\n\t\t\txAxes: [{\n\t\t\t\ttype: 'category',\n\t\t\t\tid: 'x-axis-0'\n\t\t\t}],\n\t\t\tyAxes: [{\n\t\t\t\ttype: 'linear',\n\t\t\t\tid: 'y-axis-0'\n\t\t\t}]\n\t\t}\n\t};\n\n\tfunction lineEnabled(dataset, options) {\n\t\treturn helpers.getValueOrDefault(dataset.showLine, options.showLines);\n\t}\n\n\tChart.controllers.line = Chart.DatasetController.extend({\n\n\t\tdatasetElementType: Chart.elements.Line,\n\n\t\tdataElementType: Chart.elements.Point,\n\n\t\tupdate: function(reset) {\n\t\t\tvar me = this;\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar line = meta.dataset;\n\t\t\tvar points = meta.data || [];\n\t\t\tvar options = me.chart.options;\n\t\t\tvar lineElementOptions = options.elements.line;\n\t\t\tvar scale = me.getScaleForId(meta.yAxisID);\n\t\t\tvar i, ilen, custom;\n\t\t\tvar dataset = me.getDataset();\n\t\t\tvar showLine = lineEnabled(dataset, options);\n\n\t\t\t// Update Line\n\t\t\tif (showLine) {\n\t\t\t\tcustom = line.custom || {};\n\n\t\t\t\t// Compatibility: If the properties are defined with only the old name, use those values\n\t\t\t\tif ((dataset.tension !== undefined) && (dataset.lineTension === undefined)) {\n\t\t\t\t\tdataset.lineTension = dataset.tension;\n\t\t\t\t}\n\n\t\t\t\t// Utility\n\t\t\t\tline._scale = scale;\n\t\t\t\tline._datasetIndex = me.index;\n\t\t\t\t// Data\n\t\t\t\tline._children = points;\n\t\t\t\t// Model\n\t\t\t\tline._model = {\n\t\t\t\t\t// Appearance\n\t\t\t\t\t// The default behavior of lines is to break at null values, according\n\t\t\t\t\t// to https://github.com/chartjs/Chart.js/issues/2435#issuecomment-216718158\n\t\t\t\t\t// This option gives lines the ability to span gaps\n\t\t\t\t\tspanGaps: dataset.spanGaps ? dataset.spanGaps : options.spanGaps,\n\t\t\t\t\ttension: custom.tension ? custom.tension : helpers.getValueOrDefault(dataset.lineTension, lineElementOptions.tension),\n\t\t\t\t\tbackgroundColor: custom.backgroundColor ? custom.backgroundColor : (dataset.backgroundColor || lineElementOptions.backgroundColor),\n\t\t\t\t\tborderWidth: custom.borderWidth ? custom.borderWidth : (dataset.borderWidth || lineElementOptions.borderWidth),\n\t\t\t\t\tborderColor: custom.borderColor ? custom.borderColor : (dataset.borderColor || lineElementOptions.borderColor),\n\t\t\t\t\tborderCapStyle: custom.borderCapStyle ? custom.borderCapStyle : (dataset.borderCapStyle || lineElementOptions.borderCapStyle),\n\t\t\t\t\tborderDash: custom.borderDash ? custom.borderDash : (dataset.borderDash || lineElementOptions.borderDash),\n\t\t\t\t\tborderDashOffset: custom.borderDashOffset ? custom.borderDashOffset : (dataset.borderDashOffset || lineElementOptions.borderDashOffset),\n\t\t\t\t\tborderJoinStyle: custom.borderJoinStyle ? custom.borderJoinStyle : (dataset.borderJoinStyle || lineElementOptions.borderJoinStyle),\n\t\t\t\t\tfill: custom.fill ? custom.fill : (dataset.fill !== undefined ? dataset.fill : lineElementOptions.fill),\n\t\t\t\t\tsteppedLine: custom.steppedLine ? custom.steppedLine : helpers.getValueOrDefault(dataset.steppedLine, lineElementOptions.stepped),\n\t\t\t\t\tcubicInterpolationMode: custom.cubicInterpolationMode ? custom.cubicInterpolationMode : helpers.getValueOrDefault(dataset.cubicInterpolationMode, lineElementOptions.cubicInterpolationMode),\n\t\t\t\t\t// Scale\n\t\t\t\t\tscaleTop: scale.top,\n\t\t\t\t\tscaleBottom: scale.bottom,\n\t\t\t\t\tscaleZero: scale.getBasePixel()\n\t\t\t\t};\n\n\t\t\t\tline.pivot();\n\t\t\t}\n\n\t\t\t// Update Points\n\t\t\tfor (i=0, ilen=points.length; i<ilen; ++i) {\n\t\t\t\tme.updateElement(points[i], i, reset);\n\t\t\t}\n\n\t\t\tif (showLine && line._model.tension !== 0) {\n\t\t\t\tme.updateBezierControlPoints();\n\t\t\t}\n\n\t\t\t// Now pivot the point for animation\n\t\t\tfor (i=0, ilen=points.length; i<ilen; ++i) {\n\t\t\t\tpoints[i].pivot();\n\t\t\t}\n\t\t},\n\n\t\tgetPointBackgroundColor: function(point, index) {\n\t\t\tvar backgroundColor = this.chart.options.elements.point.backgroundColor;\n\t\t\tvar dataset = this.getDataset();\n\t\t\tvar custom = point.custom || {};\n\n\t\t\tif (custom.backgroundColor) {\n\t\t\t\tbackgroundColor = custom.backgroundColor;\n\t\t\t} else if (dataset.pointBackgroundColor) {\n\t\t\t\tbackgroundColor = helpers.getValueAtIndexOrDefault(dataset.pointBackgroundColor, index, backgroundColor);\n\t\t\t} else if (dataset.backgroundColor) {\n\t\t\t\tbackgroundColor = dataset.backgroundColor;\n\t\t\t}\n\n\t\t\treturn backgroundColor;\n\t\t},\n\n\t\tgetPointBorderColor: function(point, index) {\n\t\t\tvar borderColor = this.chart.options.elements.point.borderColor;\n\t\t\tvar dataset = this.getDataset();\n\t\t\tvar custom = point.custom || {};\n\n\t\t\tif (custom.borderColor) {\n\t\t\t\tborderColor = custom.borderColor;\n\t\t\t} else if (dataset.pointBorderColor) {\n\t\t\t\tborderColor = helpers.getValueAtIndexOrDefault(dataset.pointBorderColor, index, borderColor);\n\t\t\t} else if (dataset.borderColor) {\n\t\t\t\tborderColor = dataset.borderColor;\n\t\t\t}\n\n\t\t\treturn borderColor;\n\t\t},\n\n\t\tgetPointBorderWidth: function(point, index) {\n\t\t\tvar borderWidth = this.chart.options.elements.point.borderWidth;\n\t\t\tvar dataset = this.getDataset();\n\t\t\tvar custom = point.custom || {};\n\n\t\t\tif (!isNaN(custom.borderWidth)) {\n\t\t\t\tborderWidth = custom.borderWidth;\n\t\t\t} else if (!isNaN(dataset.pointBorderWidth)) {\n\t\t\t\tborderWidth = helpers.getValueAtIndexOrDefault(dataset.pointBorderWidth, index, borderWidth);\n\t\t\t} else if (!isNaN(dataset.borderWidth)) {\n\t\t\t\tborderWidth = dataset.borderWidth;\n\t\t\t}\n\n\t\t\treturn borderWidth;\n\t\t},\n\n\t\tupdateElement: function(point, index, reset) {\n\t\t\tvar me = this;\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar custom = point.custom || {};\n\t\t\tvar dataset = me.getDataset();\n\t\t\tvar datasetIndex = me.index;\n\t\t\tvar value = dataset.data[index];\n\t\t\tvar yScale = me.getScaleForId(meta.yAxisID);\n\t\t\tvar xScale = me.getScaleForId(meta.xAxisID);\n\t\t\tvar pointOptions = me.chart.options.elements.point;\n\t\t\tvar x, y;\n\t\t\tvar labels = me.chart.data.labels || [];\n\t\t\tvar includeOffset = (labels.length === 1 || dataset.data.length === 1) || me.chart.isCombo;\n\n\t\t\t// Compatibility: If the properties are defined with only the old name, use those values\n\t\t\tif ((dataset.radius !== undefined) && (dataset.pointRadius === undefined)) {\n\t\t\t\tdataset.pointRadius = dataset.radius;\n\t\t\t}\n\t\t\tif ((dataset.hitRadius !== undefined) && (dataset.pointHitRadius === undefined)) {\n\t\t\t\tdataset.pointHitRadius = dataset.hitRadius;\n\t\t\t}\n\n\t\t\tx = xScale.getPixelForValue(typeof value === 'object' ? value : NaN, index, datasetIndex, includeOffset);\n\t\t\ty = reset ? yScale.getBasePixel() : me.calculatePointY(value, index, datasetIndex);\n\n\t\t\t// Utility\n\t\t\tpoint._xScale = xScale;\n\t\t\tpoint._yScale = yScale;\n\t\t\tpoint._datasetIndex = datasetIndex;\n\t\t\tpoint._index = index;\n\n\t\t\t// Desired view properties\n\t\t\tpoint._model = {\n\t\t\t\tx: x,\n\t\t\t\ty: y,\n\t\t\t\tskip: custom.skip || isNaN(x) || isNaN(y),\n\t\t\t\t// Appearance\n\t\t\t\tradius: custom.radius || helpers.getValueAtIndexOrDefault(dataset.pointRadius, index, pointOptions.radius),\n\t\t\t\tpointStyle: custom.pointStyle || helpers.getValueAtIndexOrDefault(dataset.pointStyle, index, pointOptions.pointStyle),\n\t\t\t\tbackgroundColor: me.getPointBackgroundColor(point, index),\n\t\t\t\tborderColor: me.getPointBorderColor(point, index),\n\t\t\t\tborderWidth: me.getPointBorderWidth(point, index),\n\t\t\t\ttension: meta.dataset._model ? meta.dataset._model.tension : 0,\n\t\t\t\tsteppedLine: meta.dataset._model ? meta.dataset._model.steppedLine : false,\n\t\t\t\t// Tooltip\n\t\t\t\thitRadius: custom.hitRadius || helpers.getValueAtIndexOrDefault(dataset.pointHitRadius, index, pointOptions.hitRadius)\n\t\t\t};\n\t\t},\n\n\t\tcalculatePointY: function(value, index, datasetIndex) {\n\t\t\tvar me = this;\n\t\t\tvar chart = me.chart;\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar yScale = me.getScaleForId(meta.yAxisID);\n\t\t\tvar sumPos = 0;\n\t\t\tvar sumNeg = 0;\n\t\t\tvar i, ds, dsMeta;\n\n\t\t\tif (yScale.options.stacked) {\n\t\t\t\tfor (i = 0; i < datasetIndex; i++) {\n\t\t\t\t\tds = chart.data.datasets[i];\n\t\t\t\t\tdsMeta = chart.getDatasetMeta(i);\n\t\t\t\t\tif (dsMeta.type === 'line' && dsMeta.yAxisID === yScale.id && chart.isDatasetVisible(i)) {\n\t\t\t\t\t\tvar stackedRightValue = Number(yScale.getRightValue(ds.data[index]));\n\t\t\t\t\t\tif (stackedRightValue < 0) {\n\t\t\t\t\t\t\tsumNeg += stackedRightValue || 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tsumPos += stackedRightValue || 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tvar rightValue = Number(yScale.getRightValue(value));\n\t\t\t\tif (rightValue < 0) {\n\t\t\t\t\treturn yScale.getPixelForValue(sumNeg + rightValue);\n\t\t\t\t}\n\t\t\t\treturn yScale.getPixelForValue(sumPos + rightValue);\n\t\t\t}\n\n\t\t\treturn yScale.getPixelForValue(value);\n\t\t},\n\n\t\tupdateBezierControlPoints: function() {\n\t\t\tvar me = this;\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar area = me.chart.chartArea;\n\t\t\tvar points = (meta.data || []);\n\t\t\tvar i, ilen, point, model, controlPoints;\n\n\t\t\t// Only consider points that are drawn in case the spanGaps option is used\n\t\t\tif (meta.dataset._model.spanGaps) {\n\t\t\t\tpoints = points.filter(function(pt) {\n\t\t\t\t\treturn !pt._model.skip;\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tfunction capControlPoint(pt, min, max) {\n\t\t\t\treturn Math.max(Math.min(pt, max), min);\n\t\t\t}\n\n\t\t\tif (meta.dataset._model.cubicInterpolationMode === 'monotone') {\n\t\t\t\thelpers.splineCurveMonotone(points);\n\t\t\t} else {\n\t\t\t\tfor (i = 0, ilen = points.length; i < ilen; ++i) {\n\t\t\t\t\tpoint = points[i];\n\t\t\t\t\tmodel = point._model;\n\t\t\t\t\tcontrolPoints = helpers.splineCurve(\n\t\t\t\t\t\thelpers.previousItem(points, i)._model,\n\t\t\t\t\t\tmodel,\n\t\t\t\t\t\thelpers.nextItem(points, i)._model,\n\t\t\t\t\t\tmeta.dataset._model.tension\n\t\t\t\t\t);\n\t\t\t\t\tmodel.controlPointPreviousX = controlPoints.previous.x;\n\t\t\t\t\tmodel.controlPointPreviousY = controlPoints.previous.y;\n\t\t\t\t\tmodel.controlPointNextX = controlPoints.next.x;\n\t\t\t\t\tmodel.controlPointNextY = controlPoints.next.y;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (me.chart.options.elements.line.capBezierPoints) {\n\t\t\t\tfor (i = 0, ilen = points.length; i < ilen; ++i) {\n\t\t\t\t\tmodel = points[i]._model;\n\t\t\t\t\tmodel.controlPointPreviousX = capControlPoint(model.controlPointPreviousX, area.left, area.right);\n\t\t\t\t\tmodel.controlPointPreviousY = capControlPoint(model.controlPointPreviousY, area.top, area.bottom);\n\t\t\t\t\tmodel.controlPointNextX = capControlPoint(model.controlPointNextX, area.left, area.right);\n\t\t\t\t\tmodel.controlPointNextY = capControlPoint(model.controlPointNextY, area.top, area.bottom);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tdraw: function(ease) {\n\t\t\tvar me = this;\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar points = meta.data || [];\n\t\t\tvar easingDecimal = ease || 1;\n\t\t\tvar i, ilen;\n\n\t\t\t// Transition Point Locations\n\t\t\tfor (i=0, ilen=points.length; i<ilen; ++i) {\n\t\t\t\tpoints[i].transition(easingDecimal);\n\t\t\t}\n\n\t\t\tChart.canvasHelpers.clipArea(me.chart.chart.ctx, me.chart.chartArea);\n\t\t\t// Transition and Draw the line\n\t\t\tif (lineEnabled(me.getDataset(), me.chart.options)) {\n\t\t\t\tmeta.dataset.transition(easingDecimal).draw();\n\t\t\t}\n\t\t\tChart.canvasHelpers.unclipArea(me.chart.chart.ctx);\n\n\t\t\t// Draw the points\n\t\t\tfor (i=0, ilen=points.length; i<ilen; ++i) {\n\t\t\t\tpoints[i].draw(me.chart.chartArea);\n\t\t\t}\n\t\t},\n\n\t\tsetHoverStyle: function(point) {\n\t\t\t// Point\n\t\t\tvar dataset = this.chart.data.datasets[point._datasetIndex];\n\t\t\tvar index = point._index;\n\t\t\tvar custom = point.custom || {};\n\t\t\tvar model = point._model;\n\n\t\t\tmodel.radius = custom.hoverRadius || helpers.getValueAtIndexOrDefault(dataset.pointHoverRadius, index, this.chart.options.elements.point.hoverRadius);\n\t\t\tmodel.backgroundColor = custom.hoverBackgroundColor || helpers.getValueAtIndexOrDefault(dataset.pointHoverBackgroundColor, index, helpers.getHoverColor(model.backgroundColor));\n\t\t\tmodel.borderColor = custom.hoverBorderColor || helpers.getValueAtIndexOrDefault(dataset.pointHoverBorderColor, index, helpers.getHoverColor(model.borderColor));\n\t\t\tmodel.borderWidth = custom.hoverBorderWidth || helpers.getValueAtIndexOrDefault(dataset.pointHoverBorderWidth, index, model.borderWidth);\n\t\t},\n\n\t\tremoveHoverStyle: function(point) {\n\t\t\tvar me = this;\n\t\t\tvar dataset = me.chart.data.datasets[point._datasetIndex];\n\t\t\tvar index = point._index;\n\t\t\tvar custom = point.custom || {};\n\t\t\tvar model = point._model;\n\n\t\t\t// Compatibility: If the properties are defined with only the old name, use those values\n\t\t\tif ((dataset.radius !== undefined) && (dataset.pointRadius === undefined)) {\n\t\t\t\tdataset.pointRadius = dataset.radius;\n\t\t\t}\n\n\t\t\tmodel.radius = custom.radius || helpers.getValueAtIndexOrDefault(dataset.pointRadius, index, me.chart.options.elements.point.radius);\n\t\t\tmodel.backgroundColor = me.getPointBackgroundColor(point, index);\n\t\t\tmodel.borderColor = me.getPointBorderColor(point, index);\n\t\t\tmodel.borderWidth = me.getPointBorderWidth(point, index);\n\t\t}\n\t});\n};\n\n},{}],19:[function(require,module,exports){\n'use strict';\n\nmodule.exports = function(Chart) {\n\n\tvar helpers = Chart.helpers;\n\n\tChart.defaults.polarArea = {\n\n\t\tscale: {\n\t\t\ttype: 'radialLinear',\n\t\t\tlineArc: true, // so that lines are circular\n\t\t\tticks: {\n\t\t\t\tbeginAtZero: true\n\t\t\t}\n\t\t},\n\n\t\t// Boolean - Whether to animate the rotation of the chart\n\t\tanimation: {\n\t\t\tanimateRotate: true,\n\t\t\tanimateScale: true\n\t\t},\n\n\t\tstartAngle: -0.5 * Math.PI,\n\t\taspectRatio: 1,\n\t\tlegendCallback: function(chart) {\n\t\t\tvar text = [];\n\t\t\ttext.push('<ul class=\"' + chart.id + '-legend\">');\n\n\t\t\tvar data = chart.data;\n\t\t\tvar datasets = data.datasets;\n\t\t\tvar labels = data.labels;\n\n\t\t\tif (datasets.length) {\n\t\t\t\tfor (var i = 0; i < datasets[0].data.length; ++i) {\n\t\t\t\t\ttext.push('<li><span style=\"background-color:' + datasets[0].backgroundColor[i] + '\"></span>');\n\t\t\t\t\tif (labels[i]) {\n\t\t\t\t\t\ttext.push(labels[i]);\n\t\t\t\t\t}\n\t\t\t\t\ttext.push('</li>');\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttext.push('</ul>');\n\t\t\treturn text.join('');\n\t\t},\n\t\tlegend: {\n\t\t\tlabels: {\n\t\t\t\tgenerateLabels: function(chart) {\n\t\t\t\t\tvar data = chart.data;\n\t\t\t\t\tif (data.labels.length && data.datasets.length) {\n\t\t\t\t\t\treturn data.labels.map(function(label, i) {\n\t\t\t\t\t\t\tvar meta = chart.getDatasetMeta(0);\n\t\t\t\t\t\t\tvar ds = data.datasets[0];\n\t\t\t\t\t\t\tvar arc = meta.data[i];\n\t\t\t\t\t\t\tvar custom = arc.custom || {};\n\t\t\t\t\t\t\tvar getValueAtIndexOrDefault = helpers.getValueAtIndexOrDefault;\n\t\t\t\t\t\t\tvar arcOpts = chart.options.elements.arc;\n\t\t\t\t\t\t\tvar fill = custom.backgroundColor ? custom.backgroundColor : getValueAtIndexOrDefault(ds.backgroundColor, i, arcOpts.backgroundColor);\n\t\t\t\t\t\t\tvar stroke = custom.borderColor ? custom.borderColor : getValueAtIndexOrDefault(ds.borderColor, i, arcOpts.borderColor);\n\t\t\t\t\t\t\tvar bw = custom.borderWidth ? custom.borderWidth : getValueAtIndexOrDefault(ds.borderWidth, i, arcOpts.borderWidth);\n\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\ttext: label,\n\t\t\t\t\t\t\t\tfillStyle: fill,\n\t\t\t\t\t\t\t\tstrokeStyle: stroke,\n\t\t\t\t\t\t\t\tlineWidth: bw,\n\t\t\t\t\t\t\t\thidden: isNaN(ds.data[i]) || meta.data[i].hidden,\n\n\t\t\t\t\t\t\t\t// Extra data used for toggling the correct item\n\t\t\t\t\t\t\t\tindex: i\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\treturn [];\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tonClick: function(e, legendItem) {\n\t\t\t\tvar index = legendItem.index;\n\t\t\t\tvar chart = this.chart;\n\t\t\t\tvar i, ilen, meta;\n\n\t\t\t\tfor (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {\n\t\t\t\t\tmeta = chart.getDatasetMeta(i);\n\t\t\t\t\tmeta.data[index].hidden = !meta.data[index].hidden;\n\t\t\t\t}\n\n\t\t\t\tchart.update();\n\t\t\t}\n\t\t},\n\n\t\t// Need to override these to give a nice default\n\t\ttooltips: {\n\t\t\tcallbacks: {\n\t\t\t\ttitle: function() {\n\t\t\t\t\treturn '';\n\t\t\t\t},\n\t\t\t\tlabel: function(tooltipItem, data) {\n\t\t\t\t\treturn data.labels[tooltipItem.index] + ': ' + tooltipItem.yLabel;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\tChart.controllers.polarArea = Chart.DatasetController.extend({\n\n\t\tdataElementType: Chart.elements.Arc,\n\n\t\tlinkScales: helpers.noop,\n\n\t\tupdate: function(reset) {\n\t\t\tvar me = this;\n\t\t\tvar chart = me.chart;\n\t\t\tvar chartArea = chart.chartArea;\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar opts = chart.options;\n\t\t\tvar arcOpts = opts.elements.arc;\n\t\t\tvar minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);\n\t\t\tchart.outerRadius = Math.max((minSize - arcOpts.borderWidth / 2) / 2, 0);\n\t\t\tchart.innerRadius = Math.max(opts.cutoutPercentage ? (chart.outerRadius / 100) * (opts.cutoutPercentage) : 1, 0);\n\t\t\tchart.radiusLength = (chart.outerRadius - chart.innerRadius) / chart.getVisibleDatasetCount();\n\n\t\t\tme.outerRadius = chart.outerRadius - (chart.radiusLength * me.index);\n\t\t\tme.innerRadius = me.outerRadius - chart.radiusLength;\n\n\t\t\tmeta.count = me.countVisibleElements();\n\n\t\t\thelpers.each(meta.data, function(arc, index) {\n\t\t\t\tme.updateElement(arc, index, reset);\n\t\t\t});\n\t\t},\n\n\t\tupdateElement: function(arc, index, reset) {\n\t\t\tvar me = this;\n\t\t\tvar chart = me.chart;\n\t\t\tvar dataset = me.getDataset();\n\t\t\tvar opts = chart.options;\n\t\t\tvar animationOpts = opts.animation;\n\t\t\tvar scale = chart.scale;\n\t\t\tvar getValueAtIndexOrDefault = helpers.getValueAtIndexOrDefault;\n\t\t\tvar labels = chart.data.labels;\n\n\t\t\tvar circumference = me.calculateCircumference(dataset.data[index]);\n\t\t\tvar centerX = scale.xCenter;\n\t\t\tvar centerY = scale.yCenter;\n\n\t\t\t// If there is NaN data before us, we need to calculate the starting angle correctly.\n\t\t\t// We could be way more efficient here, but its unlikely that the polar area chart will have a lot of data\n\t\t\tvar visibleCount = 0;\n\t\t\tvar meta = me.getMeta();\n\t\t\tfor (var i = 0; i < index; ++i) {\n\t\t\t\tif (!isNaN(dataset.data[i]) && !meta.data[i].hidden) {\n\t\t\t\t\t++visibleCount;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// var negHalfPI = -0.5 * Math.PI;\n\t\t\tvar datasetStartAngle = opts.startAngle;\n\t\t\tvar distance = arc.hidden ? 0 : scale.getDistanceFromCenterForValue(dataset.data[index]);\n\t\t\tvar startAngle = datasetStartAngle + (circumference * visibleCount);\n\t\t\tvar endAngle = startAngle + (arc.hidden ? 0 : circumference);\n\n\t\t\tvar resetRadius = animationOpts.animateScale ? 0 : scale.getDistanceFromCenterForValue(dataset.data[index]);\n\n\t\t\thelpers.extend(arc, {\n\t\t\t\t// Utility\n\t\t\t\t_datasetIndex: me.index,\n\t\t\t\t_index: index,\n\t\t\t\t_scale: scale,\n\n\t\t\t\t// Desired view properties\n\t\t\t\t_model: {\n\t\t\t\t\tx: centerX,\n\t\t\t\t\ty: centerY,\n\t\t\t\t\tinnerRadius: 0,\n\t\t\t\t\touterRadius: reset ? resetRadius : distance,\n\t\t\t\t\tstartAngle: reset && animationOpts.animateRotate ? datasetStartAngle : startAngle,\n\t\t\t\t\tendAngle: reset && animationOpts.animateRotate ? datasetStartAngle : endAngle,\n\t\t\t\t\tlabel: getValueAtIndexOrDefault(labels, index, labels[index])\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// Apply border and fill style\n\t\t\tme.removeHoverStyle(arc);\n\n\t\t\tarc.pivot();\n\t\t},\n\n\t\tremoveHoverStyle: function(arc) {\n\t\t\tChart.DatasetController.prototype.removeHoverStyle.call(this, arc, this.chart.options.elements.arc);\n\t\t},\n\n\t\tcountVisibleElements: function() {\n\t\t\tvar dataset = this.getDataset();\n\t\t\tvar meta = this.getMeta();\n\t\t\tvar count = 0;\n\n\t\t\thelpers.each(meta.data, function(element, index) {\n\t\t\t\tif (!isNaN(dataset.data[index]) && !element.hidden) {\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\treturn count;\n\t\t},\n\n\t\tcalculateCircumference: function(value) {\n\t\t\tvar count = this.getMeta().count;\n\t\t\tif (count > 0 && !isNaN(value)) {\n\t\t\t\treturn (2 * Math.PI) / count;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t});\n};\n\n},{}],20:[function(require,module,exports){\n'use strict';\n\nmodule.exports = function(Chart) {\n\n\tvar helpers = Chart.helpers;\n\n\tChart.defaults.radar = {\n\t\taspectRatio: 1,\n\t\tscale: {\n\t\t\ttype: 'radialLinear'\n\t\t},\n\t\telements: {\n\t\t\tline: {\n\t\t\t\ttension: 0 // no bezier in radar\n\t\t\t}\n\t\t}\n\t};\n\n\tChart.controllers.radar = Chart.DatasetController.extend({\n\n\t\tdatasetElementType: Chart.elements.Line,\n\n\t\tdataElementType: Chart.elements.Point,\n\n\t\tlinkScales: helpers.noop,\n\n\t\tupdate: function(reset) {\n\t\t\tvar me = this;\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar line = meta.dataset;\n\t\t\tvar points = meta.data;\n\t\t\tvar custom = line.custom || {};\n\t\t\tvar dataset = me.getDataset();\n\t\t\tvar lineElementOptions = me.chart.options.elements.line;\n\t\t\tvar scale = me.chart.scale;\n\n\t\t\t// Compatibility: If the properties are defined with only the old name, use those values\n\t\t\tif ((dataset.tension !== undefined) && (dataset.lineTension === undefined)) {\n\t\t\t\tdataset.lineTension = dataset.tension;\n\t\t\t}\n\n\t\t\thelpers.extend(meta.dataset, {\n\t\t\t\t// Utility\n\t\t\t\t_datasetIndex: me.index,\n\t\t\t\t// Data\n\t\t\t\t_children: points,\n\t\t\t\t_loop: true,\n\t\t\t\t// Model\n\t\t\t\t_model: {\n\t\t\t\t\t// Appearance\n\t\t\t\t\ttension: custom.tension ? custom.tension : helpers.getValueOrDefault(dataset.lineTension, lineElementOptions.tension),\n\t\t\t\t\tbackgroundColor: custom.backgroundColor ? custom.backgroundColor : (dataset.backgroundColor || lineElementOptions.backgroundColor),\n\t\t\t\t\tborderWidth: custom.borderWidth ? custom.borderWidth : (dataset.borderWidth || lineElementOptions.borderWidth),\n\t\t\t\t\tborderColor: custom.borderColor ? custom.borderColor : (dataset.borderColor || lineElementOptions.borderColor),\n\t\t\t\t\tfill: custom.fill ? custom.fill : (dataset.fill !== undefined ? dataset.fill : lineElementOptions.fill),\n\t\t\t\t\tborderCapStyle: custom.borderCapStyle ? custom.borderCapStyle : (dataset.borderCapStyle || lineElementOptions.borderCapStyle),\n\t\t\t\t\tborderDash: custom.borderDash ? custom.borderDash : (dataset.borderDash || lineElementOptions.borderDash),\n\t\t\t\t\tborderDashOffset: custom.borderDashOffset ? custom.borderDashOffset : (dataset.borderDashOffset || lineElementOptions.borderDashOffset),\n\t\t\t\t\tborderJoinStyle: custom.borderJoinStyle ? custom.borderJoinStyle : (dataset.borderJoinStyle || lineElementOptions.borderJoinStyle),\n\n\t\t\t\t\t// Scale\n\t\t\t\t\tscaleTop: scale.top,\n\t\t\t\t\tscaleBottom: scale.bottom,\n\t\t\t\t\tscaleZero: scale.getBasePosition()\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tmeta.dataset.pivot();\n\n\t\t\t// Update Points\n\t\t\thelpers.each(points, function(point, index) {\n\t\t\t\tme.updateElement(point, index, reset);\n\t\t\t}, me);\n\n\t\t\t// Update bezier control points\n\t\t\tme.updateBezierControlPoints();\n\t\t},\n\t\tupdateElement: function(point, index, reset) {\n\t\t\tvar me = this;\n\t\t\tvar custom = point.custom || {};\n\t\t\tvar dataset = me.getDataset();\n\t\t\tvar scale = me.chart.scale;\n\t\t\tvar pointElementOptions = me.chart.options.elements.point;\n\t\t\tvar pointPosition = scale.getPointPositionForValue(index, dataset.data[index]);\n\n\t\t\thelpers.extend(point, {\n\t\t\t\t// Utility\n\t\t\t\t_datasetIndex: me.index,\n\t\t\t\t_index: index,\n\t\t\t\t_scale: scale,\n\n\t\t\t\t// Desired view properties\n\t\t\t\t_model: {\n\t\t\t\t\tx: reset ? scale.xCenter : pointPosition.x, // value not used in dataset scale, but we want a consistent API between scales\n\t\t\t\t\ty: reset ? scale.yCenter : pointPosition.y,\n\n\t\t\t\t\t// Appearance\n\t\t\t\t\ttension: custom.tension ? custom.tension : helpers.getValueOrDefault(dataset.lineTension, me.chart.options.elements.line.tension),\n\t\t\t\t\tradius: custom.radius ? custom.radius : helpers.getValueAtIndexOrDefault(dataset.pointRadius, index, pointElementOptions.radius),\n\t\t\t\t\tbackgroundColor: custom.backgroundColor ? custom.backgroundColor : helpers.getValueAtIndexOrDefault(dataset.pointBackgroundColor, index, pointElementOptions.backgroundColor),\n\t\t\t\t\tborderColor: custom.borderColor ? custom.borderColor : helpers.getValueAtIndexOrDefault(dataset.pointBorderColor, index, pointElementOptions.borderColor),\n\t\t\t\t\tborderWidth: custom.borderWidth ? custom.borderWidth : helpers.getValueAtIndexOrDefault(dataset.pointBorderWidth, index, pointElementOptions.borderWidth),\n\t\t\t\t\tpointStyle: custom.pointStyle ? custom.pointStyle : helpers.getValueAtIndexOrDefault(dataset.pointStyle, index, pointElementOptions.pointStyle),\n\n\t\t\t\t\t// Tooltip\n\t\t\t\t\thitRadius: custom.hitRadius ? custom.hitRadius : helpers.getValueAtIndexOrDefault(dataset.hitRadius, index, pointElementOptions.hitRadius)\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tpoint._model.skip = custom.skip ? custom.skip : (isNaN(point._model.x) || isNaN(point._model.y));\n\t\t},\n\t\tupdateBezierControlPoints: function() {\n\t\t\tvar chartArea = this.chart.chartArea;\n\t\t\tvar meta = this.getMeta();\n\n\t\t\thelpers.each(meta.data, function(point, index) {\n\t\t\t\tvar model = point._model;\n\t\t\t\tvar controlPoints = helpers.splineCurve(\n\t\t\t\t\thelpers.previousItem(meta.data, index, true)._model,\n\t\t\t\t\tmodel,\n\t\t\t\t\thelpers.nextItem(meta.data, index, true)._model,\n\t\t\t\t\tmodel.tension\n\t\t\t\t);\n\n\t\t\t\t// Prevent the bezier going outside of the bounds of the graph\n\t\t\t\tmodel.controlPointPreviousX = Math.max(Math.min(controlPoints.previous.x, chartArea.right), chartArea.left);\n\t\t\t\tmodel.controlPointPreviousY = Math.max(Math.min(controlPoints.previous.y, chartArea.bottom), chartArea.top);\n\n\t\t\t\tmodel.controlPointNextX = Math.max(Math.min(controlPoints.next.x, chartArea.right), chartArea.left);\n\t\t\t\tmodel.controlPointNextY = Math.max(Math.min(controlPoints.next.y, chartArea.bottom), chartArea.top);\n\n\t\t\t\t// Now pivot the point for animation\n\t\t\t\tpoint.pivot();\n\t\t\t});\n\t\t},\n\n\t\tdraw: function(ease) {\n\t\t\tvar meta = this.getMeta();\n\t\t\tvar easingDecimal = ease || 1;\n\n\t\t\t// Transition Point Locations\n\t\t\thelpers.each(meta.data, function(point) {\n\t\t\t\tpoint.transition(easingDecimal);\n\t\t\t});\n\n\t\t\t// Transition and Draw the line\n\t\t\tmeta.dataset.transition(easingDecimal).draw();\n\n\t\t\t// Draw the points\n\t\t\thelpers.each(meta.data, function(point) {\n\t\t\t\tpoint.draw();\n\t\t\t});\n\t\t},\n\n\t\tsetHoverStyle: function(point) {\n\t\t\t// Point\n\t\t\tvar dataset = this.chart.data.datasets[point._datasetIndex];\n\t\t\tvar custom = point.custom || {};\n\t\t\tvar index = point._index;\n\t\t\tvar model = point._model;\n\n\t\t\tmodel.radius = custom.hoverRadius ? custom.hoverRadius : helpers.getValueAtIndexOrDefault(dataset.pointHoverRadius, index, this.chart.options.elements.point.hoverRadius);\n\t\t\tmodel.backgroundColor = custom.hoverBackgroundColor ? custom.hoverBackgroundColor : helpers.getValueAtIndexOrDefault(dataset.pointHoverBackgroundColor, index, helpers.getHoverColor(model.backgroundColor));\n\t\t\tmodel.borderColor = custom.hoverBorderColor ? custom.hoverBorderColor : helpers.getValueAtIndexOrDefault(dataset.pointHoverBorderColor, index, helpers.getHoverColor(model.borderColor));\n\t\t\tmodel.borderWidth = custom.hoverBorderWidth ? custom.hoverBorderWidth : helpers.getValueAtIndexOrDefault(dataset.pointHoverBorderWidth, index, model.borderWidth);\n\t\t},\n\n\t\tremoveHoverStyle: function(point) {\n\t\t\tvar dataset = this.chart.data.datasets[point._datasetIndex];\n\t\t\tvar custom = point.custom || {};\n\t\t\tvar index = point._index;\n\t\t\tvar model = point._model;\n\t\t\tvar pointElementOptions = this.chart.options.elements.point;\n\n\t\t\tmodel.radius = custom.radius ? custom.radius : helpers.getValueAtIndexOrDefault(dataset.radius, index, pointElementOptions.radius);\n\t\t\tmodel.backgroundColor = custom.backgroundColor ? custom.backgroundColor : helpers.getValueAtIndexOrDefault(dataset.pointBackgroundColor, index, pointElementOptions.backgroundColor);\n\t\t\tmodel.borderColor = custom.borderColor ? custom.borderColor : helpers.getValueAtIndexOrDefault(dataset.pointBorderColor, index, pointElementOptions.borderColor);\n\t\t\tmodel.borderWidth = custom.borderWidth ? custom.borderWidth : helpers.getValueAtIndexOrDefault(dataset.pointBorderWidth, index, pointElementOptions.borderWidth);\n\t\t}\n\t});\n};\n\n},{}],21:[function(require,module,exports){\n/* global window: false */\n'use strict';\n\nmodule.exports = function(Chart) {\n\n\tvar helpers = Chart.helpers;\n\n\tChart.defaults.global.animation = {\n\t\tduration: 1000,\n\t\teasing: 'easeOutQuart',\n\t\tonProgress: helpers.noop,\n\t\tonComplete: helpers.noop\n\t};\n\n\tChart.Animation = Chart.Element.extend({\n\t\tcurrentStep: null, // the current animation step\n\t\tnumSteps: 60, // default number of steps\n\t\teasing: '', // the easing to use for this animation\n\t\trender: null, // render function used by the animation service\n\n\t\tonAnimationProgress: null, // user specified callback to fire on each step of the animation\n\t\tonAnimationComplete: null // user specified callback to fire when the animation finishes\n\t});\n\n\tChart.animationService = {\n\t\tframeDuration: 17,\n\t\tanimations: [],\n\t\tdropFrames: 0,\n\t\trequest: null,\n\n\t\t/**\n\t\t * @function Chart.animationService.addAnimation\n\t\t * @param chartInstance {ChartController} the chart to animate\n\t\t * @param animationObject {IAnimation} the animation that we will animate\n\t\t * @param duration {Number} length of animation in ms\n\t\t * @param lazy {Boolean} if true, the chart is not marked as animating to enable more responsive interactions\n\t\t */\n\t\taddAnimation: function(chartInstance, animationObject, duration, lazy) {\n\t\t\tvar me = this;\n\n\t\t\tif (!lazy) {\n\t\t\t\tchartInstance.animating = true;\n\t\t\t}\n\n\t\t\tfor (var index = 0; index < me.animations.length; ++index) {\n\t\t\t\tif (me.animations[index].chartInstance === chartInstance) {\n\t\t\t\t\t// replacing an in progress animation\n\t\t\t\t\tme.animations[index].animationObject = animationObject;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tme.animations.push({\n\t\t\t\tchartInstance: chartInstance,\n\t\t\t\tanimationObject: animationObject\n\t\t\t});\n\n\t\t\t// If there are no animations queued, manually kickstart a digest, for lack of a better word\n\t\t\tif (me.animations.length === 1) {\n\t\t\t\tme.requestAnimationFrame();\n\t\t\t}\n\t\t},\n\t\t// Cancel the animation for a given chart instance\n\t\tcancelAnimation: function(chartInstance) {\n\t\t\tvar index = helpers.findIndex(this.animations, function(animationWrapper) {\n\t\t\t\treturn animationWrapper.chartInstance === chartInstance;\n\t\t\t});\n\n\t\t\tif (index !== -1) {\n\t\t\t\tthis.animations.splice(index, 1);\n\t\t\t\tchartInstance.animating = false;\n\t\t\t}\n\t\t},\n\t\trequestAnimationFrame: function() {\n\t\t\tvar me = this;\n\t\t\tif (me.request === null) {\n\t\t\t\t// Skip animation frame requests until the active one is executed.\n\t\t\t\t// This can happen when processing mouse events, e.g. 'mousemove'\n\t\t\t\t// and 'mouseout' events will trigger multiple renders.\n\t\t\t\tme.request = helpers.requestAnimFrame.call(window, function() {\n\t\t\t\t\tme.request = null;\n\t\t\t\t\tme.startDigest();\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\t\tstartDigest: function() {\n\t\t\tvar me = this;\n\n\t\t\tvar startTime = Date.now();\n\t\t\tvar framesToDrop = 0;\n\n\t\t\tif (me.dropFrames > 1) {\n\t\t\t\tframesToDrop = Math.floor(me.dropFrames);\n\t\t\t\tme.dropFrames = me.dropFrames % 1;\n\t\t\t}\n\n\t\t\tvar i = 0;\n\t\t\twhile (i < me.animations.length) {\n\t\t\t\tif (me.animations[i].animationObject.currentStep === null) {\n\t\t\t\t\tme.animations[i].animationObject.currentStep = 0;\n\t\t\t\t}\n\n\t\t\t\tme.animations[i].animationObject.currentStep += 1 + framesToDrop;\n\n\t\t\t\tif (me.animations[i].animationObject.currentStep > me.animations[i].animationObject.numSteps) {\n\t\t\t\t\tme.animations[i].animationObject.currentStep = me.animations[i].animationObject.numSteps;\n\t\t\t\t}\n\n\t\t\t\tme.animations[i].animationObject.render(me.animations[i].chartInstance, me.animations[i].animationObject);\n\t\t\t\tif (me.animations[i].animationObject.onAnimationProgress && me.animations[i].animationObject.onAnimationProgress.call) {\n\t\t\t\t\tme.animations[i].animationObject.onAnimationProgress.call(me.animations[i].chartInstance, me.animations[i]);\n\t\t\t\t}\n\n\t\t\t\tif (me.animations[i].animationObject.currentStep === me.animations[i].animationObject.numSteps) {\n\t\t\t\t\tif (me.animations[i].animationObject.onAnimationComplete && me.animations[i].animationObject.onAnimationComplete.call) {\n\t\t\t\t\t\tme.animations[i].animationObject.onAnimationComplete.call(me.animations[i].chartInstance, me.animations[i]);\n\t\t\t\t\t}\n\n\t\t\t\t\t// executed the last frame. Remove the animation.\n\t\t\t\t\tme.animations[i].chartInstance.animating = false;\n\n\t\t\t\t\tme.animations.splice(i, 1);\n\t\t\t\t} else {\n\t\t\t\t\t++i;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar endTime = Date.now();\n\t\t\tvar dropFrames = (endTime - startTime) / me.frameDuration;\n\n\t\t\tme.dropFrames += dropFrames;\n\n\t\t\t// Do we have more stuff to animate?\n\t\t\tif (me.animations.length > 0) {\n\t\t\t\tme.requestAnimationFrame();\n\t\t\t}\n\t\t}\n\t};\n};\n\n},{}],22:[function(require,module,exports){\n'use strict';\n\nmodule.exports = function(Chart) {\n\t// Global Chart canvas helpers object for drawing items to canvas\n\tvar helpers = Chart.canvasHelpers = {};\n\n\thelpers.drawPoint = function(ctx, pointStyle, radius, x, y) {\n\t\tvar type, edgeLength, xOffset, yOffset, height, size;\n\n\t\tif (typeof pointStyle === 'object') {\n\t\t\ttype = pointStyle.toString();\n\t\t\tif (type === '[object HTMLImageElement]' || type === '[object HTMLCanvasElement]') {\n\t\t\t\tctx.drawImage(pointStyle, x - pointStyle.width / 2, y - pointStyle.height / 2);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif (isNaN(radius) || radius <= 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tswitch (pointStyle) {\n\t\t// Default includes circle\n\t\tdefault:\n\t\t\tctx.beginPath();\n\t\t\tctx.arc(x, y, radius, 0, Math.PI * 2);\n\t\t\tctx.closePath();\n\t\t\tctx.fill();\n\t\t\tbreak;\n\t\tcase 'triangle':\n\t\t\tctx.beginPath();\n\t\t\tedgeLength = 3 * radius / Math.sqrt(3);\n\t\t\theight = edgeLength * Math.sqrt(3) / 2;\n\t\t\tctx.moveTo(x - edgeLength / 2, y + height / 3);\n\t\t\tctx.lineTo(x + edgeLength / 2, y + height / 3);\n\t\t\tctx.lineTo(x, y - 2 * height / 3);\n\t\t\tctx.closePath();\n\t\t\tctx.fill();\n\t\t\tbreak;\n\t\tcase 'rect':\n\t\t\tsize = 1 / Math.SQRT2 * radius;\n\t\t\tctx.beginPath();\n\t\t\tctx.fillRect(x - size, y - size, 2 * size, 2 * size);\n\t\t\tctx.strokeRect(x - size, y - size, 2 * size, 2 * size);\n\t\t\tbreak;\n\t\tcase 'rectRounded':\n\t\t\tvar offset = radius / Math.SQRT2;\n\t\t\tvar leftX = x - offset;\n\t\t\tvar topY = y - offset;\n\t\t\tvar sideSize = Math.SQRT2 * radius;\n\t\t\tChart.helpers.drawRoundedRectangle(ctx, leftX, topY, sideSize, sideSize, radius / 2);\n\t\t\tctx.fill();\n\t\t\tbreak;\n\t\tcase 'rectRot':\n\t\t\tsize = 1 / Math.SQRT2 * radius;\n\t\t\tctx.beginPath();\n\t\t\tctx.moveTo(x - size, y);\n\t\t\tctx.lineTo(x, y + size);\n\t\t\tctx.lineTo(x + size, y);\n\t\t\tctx.lineTo(x, y - size);\n\t\t\tctx.closePath();\n\t\t\tctx.fill();\n\t\t\tbreak;\n\t\tcase 'cross':\n\t\t\tctx.beginPath();\n\t\t\tctx.moveTo(x, y + radius);\n\t\t\tctx.lineTo(x, y - radius);\n\t\t\tctx.moveTo(x - radius, y);\n\t\t\tctx.lineTo(x + radius, y);\n\t\t\tctx.closePath();\n\t\t\tbreak;\n\t\tcase 'crossRot':\n\t\t\tctx.beginPath();\n\t\t\txOffset = Math.cos(Math.PI / 4) * radius;\n\t\t\tyOffset = Math.sin(Math.PI / 4) * radius;\n\t\t\tctx.moveTo(x - xOffset, y - yOffset);\n\t\t\tctx.lineTo(x + xOffset, y + yOffset);\n\t\t\tctx.moveTo(x - xOffset, y + yOffset);\n\t\t\tctx.lineTo(x + xOffset, y - yOffset);\n\t\t\tctx.closePath();\n\t\t\tbreak;\n\t\tcase 'star':\n\t\t\tctx.beginPath();\n\t\t\tctx.moveTo(x, y + radius);\n\t\t\tctx.lineTo(x, y - radius);\n\t\t\tctx.moveTo(x - radius, y);\n\t\t\tctx.lineTo(x + radius, y);\n\t\t\txOffset = Math.cos(Math.PI / 4) * radius;\n\t\t\tyOffset = Math.sin(Math.PI / 4) * radius;\n\t\t\tctx.moveTo(x - xOffset, y - yOffset);\n\t\t\tctx.lineTo(x + xOffset, y + yOffset);\n\t\t\tctx.moveTo(x - xOffset, y + yOffset);\n\t\t\tctx.lineTo(x + xOffset, y - yOffset);\n\t\t\tctx.closePath();\n\t\t\tbreak;\n\t\tcase 'line':\n\t\t\tctx.beginPath();\n\t\t\tctx.moveTo(x - radius, y);\n\t\t\tctx.lineTo(x + radius, y);\n\t\t\tctx.closePath();\n\t\t\tbreak;\n\t\tcase 'dash':\n\t\t\tctx.beginPath();\n\t\t\tctx.moveTo(x, y);\n\t\t\tctx.lineTo(x + radius, y);\n\t\t\tctx.closePath();\n\t\t\tbreak;\n\t\t}\n\n\t\tctx.stroke();\n\t};\n\n\thelpers.clipArea = function(ctx, clipArea) {\n\t\tctx.save();\n\t\tctx.beginPath();\n\t\tctx.rect(clipArea.left, clipArea.top, clipArea.right - clipArea.left, clipArea.bottom - clipArea.top);\n\t\tctx.clip();\n\t};\n\n\thelpers.unclipArea = function(ctx) {\n\t\tctx.restore();\n\t};\n\n};\n\n},{}],23:[function(require,module,exports){\n'use strict';\n\nmodule.exports = function(Chart) {\n\n\tvar helpers = Chart.helpers;\n\tvar plugins = Chart.plugins;\n\tvar platform = Chart.platform;\n\n\t// Create a dictionary of chart types, to allow for extension of existing types\n\tChart.types = {};\n\n\t// Store a reference to each instance - allowing us to globally resize chart instances on window resize.\n\t// Destroy method on the chart will remove the instance of the chart from this reference.\n\tChart.instances = {};\n\n\t// Controllers available for dataset visualization eg. bar, line, slice, etc.\n\tChart.controllers = {};\n\n\t/**\n\t * Initializes the given config with global and chart default values.\n\t */\n\tfunction initConfig(config) {\n\t\tconfig = config || {};\n\n\t\t// Do NOT use configMerge() for the data object because this method merges arrays\n\t\t// and so would change references to labels and datasets, preventing data updates.\n\t\tvar data = config.data = config.data || {};\n\t\tdata.datasets = data.datasets || [];\n\t\tdata.labels = data.labels || [];\n\n\t\tconfig.options = helpers.configMerge(\n\t\t\tChart.defaults.global,\n\t\t\tChart.defaults[config.type],\n\t\t\tconfig.options || {});\n\n\t\treturn config;\n\t}\n\n\t/**\n\t * Updates the config of the chart\n\t * @param chart {Chart.Controller} chart to update the options for\n\t */\n\tfunction updateConfig(chart) {\n\t\tvar newOptions = chart.options;\n\n\t\t// Update Scale(s) with options\n\t\tif (newOptions.scale) {\n\t\t\tchart.scale.options = newOptions.scale;\n\t\t} else if (newOptions.scales) {\n\t\t\tnewOptions.scales.xAxes.concat(newOptions.scales.yAxes).forEach(function(scaleOptions) {\n\t\t\t\tchart.scales[scaleOptions.id].options = scaleOptions;\n\t\t\t});\n\t\t}\n\n\t\t// Tooltip\n\t\tchart.tooltip._options = newOptions.tooltips;\n\t}\n\n\t/**\n\t * @class Chart.Controller\n\t * The main controller of a chart.\n\t */\n\tChart.Controller = function(item, config, instance) {\n\t\tvar me = this;\n\n\t\tconfig = initConfig(config);\n\n\t\tvar context = platform.acquireContext(item, config);\n\t\tvar canvas = context && context.canvas;\n\t\tvar height = canvas && canvas.height;\n\t\tvar width = canvas && canvas.width;\n\n\t\tinstance.ctx = context;\n\t\tinstance.canvas = canvas;\n\t\tinstance.config = config;\n\t\tinstance.width = width;\n\t\tinstance.height = height;\n\t\tinstance.aspectRatio = height? width / height : null;\n\n\t\tme.id = helpers.uid();\n\t\tme.chart = instance;\n\t\tme.config = config;\n\t\tme.options = config.options;\n\t\tme._bufferedRender = false;\n\n\t\t// Add the chart instance to the global namespace\n\t\tChart.instances[me.id] = me;\n\n\t\tObject.defineProperty(me, 'data', {\n\t\t\tget: function() {\n\t\t\t\treturn me.config.data;\n\t\t\t}\n\t\t});\n\n\t\tif (!context || !canvas) {\n\t\t\t// The given item is not a compatible context2d element, let's return before finalizing\n\t\t\t// the chart initialization but after setting basic chart / controller properties that\n\t\t\t// can help to figure out that the chart is not valid (e.g chart.canvas !== null);\n\t\t\t// https://github.com/chartjs/Chart.js/issues/2807\n\t\t\tconsole.error(\"Failed to create chart: can't acquire context from the given item\");\n\t\t\treturn me;\n\t\t}\n\n\t\tme.initialize();\n\t\tme.update();\n\n\t\treturn me;\n\t};\n\n\thelpers.extend(Chart.Controller.prototype, /** @lends Chart.Controller.prototype */ {\n\t\tinitialize: function() {\n\t\t\tvar me = this;\n\n\t\t\t// Before init plugin notification\n\t\t\tplugins.notify(me, 'beforeInit');\n\n\t\t\thelpers.retinaScale(me.chart);\n\n\t\t\tme.bindEvents();\n\n\t\t\tif (me.options.responsive) {\n\t\t\t\t// Initial resize before chart draws (must be silent to preserve initial animations).\n\t\t\t\tme.resize(true);\n\t\t\t}\n\n\t\t\t// Make sure scales have IDs and are built before we build any controllers.\n\t\t\tme.ensureScalesHaveIDs();\n\t\t\tme.buildScales();\n\t\t\tme.initToolTip();\n\n\t\t\t// After init plugin notification\n\t\t\tplugins.notify(me, 'afterInit');\n\n\t\t\treturn me;\n\t\t},\n\n\t\tclear: function() {\n\t\t\thelpers.clear(this.chart);\n\t\t\treturn this;\n\t\t},\n\n\t\tstop: function() {\n\t\t\t// Stops any current animation loop occurring\n\t\t\tChart.animationService.cancelAnimation(this);\n\t\t\treturn this;\n\t\t},\n\n\t\tresize: function(silent) {\n\t\t\tvar me = this;\n\t\t\tvar chart = me.chart;\n\t\t\tvar options = me.options;\n\t\t\tvar canvas = chart.canvas;\n\t\t\tvar aspectRatio = (options.maintainAspectRatio && chart.aspectRatio) || null;\n\n\t\t\t// the canvas render width and height will be casted to integers so make sure that\n\t\t\t// the canvas display style uses the same integer values to avoid blurring effect.\n\t\t\tvar newWidth = Math.floor(helpers.getMaximumWidth(canvas));\n\t\t\tvar newHeight = Math.floor(aspectRatio? newWidth / aspectRatio : helpers.getMaximumHeight(canvas));\n\n\t\t\tif (chart.width === newWidth && chart.height === newHeight) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tcanvas.width = chart.width = newWidth;\n\t\t\tcanvas.height = chart.height = newHeight;\n\t\t\tcanvas.style.width = newWidth + 'px';\n\t\t\tcanvas.style.height = newHeight + 'px';\n\n\t\t\thelpers.retinaScale(chart);\n\n\t\t\tif (!silent) {\n\t\t\t\t// Notify any plugins about the resize\n\t\t\t\tvar newSize = {width: newWidth, height: newHeight};\n\t\t\t\tplugins.notify(me, 'resize', [newSize]);\n\n\t\t\t\t// Notify of resize\n\t\t\t\tif (me.options.onResize) {\n\t\t\t\t\tme.options.onResize(me, newSize);\n\t\t\t\t}\n\n\t\t\t\tme.stop();\n\t\t\t\tme.update(me.options.responsiveAnimationDuration);\n\t\t\t}\n\t\t},\n\n\t\tensureScalesHaveIDs: function() {\n\t\t\tvar options = this.options;\n\t\t\tvar scalesOptions = options.scales || {};\n\t\t\tvar scaleOptions = options.scale;\n\n\t\t\thelpers.each(scalesOptions.xAxes, function(xAxisOptions, index) {\n\t\t\t\txAxisOptions.id = xAxisOptions.id || ('x-axis-' + index);\n\t\t\t});\n\n\t\t\thelpers.each(scalesOptions.yAxes, function(yAxisOptions, index) {\n\t\t\t\tyAxisOptions.id = yAxisOptions.id || ('y-axis-' + index);\n\t\t\t});\n\n\t\t\tif (scaleOptions) {\n\t\t\t\tscaleOptions.id = scaleOptions.id || 'scale';\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Builds a map of scale ID to scale object for future lookup.\n\t\t */\n\t\tbuildScales: function() {\n\t\t\tvar me = this;\n\t\t\tvar options = me.options;\n\t\t\tvar scales = me.scales = {};\n\t\t\tvar items = [];\n\n\t\t\tif (options.scales) {\n\t\t\t\titems = items.concat(\n\t\t\t\t\t(options.scales.xAxes || []).map(function(xAxisOptions) {\n\t\t\t\t\t\treturn {options: xAxisOptions, dtype: 'category'};\n\t\t\t\t\t}),\n\t\t\t\t\t(options.scales.yAxes || []).map(function(yAxisOptions) {\n\t\t\t\t\t\treturn {options: yAxisOptions, dtype: 'linear'};\n\t\t\t\t\t})\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (options.scale) {\n\t\t\t\titems.push({options: options.scale, dtype: 'radialLinear', isDefault: true});\n\t\t\t}\n\n\t\t\thelpers.each(items, function(item) {\n\t\t\t\tvar scaleOptions = item.options;\n\t\t\t\tvar scaleType = helpers.getValueOrDefault(scaleOptions.type, item.dtype);\n\t\t\t\tvar scaleClass = Chart.scaleService.getScaleConstructor(scaleType);\n\t\t\t\tif (!scaleClass) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tvar scale = new scaleClass({\n\t\t\t\t\tid: scaleOptions.id,\n\t\t\t\t\toptions: scaleOptions,\n\t\t\t\t\tctx: me.chart.ctx,\n\t\t\t\t\tchart: me\n\t\t\t\t});\n\n\t\t\t\tscales[scale.id] = scale;\n\n\t\t\t\t// TODO(SB): I think we should be able to remove this custom case (options.scale)\n\t\t\t\t// and consider it as a regular scale part of the \"scales\"\" map only! This would\n\t\t\t\t// make the logic easier and remove some useless? custom code.\n\t\t\t\tif (item.isDefault) {\n\t\t\t\t\tme.scale = scale;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tChart.scaleService.addScalesToLayout(this);\n\t\t},\n\n\t\tbuildOrUpdateControllers: function() {\n\t\t\tvar me = this;\n\t\t\tvar types = [];\n\t\t\tvar newControllers = [];\n\n\t\t\thelpers.each(me.data.datasets, function(dataset, datasetIndex) {\n\t\t\t\tvar meta = me.getDatasetMeta(datasetIndex);\n\t\t\t\tif (!meta.type) {\n\t\t\t\t\tmeta.type = dataset.type || me.config.type;\n\t\t\t\t}\n\n\t\t\t\ttypes.push(meta.type);\n\n\t\t\t\tif (meta.controller) {\n\t\t\t\t\tmeta.controller.updateIndex(datasetIndex);\n\t\t\t\t} else {\n\t\t\t\t\tmeta.controller = new Chart.controllers[meta.type](me, datasetIndex);\n\t\t\t\t\tnewControllers.push(meta.controller);\n\t\t\t\t}\n\t\t\t}, me);\n\n\t\t\tif (types.length > 1) {\n\t\t\t\tfor (var i = 1; i < types.length; i++) {\n\t\t\t\t\tif (types[i] !== types[i - 1]) {\n\t\t\t\t\t\tme.isCombo = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn newControllers;\n\t\t},\n\n\t\t/**\n\t\t * Reset the elements of all datasets\n\t\t * @private\n\t\t */\n\t\tresetElements: function() {\n\t\t\tvar me = this;\n\t\t\thelpers.each(me.data.datasets, function(dataset, datasetIndex) {\n\t\t\t\tme.getDatasetMeta(datasetIndex).controller.reset();\n\t\t\t}, me);\n\t\t},\n\n\t\t/**\n\t\t* Resets the chart back to it's state before the initial animation\n\t\t*/\n\t\treset: function() {\n\t\t\tthis.resetElements();\n\t\t\tthis.tooltip.initialize();\n\t\t},\n\n\t\tupdate: function(animationDuration, lazy) {\n\t\t\tvar me = this;\n\n\t\t\tupdateConfig(me);\n\n\t\t\tif (plugins.notify(me, 'beforeUpdate') === false) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// In case the entire data object changed\n\t\t\tme.tooltip._data = me.data;\n\n\t\t\t// Make sure dataset controllers are updated and new controllers are reset\n\t\t\tvar newControllers = me.buildOrUpdateControllers();\n\n\t\t\t// Make sure all dataset controllers have correct meta data counts\n\t\t\thelpers.each(me.data.datasets, function(dataset, datasetIndex) {\n\t\t\t\tme.getDatasetMeta(datasetIndex).controller.buildOrUpdateElements();\n\t\t\t}, me);\n\n\t\t\tme.updateLayout();\n\n\t\t\t// Can only reset the new controllers after the scales have been updated\n\t\t\thelpers.each(newControllers, function(controller) {\n\t\t\t\tcontroller.reset();\n\t\t\t});\n\n\t\t\tme.updateDatasets();\n\n\t\t\t// Do this before render so that any plugins that need final scale updates can use it\n\t\t\tplugins.notify(me, 'afterUpdate');\n\n\t\t\tif (me._bufferedRender) {\n\t\t\t\tme._bufferedRequest = {\n\t\t\t\t\tlazy: lazy,\n\t\t\t\t\tduration: animationDuration\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\tme.render(animationDuration, lazy);\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Updates the chart layout unless a plugin returns `false` to the `beforeLayout`\n\t\t * hook, in which case, plugins will not be called on `afterLayout`.\n\t\t * @private\n\t\t */\n\t\tupdateLayout: function() {\n\t\t\tvar me = this;\n\n\t\t\tif (plugins.notify(me, 'beforeLayout') === false) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tChart.layoutService.update(this, this.chart.width, this.chart.height);\n\n\t\t\t/**\n\t\t\t * Provided for backward compatibility, use `afterLayout` instead.\n\t\t\t * @method IPlugin#afterScaleUpdate\n\t\t\t * @deprecated since version 2.5.0\n\t\t\t * @todo remove at version 3\n\t\t\t */\n\t\t\tplugins.notify(me, 'afterScaleUpdate');\n\t\t\tplugins.notify(me, 'afterLayout');\n\t\t},\n\n\t\t/**\n\t\t * Updates all datasets unless a plugin returns `false` to the `beforeDatasetsUpdate`\n\t\t * hook, in which case, plugins will not be called on `afterDatasetsUpdate`.\n\t\t * @private\n\t\t */\n\t\tupdateDatasets: function() {\n\t\t\tvar me = this;\n\n\t\t\tif (plugins.notify(me, 'beforeDatasetsUpdate') === false) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tfor (var i = 0, ilen = me.data.datasets.length; i < ilen; ++i) {\n\t\t\t\tme.getDatasetMeta(i).controller.update();\n\t\t\t}\n\n\t\t\tplugins.notify(me, 'afterDatasetsUpdate');\n\t\t},\n\n\t\trender: function(duration, lazy) {\n\t\t\tvar me = this;\n\n\t\t\tif (plugins.notify(me, 'beforeRender') === false) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar animationOptions = me.options.animation;\n\t\t\tvar onComplete = function() {\n\t\t\t\tplugins.notify(me, 'afterRender');\n\t\t\t\tvar callback = animationOptions && animationOptions.onComplete;\n\t\t\t\tif (callback && callback.call) {\n\t\t\t\t\tcallback.call(me);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tif (animationOptions && ((typeof duration !== 'undefined' && duration !== 0) || (typeof duration === 'undefined' && animationOptions.duration !== 0))) {\n\t\t\t\tvar animation = new Chart.Animation();\n\t\t\t\tanimation.numSteps = (duration || animationOptions.duration) / 16.66; // 60 fps\n\t\t\t\tanimation.easing = animationOptions.easing;\n\n\t\t\t\t// render function\n\t\t\t\tanimation.render = function(chartInstance, animationObject) {\n\t\t\t\t\tvar easingFunction = helpers.easingEffects[animationObject.easing];\n\t\t\t\t\tvar stepDecimal = animationObject.currentStep / animationObject.numSteps;\n\t\t\t\t\tvar easeDecimal = easingFunction(stepDecimal);\n\n\t\t\t\t\tchartInstance.draw(easeDecimal, stepDecimal, animationObject.currentStep);\n\t\t\t\t};\n\n\t\t\t\t// user events\n\t\t\t\tanimation.onAnimationProgress = animationOptions.onProgress;\n\t\t\t\tanimation.onAnimationComplete = onComplete;\n\n\t\t\t\tChart.animationService.addAnimation(me, animation, duration, lazy);\n\t\t\t} else {\n\t\t\t\tme.draw();\n\t\t\t\tonComplete();\n\t\t\t}\n\n\t\t\treturn me;\n\t\t},\n\n\t\tdraw: function(easingValue) {\n\t\t\tvar me = this;\n\n\t\t\tme.clear();\n\n\t\t\tif (easingValue === undefined || easingValue === null) {\n\t\t\t\teasingValue = 1;\n\t\t\t}\n\n\t\t\tif (plugins.notify(me, 'beforeDraw', [easingValue]) === false) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Draw all the scales\n\t\t\thelpers.each(me.boxes, function(box) {\n\t\t\t\tbox.draw(me.chartArea);\n\t\t\t}, me);\n\n\t\t\tif (me.scale) {\n\t\t\t\tme.scale.draw();\n\t\t\t}\n\n\t\t\tme.drawDatasets(easingValue);\n\n\t\t\t// Finally draw the tooltip\n\t\t\tme.tooltip.transition(easingValue).draw();\n\n\t\t\tplugins.notify(me, 'afterDraw', [easingValue]);\n\t\t},\n\n\t\t/**\n\t\t * Draws all datasets unless a plugin returns `false` to the `beforeDatasetsDraw`\n\t\t * hook, in which case, plugins will not be called on `afterDatasetsDraw`.\n\t\t * @private\n\t\t */\n\t\tdrawDatasets: function(easingValue) {\n\t\t\tvar me = this;\n\n\t\t\tif (plugins.notify(me, 'beforeDatasetsDraw', [easingValue]) === false) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Draw each dataset via its respective controller (reversed to support proper line stacking)\n\t\t\thelpers.each(me.data.datasets, function(dataset, datasetIndex) {\n\t\t\t\tif (me.isDatasetVisible(datasetIndex)) {\n\t\t\t\t\tme.getDatasetMeta(datasetIndex).controller.draw(easingValue);\n\t\t\t\t}\n\t\t\t}, me, true);\n\n\t\t\tplugins.notify(me, 'afterDatasetsDraw', [easingValue]);\n\t\t},\n\n\t\t// Get the single element that was clicked on\n\t\t// @return : An object containing the dataset index and element index of the matching element. Also contains the rectangle that was draw\n\t\tgetElementAtEvent: function(e) {\n\t\t\treturn Chart.Interaction.modes.single(this, e);\n\t\t},\n\n\t\tgetElementsAtEvent: function(e) {\n\t\t\treturn Chart.Interaction.modes.label(this, e, {intersect: true});\n\t\t},\n\n\t\tgetElementsAtXAxis: function(e) {\n\t\t\treturn Chart.Interaction.modes['x-axis'](this, e, {intersect: true});\n\t\t},\n\n\t\tgetElementsAtEventForMode: function(e, mode, options) {\n\t\t\tvar method = Chart.Interaction.modes[mode];\n\t\t\tif (typeof method === 'function') {\n\t\t\t\treturn method(this, e, options);\n\t\t\t}\n\n\t\t\treturn [];\n\t\t},\n\n\t\tgetDatasetAtEvent: function(e) {\n\t\t\treturn Chart.Interaction.modes.dataset(this, e, {intersect: true});\n\t\t},\n\n\t\tgetDatasetMeta: function(datasetIndex) {\n\t\t\tvar me = this;\n\t\t\tvar dataset = me.data.datasets[datasetIndex];\n\t\t\tif (!dataset._meta) {\n\t\t\t\tdataset._meta = {};\n\t\t\t}\n\n\t\t\tvar meta = dataset._meta[me.id];\n\t\t\tif (!meta) {\n\t\t\t\tmeta = dataset._meta[me.id] = {\n\t\t\t\t\ttype: null,\n\t\t\t\t\tdata: [],\n\t\t\t\t\tdataset: null,\n\t\t\t\t\tcontroller: null,\n\t\t\t\t\thidden: null,\t\t\t// See isDatasetVisible() comment\n\t\t\t\t\txAxisID: null,\n\t\t\t\t\tyAxisID: null\n\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn meta;\n\t\t},\n\n\t\tgetVisibleDatasetCount: function() {\n\t\t\tvar count = 0;\n\t\t\tfor (var i = 0, ilen = this.data.datasets.length; i<ilen; ++i) {\n\t\t\t\tif (this.isDatasetVisible(i)) {\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn count;\n\t\t},\n\n\t\tisDatasetVisible: function(datasetIndex) {\n\t\t\tvar meta = this.getDatasetMeta(datasetIndex);\n\n\t\t\t// meta.hidden is a per chart dataset hidden flag override with 3 states: if true or false,\n\t\t\t// the dataset.hidden value is ignored, else if null, the dataset hidden state is returned.\n\t\t\treturn typeof meta.hidden === 'boolean'? !meta.hidden : !this.data.datasets[datasetIndex].hidden;\n\t\t},\n\n\t\tgenerateLegend: function() {\n\t\t\treturn this.options.legendCallback(this);\n\t\t},\n\n\t\tdestroy: function() {\n\t\t\tvar me = this;\n\t\t\tvar canvas = me.chart.canvas;\n\t\t\tvar meta, i, ilen;\n\n\t\t\tme.stop();\n\n\t\t\t// dataset controllers need to cleanup associated data\n\t\t\tfor (i = 0, ilen = me.data.datasets.length; i < ilen; ++i) {\n\t\t\t\tmeta = me.getDatasetMeta(i);\n\t\t\t\tif (meta.controller) {\n\t\t\t\t\tmeta.controller.destroy();\n\t\t\t\t\tmeta.controller = null;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (canvas) {\n\t\t\t\tme.unbindEvents();\n\t\t\t\thelpers.clear(me.chart);\n\t\t\t\tplatform.releaseContext(me.chart.ctx);\n\t\t\t\tme.chart.canvas = null;\n\t\t\t\tme.chart.ctx = null;\n\t\t\t}\n\n\t\t\tplugins.notify(me, 'destroy');\n\n\t\t\tdelete Chart.instances[me.id];\n\t\t},\n\n\t\ttoBase64Image: function() {\n\t\t\treturn this.chart.canvas.toDataURL.apply(this.chart.canvas, arguments);\n\t\t},\n\n\t\tinitToolTip: function() {\n\t\t\tvar me = this;\n\t\t\tme.tooltip = new Chart.Tooltip({\n\t\t\t\t_chart: me.chart,\n\t\t\t\t_chartInstance: me,\n\t\t\t\t_data: me.data,\n\t\t\t\t_options: me.options.tooltips\n\t\t\t}, me);\n\t\t\tme.tooltip.initialize();\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tbindEvents: function() {\n\t\t\tvar me = this;\n\t\t\tvar listeners = me._listeners = {};\n\t\t\tvar listener = function() {\n\t\t\t\tme.eventHandler.apply(me, arguments);\n\t\t\t};\n\n\t\t\thelpers.each(me.options.events, function(type) {\n\t\t\t\tplatform.addEventListener(me, type, listener);\n\t\t\t\tlisteners[type] = listener;\n\t\t\t});\n\n\t\t\t// Responsiveness is currently based on the use of an iframe, however this method causes\n\t\t\t// performance issues and could be troublesome when used with ad blockers. So make sure\n\t\t\t// that the user is still able to create a chart without iframe when responsive is false.\n\t\t\t// See https://github.com/chartjs/Chart.js/issues/2210\n\t\t\tif (me.options.responsive) {\n\t\t\t\tlistener = function() {\n\t\t\t\t\tme.resize();\n\t\t\t\t};\n\n\t\t\t\tplatform.addEventListener(me, 'resize', listener);\n\t\t\t\tlisteners.resize = listener;\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tunbindEvents: function() {\n\t\t\tvar me = this;\n\t\t\tvar listeners = me._listeners;\n\t\t\tif (!listeners) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tdelete me._listeners;\n\t\t\thelpers.each(listeners, function(listener, type) {\n\t\t\t\tplatform.removeEventListener(me, type, listener);\n\t\t\t});\n\t\t},\n\n\t\tupdateHoverStyle: function(elements, mode, enabled) {\n\t\t\tvar method = enabled? 'setHoverStyle' : 'removeHoverStyle';\n\t\t\tvar element, i, ilen;\n\n\t\t\tfor (i=0, ilen=elements.length; i<ilen; ++i) {\n\t\t\t\telement = elements[i];\n\t\t\t\tif (element) {\n\t\t\t\t\tthis.getDatasetMeta(element._datasetIndex).controller[method](element);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\teventHandler: function(e) {\n\t\t\tvar me = this;\n\t\t\tvar tooltip = me.tooltip;\n\n\t\t\tif (plugins.notify(me, 'beforeEvent', [e]) === false) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Buffer any update calls so that renders do not occur\n\t\t\tme._bufferedRender = true;\n\t\t\tme._bufferedRequest = null;\n\n\t\t\tvar changed = me.handleEvent(e);\n\t\t\tchanged |= tooltip && tooltip.handleEvent(e);\n\n\t\t\tplugins.notify(me, 'afterEvent', [e]);\n\n\t\t\tvar bufferedRequest = me._bufferedRequest;\n\t\t\tif (bufferedRequest) {\n\t\t\t\t// If we have an update that was triggered, we need to do a normal render\n\t\t\t\tme.render(bufferedRequest.duration, bufferedRequest.lazy);\n\t\t\t} else if (changed && !me.animating) {\n\t\t\t\t// If entering, leaving, or changing elements, animate the change via pivot\n\t\t\t\tme.stop();\n\n\t\t\t\t// We only need to render at this point. Updating will cause scales to be\n\t\t\t\t// recomputed generating flicker & using more memory than necessary.\n\t\t\t\tme.render(me.options.hover.animationDuration, true);\n\t\t\t}\n\n\t\t\tme._bufferedRender = false;\n\t\t\tme._bufferedRequest = null;\n\n\t\t\treturn me;\n\t\t},\n\n\t\t/**\n\t\t * Handle an event\n\t\t * @private\n\t\t * @param {IEvent} event the event to handle\n\t\t * @return {Boolean} true if the chart needs to re-render\n\t\t */\n\t\thandleEvent: function(e) {\n\t\t\tvar me = this;\n\t\t\tvar options = me.options || {};\n\t\t\tvar hoverOptions = options.hover;\n\t\t\tvar changed = false;\n\n\t\t\tme.lastActive = me.lastActive || [];\n\n\t\t\t// Find Active Elements for hover and tooltips\n\t\t\tif (e.type === 'mouseout') {\n\t\t\t\tme.active = [];\n\t\t\t} else {\n\t\t\t\tme.active = me.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions);\n\t\t\t}\n\n\t\t\t// On Hover hook\n\t\t\tif (hoverOptions.onHover) {\n\t\t\t\t// Need to call with native event here to not break backwards compatibility\n\t\t\t\thoverOptions.onHover.call(me, e.native, me.active);\n\t\t\t}\n\n\t\t\tif (e.type === 'mouseup' || e.type === 'click') {\n\t\t\t\tif (options.onClick) {\n\t\t\t\t\t// Use e.native here for backwards compatibility\n\t\t\t\t\toptions.onClick.call(me, e.native, me.active);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Remove styling for last active (even if it may still be active)\n\t\t\tif (me.lastActive.length) {\n\t\t\t\tme.updateHoverStyle(me.lastActive, hoverOptions.mode, false);\n\t\t\t}\n\n\t\t\t// Built in hover styling\n\t\t\tif (me.active.length && hoverOptions.mode) {\n\t\t\t\tme.updateHoverStyle(me.active, hoverOptions.mode, true);\n\t\t\t}\n\n\t\t\tchanged = !helpers.arrayEquals(me.active, me.lastActive);\n\n\t\t\t// Remember Last Actives\n\t\t\tme.lastActive = me.active;\n\n\t\t\treturn changed;\n\t\t}\n\t});\n};\n\n},{}],24:[function(require,module,exports){\n'use strict';\n\nmodule.exports = function(Chart) {\n\n\tvar helpers = Chart.helpers;\n\n\tvar arrayEvents = ['push', 'pop', 'shift', 'splice', 'unshift'];\n\n\t/**\n\t * Hooks the array methods that add or remove values ('push', pop', 'shift', 'splice',\n\t * 'unshift') and notify the listener AFTER the array has been altered. Listeners are\n\t * called on the 'onData*' callbacks (e.g. onDataPush, etc.) with same arguments.\n\t */\n\tfunction listenArrayEvents(array, listener) {\n\t\tif (array._chartjs) {\n\t\t\tarray._chartjs.listeners.push(listener);\n\t\t\treturn;\n\t\t}\n\n\t\tObject.defineProperty(array, '_chartjs', {\n\t\t\tconfigurable: true,\n\t\t\tenumerable: false,\n\t\t\tvalue: {\n\t\t\t\tlisteners: [listener]\n\t\t\t}\n\t\t});\n\n\t\tarrayEvents.forEach(function(key) {\n\t\t\tvar method = 'onData' + key.charAt(0).toUpperCase() + key.slice(1);\n\t\t\tvar base = array[key];\n\n\t\t\tObject.defineProperty(array, key, {\n\t\t\t\tconfigurable: true,\n\t\t\t\tenumerable: false,\n\t\t\t\tvalue: function() {\n\t\t\t\t\tvar args = Array.prototype.slice.call(arguments);\n\t\t\t\t\tvar res = base.apply(this, args);\n\n\t\t\t\t\thelpers.each(array._chartjs.listeners, function(object) {\n\t\t\t\t\t\tif (typeof object[method] === 'function') {\n\t\t\t\t\t\t\tobject[method].apply(object, args);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t\treturn res;\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * Removes the given array event listener and cleanup extra attached properties (such as\n\t * the _chartjs stub and overridden methods) if array doesn't have any more listeners.\n\t */\n\tfunction unlistenArrayEvents(array, listener) {\n\t\tvar stub = array._chartjs;\n\t\tif (!stub) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar listeners = stub.listeners;\n\t\tvar index = listeners.indexOf(listener);\n\t\tif (index !== -1) {\n\t\t\tlisteners.splice(index, 1);\n\t\t}\n\n\t\tif (listeners.length > 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tarrayEvents.forEach(function(key) {\n\t\t\tdelete array[key];\n\t\t});\n\n\t\tdelete array._chartjs;\n\t}\n\n\t// Base class for all dataset controllers (line, bar, etc)\n\tChart.DatasetController = function(chart, datasetIndex) {\n\t\tthis.initialize(chart, datasetIndex);\n\t};\n\n\thelpers.extend(Chart.DatasetController.prototype, {\n\n\t\t/**\n\t\t * Element type used to generate a meta dataset (e.g. Chart.element.Line).\n\t\t * @type {Chart.core.element}\n\t\t */\n\t\tdatasetElementType: null,\n\n\t\t/**\n\t\t * Element type used to generate a meta data (e.g. Chart.element.Point).\n\t\t * @type {Chart.core.element}\n\t\t */\n\t\tdataElementType: null,\n\n\t\tinitialize: function(chart, datasetIndex) {\n\t\t\tvar me = this;\n\t\t\tme.chart = chart;\n\t\t\tme.index = datasetIndex;\n\t\t\tme.linkScales();\n\t\t\tme.addElements();\n\t\t},\n\n\t\tupdateIndex: function(datasetIndex) {\n\t\t\tthis.index = datasetIndex;\n\t\t},\n\n\t\tlinkScales: function() {\n\t\t\tvar me = this;\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar dataset = me.getDataset();\n\n\t\t\tif (meta.xAxisID === null) {\n\t\t\t\tmeta.xAxisID = dataset.xAxisID || me.chart.options.scales.xAxes[0].id;\n\t\t\t}\n\t\t\tif (meta.yAxisID === null) {\n\t\t\t\tmeta.yAxisID = dataset.yAxisID || me.chart.options.scales.yAxes[0].id;\n\t\t\t}\n\t\t},\n\n\t\tgetDataset: function() {\n\t\t\treturn this.chart.data.datasets[this.index];\n\t\t},\n\n\t\tgetMeta: function() {\n\t\t\treturn this.chart.getDatasetMeta(this.index);\n\t\t},\n\n\t\tgetScaleForId: function(scaleID) {\n\t\t\treturn this.chart.scales[scaleID];\n\t\t},\n\n\t\treset: function() {\n\t\t\tthis.update(true);\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tdestroy: function() {\n\t\t\tif (this._data) {\n\t\t\t\tunlistenArrayEvents(this._data, this);\n\t\t\t}\n\t\t},\n\n\t\tcreateMetaDataset: function() {\n\t\t\tvar me = this;\n\t\t\tvar type = me.datasetElementType;\n\t\t\treturn type && new type({\n\t\t\t\t_chart: me.chart.chart,\n\t\t\t\t_datasetIndex: me.index\n\t\t\t});\n\t\t},\n\n\t\tcreateMetaData: function(index) {\n\t\t\tvar me = this;\n\t\t\tvar type = me.dataElementType;\n\t\t\treturn type && new type({\n\t\t\t\t_chart: me.chart.chart,\n\t\t\t\t_datasetIndex: me.index,\n\t\t\t\t_index: index\n\t\t\t});\n\t\t},\n\n\t\taddElements: function() {\n\t\t\tvar me = this;\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar data = me.getDataset().data || [];\n\t\t\tvar metaData = meta.data;\n\t\t\tvar i, ilen;\n\n\t\t\tfor (i=0, ilen=data.length; i<ilen; ++i) {\n\t\t\t\tmetaData[i] = metaData[i] || me.createMetaData(i);\n\t\t\t}\n\n\t\t\tmeta.dataset = meta.dataset || me.createMetaDataset();\n\t\t},\n\n\t\taddElementAndReset: function(index) {\n\t\t\tvar element = this.createMetaData(index);\n\t\t\tthis.getMeta().data.splice(index, 0, element);\n\t\t\tthis.updateElement(element, index, true);\n\t\t},\n\n\t\tbuildOrUpdateElements: function() {\n\t\t\tvar me = this;\n\t\t\tvar dataset = me.getDataset();\n\t\t\tvar data = dataset.data || (dataset.data = []);\n\n\t\t\t// In order to correctly handle data addition/deletion animation (an thus simulate\n\t\t\t// real-time charts), we need to monitor these data modifications and synchronize\n\t\t\t// the internal meta data accordingly.\n\t\t\tif (me._data !== data) {\n\t\t\t\tif (me._data) {\n\t\t\t\t\t// This case happens when the user replaced the data array instance.\n\t\t\t\t\tunlistenArrayEvents(me._data, me);\n\t\t\t\t}\n\n\t\t\t\tlistenArrayEvents(data, me);\n\t\t\t\tme._data = data;\n\t\t\t}\n\n\t\t\t// Re-sync meta data in case the user replaced the data array or if we missed\n\t\t\t// any updates and so make sure that we handle number of datapoints changing.\n\t\t\tme.resyncElements();\n\t\t},\n\n\t\tupdate: helpers.noop,\n\n\t\tdraw: function(ease) {\n\t\t\tvar easingDecimal = ease || 1;\n\t\t\tvar i, len;\n\t\t\tvar metaData = this.getMeta().data;\n\t\t\tfor (i = 0, len = metaData.length; i < len; ++i) {\n\t\t\t\tmetaData[i].transition(easingDecimal).draw();\n\t\t\t}\n\t\t},\n\n\t\tremoveHoverStyle: function(element, elementOpts) {\n\t\t\tvar dataset = this.chart.data.datasets[element._datasetIndex],\n\t\t\t\tindex = element._index,\n\t\t\t\tcustom = element.custom || {},\n\t\t\t\tvalueOrDefault = helpers.getValueAtIndexOrDefault,\n\t\t\t\tmodel = element._model;\n\n\t\t\tmodel.backgroundColor = custom.backgroundColor ? custom.backgroundColor : valueOrDefault(dataset.backgroundColor, index, elementOpts.backgroundColor);\n\t\t\tmodel.borderColor = custom.borderColor ? custom.borderColor : valueOrDefault(dataset.borderColor, index, elementOpts.borderColor);\n\t\t\tmodel.borderWidth = custom.borderWidth ? custom.borderWidth : valueOrDefault(dataset.borderWidth, index, elementOpts.borderWidth);\n\t\t},\n\n\t\tsetHoverStyle: function(element) {\n\t\t\tvar dataset = this.chart.data.datasets[element._datasetIndex],\n\t\t\t\tindex = element._index,\n\t\t\t\tcustom = element.custom || {},\n\t\t\t\tvalueOrDefault = helpers.getValueAtIndexOrDefault,\n\t\t\t\tgetHoverColor = helpers.getHoverColor,\n\t\t\t\tmodel = element._model;\n\n\t\t\tmodel.backgroundColor = custom.hoverBackgroundColor ? custom.hoverBackgroundColor : valueOrDefault(dataset.hoverBackgroundColor, index, getHoverColor(model.backgroundColor));\n\t\t\tmodel.borderColor = custom.hoverBorderColor ? custom.hoverBorderColor : valueOrDefault(dataset.hoverBorderColor, index, getHoverColor(model.borderColor));\n\t\t\tmodel.borderWidth = custom.hoverBorderWidth ? custom.hoverBorderWidth : valueOrDefault(dataset.hoverBorderWidth, index, model.borderWidth);\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tresyncElements: function() {\n\t\t\tvar me = this;\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar data = me.getDataset().data;\n\t\t\tvar numMeta = meta.data.length;\n\t\t\tvar numData = data.length;\n\n\t\t\tif (numData < numMeta) {\n\t\t\t\tmeta.data.splice(numData, numMeta - numData);\n\t\t\t} else if (numData > numMeta) {\n\t\t\t\tme.insertElements(numMeta, numData - numMeta);\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tinsertElements: function(start, count) {\n\t\t\tfor (var i=0; i<count; ++i) {\n\t\t\t\tthis.addElementAndReset(start + i);\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tonDataPush: function() {\n\t\t\tthis.insertElements(this.getDataset().data.length-1, arguments.length);\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tonDataPop: function() {\n\t\t\tthis.getMeta().data.pop();\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tonDataShift: function() {\n\t\t\tthis.getMeta().data.shift();\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tonDataSplice: function(start, count) {\n\t\t\tthis.getMeta().data.splice(start, count);\n\t\t\tthis.insertElements(start, arguments.length - 2);\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tonDataUnshift: function() {\n\t\t\tthis.insertElements(0, arguments.length);\n\t\t}\n\t});\n\n\tChart.DatasetController.extend = helpers.inherits;\n};\n\n},{}],25:[function(require,module,exports){\n'use strict';\n\nmodule.exports = function(Chart) {\n\n\tvar helpers = Chart.helpers;\n\n\tChart.elements = {};\n\n\tChart.Element = function(configuration) {\n\t\thelpers.extend(this, configuration);\n\t\tthis.initialize.apply(this, arguments);\n\t};\n\n\thelpers.extend(Chart.Element.prototype, {\n\n\t\tinitialize: function() {\n\t\t\tthis.hidden = false;\n\t\t},\n\n\t\tpivot: function() {\n\t\t\tvar me = this;\n\t\t\tif (!me._view) {\n\t\t\t\tme._view = helpers.clone(me._model);\n\t\t\t}\n\t\t\tme._start = helpers.clone(me._view);\n\t\t\treturn me;\n\t\t},\n\n\t\ttransition: function(ease) {\n\t\t\tvar me = this;\n\n\t\t\tif (!me._view) {\n\t\t\t\tme._view = helpers.clone(me._model);\n\t\t\t}\n\n\t\t\t// No animation -> No Transition\n\t\t\tif (ease === 1) {\n\t\t\t\tme._view = me._model;\n\t\t\t\tme._start = null;\n\t\t\t\treturn me;\n\t\t\t}\n\n\t\t\tif (!me._start) {\n\t\t\t\tme.pivot();\n\t\t\t}\n\n\t\t\thelpers.each(me._model, function(value, key) {\n\n\t\t\t\tif (key[0] === '_') {\n\t\t\t\t\t// Only non-underscored properties\n\t\t\t\t// Init if doesn't exist\n\t\t\t\t} else if (!me._view.hasOwnProperty(key)) {\n\t\t\t\t\tif (typeof value === 'number' && !isNaN(me._view[key])) {\n\t\t\t\t\t\tme._view[key] = value * ease;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tme._view[key] = value;\n\t\t\t\t\t}\n\t\t\t\t// No unnecessary computations\n\t\t\t\t} else if (value === me._view[key]) {\n\t\t\t\t\t// It's the same! Woohoo!\n\t\t\t\t// Color transitions if possible\n\t\t\t\t} else if (typeof value === 'string') {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tvar color = helpers.color(me._model[key]).mix(helpers.color(me._start[key]), ease);\n\t\t\t\t\t\tme._view[key] = color.rgbString();\n\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\tme._view[key] = value;\n\t\t\t\t\t}\n\t\t\t\t// Number transitions\n\t\t\t\t} else if (typeof value === 'number') {\n\t\t\t\t\tvar startVal = me._start[key] !== undefined && isNaN(me._start[key]) === false ? me._start[key] : 0;\n\t\t\t\t\tme._view[key] = ((me._model[key] - startVal) * ease) + startVal;\n\t\t\t\t// Everything else\n\t\t\t\t} else {\n\t\t\t\t\tme._view[key] = value;\n\t\t\t\t}\n\t\t\t}, me);\n\n\t\t\treturn me;\n\t\t},\n\n\t\ttooltipPosition: function() {\n\t\t\treturn {\n\t\t\t\tx: this._model.x,\n\t\t\t\ty: this._model.y\n\t\t\t};\n\t\t},\n\n\t\thasValue: function() {\n\t\t\treturn helpers.isNumber(this._model.x) && helpers.isNumber(this._model.y);\n\t\t}\n\t});\n\n\tChart.Element.extend = helpers.inherits;\n\n};\n\n},{}],26:[function(require,module,exports){\n/* global window: false */\n/* global document: false */\n'use strict';\n\nvar color = require(3);\n\nmodule.exports = function(Chart) {\n\t// Global Chart helpers object for utility methods and classes\n\tvar helpers = Chart.helpers = {};\n\n\t// -- Basic js utility methods\n\thelpers.each = function(loopable, callback, self, reverse) {\n\t\t// Check to see if null or undefined firstly.\n\t\tvar i, len;\n\t\tif (helpers.isArray(loopable)) {\n\t\t\tlen = loopable.length;\n\t\t\tif (reverse) {\n\t\t\t\tfor (i = len - 1; i >= 0; i--) {\n\t\t\t\t\tcallback.call(self, loopable[i], i);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\t\tcallback.call(self, loopable[i], i);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (typeof loopable === 'object') {\n\t\t\tvar keys = Object.keys(loopable);\n\t\t\tlen = keys.length;\n\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\tcallback.call(self, loopable[keys[i]], keys[i]);\n\t\t\t}\n\t\t}\n\t};\n\thelpers.clone = function(obj) {\n\t\tvar objClone = {};\n\t\thelpers.each(obj, function(value, key) {\n\t\t\tif (helpers.isArray(value)) {\n\t\t\t\tobjClone[key] = value.slice(0);\n\t\t\t} else if (typeof value === 'object' && value !== null) {\n\t\t\t\tobjClone[key] = helpers.clone(value);\n\t\t\t} else {\n\t\t\t\tobjClone[key] = value;\n\t\t\t}\n\t\t});\n\t\treturn objClone;\n\t};\n\thelpers.extend = function(base) {\n\t\tvar setFn = function(value, key) {\n\t\t\tbase[key] = value;\n\t\t};\n\t\tfor (var i = 1, ilen = arguments.length; i < ilen; i++) {\n\t\t\thelpers.each(arguments[i], setFn);\n\t\t}\n\t\treturn base;\n\t};\n\t// Need a special merge function to chart configs since they are now grouped\n\thelpers.configMerge = function(_base) {\n\t\tvar base = helpers.clone(_base);\n\t\thelpers.each(Array.prototype.slice.call(arguments, 1), function(extension) {\n\t\t\thelpers.each(extension, function(value, key) {\n\t\t\t\tvar baseHasProperty = base.hasOwnProperty(key);\n\t\t\t\tvar baseVal = baseHasProperty ? base[key] : {};\n\n\t\t\t\tif (key === 'scales') {\n\t\t\t\t\t// Scale config merging is complex. Add our own function here for that\n\t\t\t\t\tbase[key] = helpers.scaleMerge(baseVal, value);\n\t\t\t\t} else if (key === 'scale') {\n\t\t\t\t\t// Used in polar area & radar charts since there is only one scale\n\t\t\t\t\tbase[key] = helpers.configMerge(baseVal, Chart.scaleService.getScaleDefaults(value.type), value);\n\t\t\t\t} else if (baseHasProperty\n\t\t\t\t\t\t&& typeof baseVal === 'object'\n\t\t\t\t\t\t&& !helpers.isArray(baseVal)\n\t\t\t\t\t\t&& baseVal !== null\n\t\t\t\t\t\t&& typeof value === 'object'\n\t\t\t\t\t\t&& !helpers.isArray(value)) {\n\t\t\t\t\t// If we are overwriting an object with an object, do a merge of the properties.\n\t\t\t\t\tbase[key] = helpers.configMerge(baseVal, value);\n\t\t\t\t} else {\n\t\t\t\t\t// can just overwrite the value in this case\n\t\t\t\t\tbase[key] = value;\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\n\t\treturn base;\n\t};\n\thelpers.scaleMerge = function(_base, extension) {\n\t\tvar base = helpers.clone(_base);\n\n\t\thelpers.each(extension, function(value, key) {\n\t\t\tif (key === 'xAxes' || key === 'yAxes') {\n\t\t\t\t// These properties are arrays of items\n\t\t\t\tif (base.hasOwnProperty(key)) {\n\t\t\t\t\thelpers.each(value, function(valueObj, index) {\n\t\t\t\t\t\tvar axisType = helpers.getValueOrDefault(valueObj.type, key === 'xAxes' ? 'category' : 'linear');\n\t\t\t\t\t\tvar axisDefaults = Chart.scaleService.getScaleDefaults(axisType);\n\t\t\t\t\t\tif (index >= base[key].length || !base[key][index].type) {\n\t\t\t\t\t\t\tbase[key].push(helpers.configMerge(axisDefaults, valueObj));\n\t\t\t\t\t\t} else if (valueObj.type && valueObj.type !== base[key][index].type) {\n\t\t\t\t\t\t\t// Type changed. Bring in the new defaults before we bring in valueObj so that valueObj can override the correct scale defaults\n\t\t\t\t\t\t\tbase[key][index] = helpers.configMerge(base[key][index], axisDefaults, valueObj);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Type is the same\n\t\t\t\t\t\t\tbase[key][index] = helpers.configMerge(base[key][index], valueObj);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tbase[key] = [];\n\t\t\t\t\thelpers.each(value, function(valueObj) {\n\t\t\t\t\t\tvar axisType = helpers.getValueOrDefault(valueObj.type, key === 'xAxes' ? 'category' : 'linear');\n\t\t\t\t\t\tbase[key].push(helpers.configMerge(Chart.scaleService.getScaleDefaults(axisType), valueObj));\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t} else if (base.hasOwnProperty(key) && typeof base[key] === 'object' && base[key] !== null && typeof value === 'object') {\n\t\t\t\t// If we are overwriting an object with an object, do a merge of the properties.\n\t\t\t\tbase[key] = helpers.configMerge(base[key], value);\n\n\t\t\t} else {\n\t\t\t\t// can just overwrite the value in this case\n\t\t\t\tbase[key] = value;\n\t\t\t}\n\t\t});\n\n\t\treturn base;\n\t};\n\thelpers.getValueAtIndexOrDefault = function(value, index, defaultValue) {\n\t\tif (value === undefined || value === null) {\n\t\t\treturn defaultValue;\n\t\t}\n\n\t\tif (helpers.isArray(value)) {\n\t\t\treturn index < value.length ? value[index] : defaultValue;\n\t\t}\n\n\t\treturn value;\n\t};\n\thelpers.getValueOrDefault = function(value, defaultValue) {\n\t\treturn value === undefined ? defaultValue : value;\n\t};\n\thelpers.indexOf = Array.prototype.indexOf?\n\t\tfunction(array, item) {\n\t\t\treturn array.indexOf(item);\n\t\t}:\n\t\tfunction(array, item) {\n\t\t\tfor (var i = 0, ilen = array.length; i < ilen; ++i) {\n\t\t\t\tif (array[i] === item) {\n\t\t\t\t\treturn i;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn -1;\n\t\t};\n\thelpers.where = function(collection, filterCallback) {\n\t\tif (helpers.isArray(collection) && Array.prototype.filter) {\n\t\t\treturn collection.filter(filterCallback);\n\t\t}\n\t\tvar filtered = [];\n\n\t\thelpers.each(collection, function(item) {\n\t\t\tif (filterCallback(item)) {\n\t\t\t\tfiltered.push(item);\n\t\t\t}\n\t\t});\n\n\t\treturn filtered;\n\t};\n\thelpers.findIndex = Array.prototype.findIndex?\n\t\tfunction(array, callback, scope) {\n\t\t\treturn array.findIndex(callback, scope);\n\t\t} :\n\t\tfunction(array, callback, scope) {\n\t\t\tscope = scope === undefined? array : scope;\n\t\t\tfor (var i = 0, ilen = array.length; i < ilen; ++i) {\n\t\t\t\tif (callback.call(scope, array[i], i, array)) {\n\t\t\t\t\treturn i;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn -1;\n\t\t};\n\thelpers.findNextWhere = function(arrayToSearch, filterCallback, startIndex) {\n\t\t// Default to start of the array\n\t\tif (startIndex === undefined || startIndex === null) {\n\t\t\tstartIndex = -1;\n\t\t}\n\t\tfor (var i = startIndex + 1; i < arrayToSearch.length; i++) {\n\t\t\tvar currentItem = arrayToSearch[i];\n\t\t\tif (filterCallback(currentItem)) {\n\t\t\t\treturn currentItem;\n\t\t\t}\n\t\t}\n\t};\n\thelpers.findPreviousWhere = function(arrayToSearch, filterCallback, startIndex) {\n\t\t// Default to end of the array\n\t\tif (startIndex === undefined || startIndex === null) {\n\t\t\tstartIndex = arrayToSearch.length;\n\t\t}\n\t\tfor (var i = startIndex - 1; i >= 0; i--) {\n\t\t\tvar currentItem = arrayToSearch[i];\n\t\t\tif (filterCallback(currentItem)) {\n\t\t\t\treturn currentItem;\n\t\t\t}\n\t\t}\n\t};\n\thelpers.inherits = function(extensions) {\n\t\t// Basic javascript inheritance based on the model created in Backbone.js\n\t\tvar me = this;\n\t\tvar ChartElement = (extensions && extensions.hasOwnProperty('constructor')) ? extensions.constructor : function() {\n\t\t\treturn me.apply(this, arguments);\n\t\t};\n\n\t\tvar Surrogate = function() {\n\t\t\tthis.constructor = ChartElement;\n\t\t};\n\t\tSurrogate.prototype = me.prototype;\n\t\tChartElement.prototype = new Surrogate();\n\n\t\tChartElement.extend = helpers.inherits;\n\n\t\tif (extensions) {\n\t\t\thelpers.extend(ChartElement.prototype, extensions);\n\t\t}\n\n\t\tChartElement.__super__ = me.prototype;\n\n\t\treturn ChartElement;\n\t};\n\thelpers.noop = function() {};\n\thelpers.uid = (function() {\n\t\tvar id = 0;\n\t\treturn function() {\n\t\t\treturn id++;\n\t\t};\n\t}());\n\t// -- Math methods\n\thelpers.isNumber = function(n) {\n\t\treturn !isNaN(parseFloat(n)) && isFinite(n);\n\t};\n\thelpers.almostEquals = function(x, y, epsilon) {\n\t\treturn Math.abs(x - y) < epsilon;\n\t};\n\thelpers.almostWhole = function(x, epsilon) {\n\t\tvar rounded = Math.round(x);\n\t\treturn (((rounded - epsilon) < x) && ((rounded + epsilon) > x));\n\t};\n\thelpers.max = function(array) {\n\t\treturn array.reduce(function(max, value) {\n\t\t\tif (!isNaN(value)) {\n\t\t\t\treturn Math.max(max, value);\n\t\t\t}\n\t\t\treturn max;\n\t\t}, Number.NEGATIVE_INFINITY);\n\t};\n\thelpers.min = function(array) {\n\t\treturn array.reduce(function(min, value) {\n\t\t\tif (!isNaN(value)) {\n\t\t\t\treturn Math.min(min, value);\n\t\t\t}\n\t\t\treturn min;\n\t\t}, Number.POSITIVE_INFINITY);\n\t};\n\thelpers.sign = Math.sign?\n\t\tfunction(x) {\n\t\t\treturn Math.sign(x);\n\t\t} :\n\t\tfunction(x) {\n\t\t\tx = +x; // convert to a number\n\t\t\tif (x === 0 || isNaN(x)) {\n\t\t\t\treturn x;\n\t\t\t}\n\t\t\treturn x > 0 ? 1 : -1;\n\t\t};\n\thelpers.log10 = Math.log10?\n\t\tfunction(x) {\n\t\t\treturn Math.log10(x);\n\t\t} :\n\t\tfunction(x) {\n\t\t\treturn Math.log(x) / Math.LN10;\n\t\t};\n\thelpers.toRadians = function(degrees) {\n\t\treturn degrees * (Math.PI / 180);\n\t};\n\thelpers.toDegrees = function(radians) {\n\t\treturn radians * (180 / Math.PI);\n\t};\n\t// Gets the angle from vertical upright to the point about a centre.\n\thelpers.getAngleFromPoint = function(centrePoint, anglePoint) {\n\t\tvar distanceFromXCenter = anglePoint.x - centrePoint.x,\n\t\t\tdistanceFromYCenter = anglePoint.y - centrePoint.y,\n\t\t\tradialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);\n\n\t\tvar angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);\n\n\t\tif (angle < (-0.5 * Math.PI)) {\n\t\t\tangle += 2.0 * Math.PI; // make sure the returned angle is in the range of (-PI/2, 3PI/2]\n\t\t}\n\n\t\treturn {\n\t\t\tangle: angle,\n\t\t\tdistance: radialDistanceFromCenter\n\t\t};\n\t};\n\thelpers.distanceBetweenPoints = function(pt1, pt2) {\n\t\treturn Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));\n\t};\n\thelpers.aliasPixel = function(pixelWidth) {\n\t\treturn (pixelWidth % 2 === 0) ? 0 : 0.5;\n\t};\n\thelpers.splineCurve = function(firstPoint, middlePoint, afterPoint, t) {\n\t\t// Props to Rob Spencer at scaled innovation for his post on splining between points\n\t\t// http://scaledinnovation.com/analytics/splines/aboutSplines.html\n\n\t\t// This function must also respect \"skipped\" points\n\n\t\tvar previous = firstPoint.skip ? middlePoint : firstPoint,\n\t\t\tcurrent = middlePoint,\n\t\t\tnext = afterPoint.skip ? middlePoint : afterPoint;\n\n\t\tvar d01 = Math.sqrt(Math.pow(current.x - previous.x, 2) + Math.pow(current.y - previous.y, 2));\n\t\tvar d12 = Math.sqrt(Math.pow(next.x - current.x, 2) + Math.pow(next.y - current.y, 2));\n\n\t\tvar s01 = d01 / (d01 + d12);\n\t\tvar s12 = d12 / (d01 + d12);\n\n\t\t// If all points are the same, s01 & s02 will be inf\n\t\ts01 = isNaN(s01) ? 0 : s01;\n\t\ts12 = isNaN(s12) ? 0 : s12;\n\n\t\tvar fa = t * s01; // scaling factor for triangle Ta\n\t\tvar fb = t * s12;\n\n\t\treturn {\n\t\t\tprevious: {\n\t\t\t\tx: current.x - fa * (next.x - previous.x),\n\t\t\t\ty: current.y - fa * (next.y - previous.y)\n\t\t\t},\n\t\t\tnext: {\n\t\t\t\tx: current.x + fb * (next.x - previous.x),\n\t\t\t\ty: current.y + fb * (next.y - previous.y)\n\t\t\t}\n\t\t};\n\t};\n\thelpers.EPSILON = Number.EPSILON || 1e-14;\n\thelpers.splineCurveMonotone = function(points) {\n\t\t// This function calculates Bézier control points in a similar way than |splineCurve|,\n\t\t// but preserves monotonicity of the provided data and ensures no local extremums are added\n\t\t// between the dataset discrete points due to the interpolation.\n\t\t// See : https://en.wikipedia.org/wiki/Monotone_cubic_interpolation\n\n\t\tvar pointsWithTangents = (points || []).map(function(point) {\n\t\t\treturn {\n\t\t\t\tmodel: point._model,\n\t\t\t\tdeltaK: 0,\n\t\t\t\tmK: 0\n\t\t\t};\n\t\t});\n\n\t\t// Calculate slopes (deltaK) and initialize tangents (mK)\n\t\tvar pointsLen = pointsWithTangents.length;\n\t\tvar i, pointBefore, pointCurrent, pointAfter;\n\t\tfor (i = 0; i < pointsLen; ++i) {\n\t\t\tpointCurrent = pointsWithTangents[i];\n\t\t\tif (pointCurrent.model.skip) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tpointBefore = i > 0 ? pointsWithTangents[i - 1] : null;\n\t\t\tpointAfter = i < pointsLen - 1 ? pointsWithTangents[i + 1] : null;\n\t\t\tif (pointAfter && !pointAfter.model.skip) {\n\t\t\t\tvar slopeDeltaX = (pointAfter.model.x - pointCurrent.model.x);\n\n\t\t\t\t// In the case of two points that appear at the same x pixel, slopeDeltaX is 0\n\t\t\t\tpointCurrent.deltaK = slopeDeltaX !== 0 ? (pointAfter.model.y - pointCurrent.model.y) / slopeDeltaX : 0;\n\t\t\t}\n\n\t\t\tif (!pointBefore || pointBefore.model.skip) {\n\t\t\t\tpointCurrent.mK = pointCurrent.deltaK;\n\t\t\t} else if (!pointAfter || pointAfter.model.skip) {\n\t\t\t\tpointCurrent.mK = pointBefore.deltaK;\n\t\t\t} else if (this.sign(pointBefore.deltaK) !== this.sign(pointCurrent.deltaK)) {\n\t\t\t\tpointCurrent.mK = 0;\n\t\t\t} else {\n\t\t\t\tpointCurrent.mK = (pointBefore.deltaK + pointCurrent.deltaK) / 2;\n\t\t\t}\n\t\t}\n\n\t\t// Adjust tangents to ensure monotonic properties\n\t\tvar alphaK, betaK, tauK, squaredMagnitude;\n\t\tfor (i = 0; i < pointsLen - 1; ++i) {\n\t\t\tpointCurrent = pointsWithTangents[i];\n\t\t\tpointAfter = pointsWithTangents[i + 1];\n\t\t\tif (pointCurrent.model.skip || pointAfter.model.skip) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (helpers.almostEquals(pointCurrent.deltaK, 0, this.EPSILON)) {\n\t\t\t\tpointCurrent.mK = pointAfter.mK = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\talphaK = pointCurrent.mK / pointCurrent.deltaK;\n\t\t\tbetaK = pointAfter.mK / pointCurrent.deltaK;\n\t\t\tsquaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);\n\t\t\tif (squaredMagnitude <= 9) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\ttauK = 3 / Math.sqrt(squaredMagnitude);\n\t\t\tpointCurrent.mK = alphaK * tauK * pointCurrent.deltaK;\n\t\t\tpointAfter.mK = betaK * tauK * pointCurrent.deltaK;\n\t\t}\n\n\t\t// Compute control points\n\t\tvar deltaX;\n\t\tfor (i = 0; i < pointsLen; ++i) {\n\t\t\tpointCurrent = pointsWithTangents[i];\n\t\t\tif (pointCurrent.model.skip) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tpointBefore = i > 0 ? pointsWithTangents[i - 1] : null;\n\t\t\tpointAfter = i < pointsLen - 1 ? pointsWithTangents[i + 1] : null;\n\t\t\tif (pointBefore && !pointBefore.model.skip) {\n\t\t\t\tdeltaX = (pointCurrent.model.x - pointBefore.model.x) / 3;\n\t\t\t\tpointCurrent.model.controlPointPreviousX = pointCurrent.model.x - deltaX;\n\t\t\t\tpointCurrent.model.controlPointPreviousY = pointCurrent.model.y - deltaX * pointCurrent.mK;\n\t\t\t}\n\t\t\tif (pointAfter && !pointAfter.model.skip) {\n\t\t\t\tdeltaX = (pointAfter.model.x - pointCurrent.model.x) / 3;\n\t\t\t\tpointCurrent.model.controlPointNextX = pointCurrent.model.x + deltaX;\n\t\t\t\tpointCurrent.model.controlPointNextY = pointCurrent.model.y + deltaX * pointCurrent.mK;\n\t\t\t}\n\t\t}\n\t};\n\thelpers.nextItem = function(collection, index, loop) {\n\t\tif (loop) {\n\t\t\treturn index >= collection.length - 1 ? collection[0] : collection[index + 1];\n\t\t}\n\t\treturn index >= collection.length - 1 ? collection[collection.length - 1] : collection[index + 1];\n\t};\n\thelpers.previousItem = function(collection, index, loop) {\n\t\tif (loop) {\n\t\t\treturn index <= 0 ? collection[collection.length - 1] : collection[index - 1];\n\t\t}\n\t\treturn index <= 0 ? collection[0] : collection[index - 1];\n\t};\n\t// Implementation of the nice number algorithm used in determining where axis labels will go\n\thelpers.niceNum = function(range, round) {\n\t\tvar exponent = Math.floor(helpers.log10(range));\n\t\tvar fraction = range / Math.pow(10, exponent);\n\t\tvar niceFraction;\n\n\t\tif (round) {\n\t\t\tif (fraction < 1.5) {\n\t\t\t\tniceFraction = 1;\n\t\t\t} else if (fraction < 3) {\n\t\t\t\tniceFraction = 2;\n\t\t\t} else if (fraction < 7) {\n\t\t\t\tniceFraction = 5;\n\t\t\t} else {\n\t\t\t\tniceFraction = 10;\n\t\t\t}\n\t\t} else if (fraction <= 1.0) {\n\t\t\tniceFraction = 1;\n\t\t} else if (fraction <= 2) {\n\t\t\tniceFraction = 2;\n\t\t} else if (fraction <= 5) {\n\t\t\tniceFraction = 5;\n\t\t} else {\n\t\t\tniceFraction = 10;\n\t\t}\n\n\t\treturn niceFraction * Math.pow(10, exponent);\n\t};\n\t// Easing functions adapted from Robert Penner's easing equations\n\t// http://www.robertpenner.com/easing/\n\tvar easingEffects = helpers.easingEffects = {\n\t\tlinear: function(t) {\n\t\t\treturn t;\n\t\t},\n\t\teaseInQuad: function(t) {\n\t\t\treturn t * t;\n\t\t},\n\t\teaseOutQuad: function(t) {\n\t\t\treturn -1 * t * (t - 2);\n\t\t},\n\t\teaseInOutQuad: function(t) {\n\t\t\tif ((t /= 1 / 2) < 1) {\n\t\t\t\treturn 1 / 2 * t * t;\n\t\t\t}\n\t\t\treturn -1 / 2 * ((--t) * (t - 2) - 1);\n\t\t},\n\t\teaseInCubic: function(t) {\n\t\t\treturn t * t * t;\n\t\t},\n\t\teaseOutCubic: function(t) {\n\t\t\treturn 1 * ((t = t / 1 - 1) * t * t + 1);\n\t\t},\n\t\teaseInOutCubic: function(t) {\n\t\t\tif ((t /= 1 / 2) < 1) {\n\t\t\t\treturn 1 / 2 * t * t * t;\n\t\t\t}\n\t\t\treturn 1 / 2 * ((t -= 2) * t * t + 2);\n\t\t},\n\t\teaseInQuart: function(t) {\n\t\t\treturn t * t * t * t;\n\t\t},\n\t\teaseOutQuart: function(t) {\n\t\t\treturn -1 * ((t = t / 1 - 1) * t * t * t - 1);\n\t\t},\n\t\teaseInOutQuart: function(t) {\n\t\t\tif ((t /= 1 / 2) < 1) {\n\t\t\t\treturn 1 / 2 * t * t * t * t;\n\t\t\t}\n\t\t\treturn -1 / 2 * ((t -= 2) * t * t * t - 2);\n\t\t},\n\t\teaseInQuint: function(t) {\n\t\t\treturn 1 * (t /= 1) * t * t * t * t;\n\t\t},\n\t\teaseOutQuint: function(t) {\n\t\t\treturn 1 * ((t = t / 1 - 1) * t * t * t * t + 1);\n\t\t},\n\t\teaseInOutQuint: function(t) {\n\t\t\tif ((t /= 1 / 2) < 1) {\n\t\t\t\treturn 1 / 2 * t * t * t * t * t;\n\t\t\t}\n\t\t\treturn 1 / 2 * ((t -= 2) * t * t * t * t + 2);\n\t\t},\n\t\teaseInSine: function(t) {\n\t\t\treturn -1 * Math.cos(t / 1 * (Math.PI / 2)) + 1;\n\t\t},\n\t\teaseOutSine: function(t) {\n\t\t\treturn 1 * Math.sin(t / 1 * (Math.PI / 2));\n\t\t},\n\t\teaseInOutSine: function(t) {\n\t\t\treturn -1 / 2 * (Math.cos(Math.PI * t / 1) - 1);\n\t\t},\n\t\teaseInExpo: function(t) {\n\t\t\treturn (t === 0) ? 1 : 1 * Math.pow(2, 10 * (t / 1 - 1));\n\t\t},\n\t\teaseOutExpo: function(t) {\n\t\t\treturn (t === 1) ? 1 : 1 * (-Math.pow(2, -10 * t / 1) + 1);\n\t\t},\n\t\teaseInOutExpo: function(t) {\n\t\t\tif (t === 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (t === 1) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tif ((t /= 1 / 2) < 1) {\n\t\t\t\treturn 1 / 2 * Math.pow(2, 10 * (t - 1));\n\t\t\t}\n\t\t\treturn 1 / 2 * (-Math.pow(2, -10 * --t) + 2);\n\t\t},\n\t\teaseInCirc: function(t) {\n\t\t\tif (t >= 1) {\n\t\t\t\treturn t;\n\t\t\t}\n\t\t\treturn -1 * (Math.sqrt(1 - (t /= 1) * t) - 1);\n\t\t},\n\t\teaseOutCirc: function(t) {\n\t\t\treturn 1 * Math.sqrt(1 - (t = t / 1 - 1) * t);\n\t\t},\n\t\teaseInOutCirc: function(t) {\n\t\t\tif ((t /= 1 / 2) < 1) {\n\t\t\t\treturn -1 / 2 * (Math.sqrt(1 - t * t) - 1);\n\t\t\t}\n\t\t\treturn 1 / 2 * (Math.sqrt(1 - (t -= 2) * t) + 1);\n\t\t},\n\t\teaseInElastic: function(t) {\n\t\t\tvar s = 1.70158;\n\t\t\tvar p = 0;\n\t\t\tvar a = 1;\n\t\t\tif (t === 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif ((t /= 1) === 1) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tif (!p) {\n\t\t\t\tp = 1 * 0.3;\n\t\t\t}\n\t\t\tif (a < Math.abs(1)) {\n\t\t\t\ta = 1;\n\t\t\t\ts = p / 4;\n\t\t\t} else {\n\t\t\t\ts = p / (2 * Math.PI) * Math.asin(1 / a);\n\t\t\t}\n\t\t\treturn -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * 1 - s) * (2 * Math.PI) / p));\n\t\t},\n\t\teaseOutElastic: function(t) {\n\t\t\tvar s = 1.70158;\n\t\t\tvar p = 0;\n\t\t\tvar a = 1;\n\t\t\tif (t === 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif ((t /= 1) === 1) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tif (!p) {\n\t\t\t\tp = 1 * 0.3;\n\t\t\t}\n\t\t\tif (a < Math.abs(1)) {\n\t\t\t\ta = 1;\n\t\t\t\ts = p / 4;\n\t\t\t} else {\n\t\t\t\ts = p / (2 * Math.PI) * Math.asin(1 / a);\n\t\t\t}\n\t\t\treturn a * Math.pow(2, -10 * t) * Math.sin((t * 1 - s) * (2 * Math.PI) / p) + 1;\n\t\t},\n\t\teaseInOutElastic: function(t) {\n\t\t\tvar s = 1.70158;\n\t\t\tvar p = 0;\n\t\t\tvar a = 1;\n\t\t\tif (t === 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif ((t /= 1 / 2) === 2) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tif (!p) {\n\t\t\t\tp = 1 * (0.3 * 1.5);\n\t\t\t}\n\t\t\tif (a < Math.abs(1)) {\n\t\t\t\ta = 1;\n\t\t\t\ts = p / 4;\n\t\t\t} else {\n\t\t\t\ts = p / (2 * Math.PI) * Math.asin(1 / a);\n\t\t\t}\n\t\t\tif (t < 1) {\n\t\t\t\treturn -0.5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * 1 - s) * (2 * Math.PI) / p));\n\t\t\t}\n\t\t\treturn a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t * 1 - s) * (2 * Math.PI) / p) * 0.5 + 1;\n\t\t},\n\t\teaseInBack: function(t) {\n\t\t\tvar s = 1.70158;\n\t\t\treturn 1 * (t /= 1) * t * ((s + 1) * t - s);\n\t\t},\n\t\teaseOutBack: function(t) {\n\t\t\tvar s = 1.70158;\n\t\t\treturn 1 * ((t = t / 1 - 1) * t * ((s + 1) * t + s) + 1);\n\t\t},\n\t\teaseInOutBack: function(t) {\n\t\t\tvar s = 1.70158;\n\t\t\tif ((t /= 1 / 2) < 1) {\n\t\t\t\treturn 1 / 2 * (t * t * (((s *= (1.525)) + 1) * t - s));\n\t\t\t}\n\t\t\treturn 1 / 2 * ((t -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2);\n\t\t},\n\t\teaseInBounce: function(t) {\n\t\t\treturn 1 - easingEffects.easeOutBounce(1 - t);\n\t\t},\n\t\teaseOutBounce: function(t) {\n\t\t\tif ((t /= 1) < (1 / 2.75)) {\n\t\t\t\treturn 1 * (7.5625 * t * t);\n\t\t\t} else if (t < (2 / 2.75)) {\n\t\t\t\treturn 1 * (7.5625 * (t -= (1.5 / 2.75)) * t + 0.75);\n\t\t\t} else if (t < (2.5 / 2.75)) {\n\t\t\t\treturn 1 * (7.5625 * (t -= (2.25 / 2.75)) * t + 0.9375);\n\t\t\t}\n\t\t\treturn 1 * (7.5625 * (t -= (2.625 / 2.75)) * t + 0.984375);\n\t\t},\n\t\teaseInOutBounce: function(t) {\n\t\t\tif (t < 1 / 2) {\n\t\t\t\treturn easingEffects.easeInBounce(t * 2) * 0.5;\n\t\t\t}\n\t\t\treturn easingEffects.easeOutBounce(t * 2 - 1) * 0.5 + 1 * 0.5;\n\t\t}\n\t};\n\t// Request animation polyfill - http://www.paulirish.com/2011/requestanimationframe-for-smart-animating/\n\thelpers.requestAnimFrame = (function() {\n\t\treturn window.requestAnimationFrame ||\n\t\t\twindow.webkitRequestAnimationFrame ||\n\t\t\twindow.mozRequestAnimationFrame ||\n\t\t\twindow.oRequestAnimationFrame ||\n\t\t\twindow.msRequestAnimationFrame ||\n\t\t\tfunction(callback) {\n\t\t\t\treturn window.setTimeout(callback, 1000 / 60);\n\t\t\t};\n\t}());\n\t// -- DOM methods\n\thelpers.getRelativePosition = function(evt, chart) {\n\t\tvar mouseX, mouseY;\n\t\tvar e = evt.originalEvent || evt,\n\t\t\tcanvas = evt.currentTarget || evt.srcElement,\n\t\t\tboundingRect = canvas.getBoundingClientRect();\n\n\t\tvar touches = e.touches;\n\t\tif (touches && touches.length > 0) {\n\t\t\tmouseX = touches[0].clientX;\n\t\t\tmouseY = touches[0].clientY;\n\n\t\t} else {\n\t\t\tmouseX = e.clientX;\n\t\t\tmouseY = e.clientY;\n\t\t}\n\n\t\t// Scale mouse coordinates into canvas coordinates\n\t\t// by following the pattern laid out by 'jerryj' in the comments of\n\t\t// http://www.html5canvastutorials.com/advanced/html5-canvas-mouse-coordinates/\n\t\tvar paddingLeft = parseFloat(helpers.getStyle(canvas, 'padding-left'));\n\t\tvar paddingTop = parseFloat(helpers.getStyle(canvas, 'padding-top'));\n\t\tvar paddingRight = parseFloat(helpers.getStyle(canvas, 'padding-right'));\n\t\tvar paddingBottom = parseFloat(helpers.getStyle(canvas, 'padding-bottom'));\n\t\tvar width = boundingRect.right - boundingRect.left - paddingLeft - paddingRight;\n\t\tvar height = boundingRect.bottom - boundingRect.top - paddingTop - paddingBottom;\n\n\t\t// We divide by the current device pixel ratio, because the canvas is scaled up by that amount in each direction. However\n\t\t// the backend model is in unscaled coordinates. Since we are going to deal with our model coordinates, we go back here\n\t\tmouseX = Math.round((mouseX - boundingRect.left - paddingLeft) / (width) * canvas.width / chart.currentDevicePixelRatio);\n\t\tmouseY = Math.round((mouseY - boundingRect.top - paddingTop) / (height) * canvas.height / chart.currentDevicePixelRatio);\n\n\t\treturn {\n\t\t\tx: mouseX,\n\t\t\ty: mouseY\n\t\t};\n\n\t};\n\thelpers.addEvent = function(node, eventType, method) {\n\t\tif (node.addEventListener) {\n\t\t\tnode.addEventListener(eventType, method);\n\t\t} else if (node.attachEvent) {\n\t\t\tnode.attachEvent('on' + eventType, method);\n\t\t} else {\n\t\t\tnode['on' + eventType] = method;\n\t\t}\n\t};\n\thelpers.removeEvent = function(node, eventType, handler) {\n\t\tif (node.removeEventListener) {\n\t\t\tnode.removeEventListener(eventType, handler, false);\n\t\t} else if (node.detachEvent) {\n\t\t\tnode.detachEvent('on' + eventType, handler);\n\t\t} else {\n\t\t\tnode['on' + eventType] = helpers.noop;\n\t\t}\n\t};\n\n\t// Private helper function to convert max-width/max-height values that may be percentages into a number\n\tfunction parseMaxStyle(styleValue, node, parentProperty) {\n\t\tvar valueInPixels;\n\t\tif (typeof(styleValue) === 'string') {\n\t\t\tvalueInPixels = parseInt(styleValue, 10);\n\n\t\t\tif (styleValue.indexOf('%') !== -1) {\n\t\t\t\t// percentage * size in dimension\n\t\t\t\tvalueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];\n\t\t\t}\n\t\t} else {\n\t\t\tvalueInPixels = styleValue;\n\t\t}\n\n\t\treturn valueInPixels;\n\t}\n\n\t/**\n\t * Returns if the given value contains an effective constraint.\n\t * @private\n\t */\n\tfunction isConstrainedValue(value) {\n\t\treturn value !== undefined && value !== null && value !== 'none';\n\t}\n\n\t// Private helper to get a constraint dimension\n\t// @param domNode : the node to check the constraint on\n\t// @param maxStyle : the style that defines the maximum for the direction we are using (maxWidth / maxHeight)\n\t// @param percentageProperty : property of parent to use when calculating width as a percentage\n\t// @see http://www.nathanaeljones.com/blog/2013/reading-max-width-cross-browser\n\tfunction getConstraintDimension(domNode, maxStyle, percentageProperty) {\n\t\tvar view = document.defaultView;\n\t\tvar parentNode = domNode.parentNode;\n\t\tvar constrainedNode = view.getComputedStyle(domNode)[maxStyle];\n\t\tvar constrainedContainer = view.getComputedStyle(parentNode)[maxStyle];\n\t\tvar hasCNode = isConstrainedValue(constrainedNode);\n\t\tvar hasCContainer = isConstrainedValue(constrainedContainer);\n\t\tvar infinity = Number.POSITIVE_INFINITY;\n\n\t\tif (hasCNode || hasCContainer) {\n\t\t\treturn Math.min(\n\t\t\t\thasCNode? parseMaxStyle(constrainedNode, domNode, percentageProperty) : infinity,\n\t\t\t\thasCContainer? parseMaxStyle(constrainedContainer, parentNode, percentageProperty) : infinity);\n\t\t}\n\n\t\treturn 'none';\n\t}\n\t// returns Number or undefined if no constraint\n\thelpers.getConstraintWidth = function(domNode) {\n\t\treturn getConstraintDimension(domNode, 'max-width', 'clientWidth');\n\t};\n\t// returns Number or undefined if no constraint\n\thelpers.getConstraintHeight = function(domNode) {\n\t\treturn getConstraintDimension(domNode, 'max-height', 'clientHeight');\n\t};\n\thelpers.getMaximumWidth = function(domNode) {\n\t\tvar container = domNode.parentNode;\n\t\tvar paddingLeft = parseInt(helpers.getStyle(container, 'padding-left'), 10);\n\t\tvar paddingRight = parseInt(helpers.getStyle(container, 'padding-right'), 10);\n\t\tvar w = container.clientWidth - paddingLeft - paddingRight;\n\t\tvar cw = helpers.getConstraintWidth(domNode);\n\t\treturn isNaN(cw)? w : Math.min(w, cw);\n\t};\n\thelpers.getMaximumHeight = function(domNode) {\n\t\tvar container = domNode.parentNode;\n\t\tvar paddingTop = parseInt(helpers.getStyle(container, 'padding-top'), 10);\n\t\tvar paddingBottom = parseInt(helpers.getStyle(container, 'padding-bottom'), 10);\n\t\tvar h = container.clientHeight - paddingTop - paddingBottom;\n\t\tvar ch = helpers.getConstraintHeight(domNode);\n\t\treturn isNaN(ch)? h : Math.min(h, ch);\n\t};\n\thelpers.getStyle = function(el, property) {\n\t\treturn el.currentStyle ?\n\t\t\tel.currentStyle[property] :\n\t\t\tdocument.defaultView.getComputedStyle(el, null).getPropertyValue(property);\n\t};\n\thelpers.retinaScale = function(chart) {\n\t\tvar pixelRatio = chart.currentDevicePixelRatio = window.devicePixelRatio || 1;\n\t\tif (pixelRatio === 1) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar canvas = chart.canvas;\n\t\tvar height = chart.height;\n\t\tvar width = chart.width;\n\n\t\tcanvas.height = height * pixelRatio;\n\t\tcanvas.width = width * pixelRatio;\n\t\tchart.ctx.scale(pixelRatio, pixelRatio);\n\n\t\t// If no style has been set on the canvas, the render size is used as display size,\n\t\t// making the chart visually bigger, so let's enforce it to the \"correct\" values.\n\t\t// See https://github.com/chartjs/Chart.js/issues/3575\n\t\tcanvas.style.height = height + 'px';\n\t\tcanvas.style.width = width + 'px';\n\t};\n\t// -- Canvas methods\n\thelpers.clear = function(chart) {\n\t\tchart.ctx.clearRect(0, 0, chart.width, chart.height);\n\t};\n\thelpers.fontString = function(pixelSize, fontStyle, fontFamily) {\n\t\treturn fontStyle + ' ' + pixelSize + 'px ' + fontFamily;\n\t};\n\thelpers.longestText = function(ctx, font, arrayOfThings, cache) {\n\t\tcache = cache || {};\n\t\tvar data = cache.data = cache.data || {};\n\t\tvar gc = cache.garbageCollect = cache.garbageCollect || [];\n\n\t\tif (cache.font !== font) {\n\t\t\tdata = cache.data = {};\n\t\t\tgc = cache.garbageCollect = [];\n\t\t\tcache.font = font;\n\t\t}\n\n\t\tctx.font = font;\n\t\tvar longest = 0;\n\t\thelpers.each(arrayOfThings, function(thing) {\n\t\t\t// Undefined strings and arrays should not be measured\n\t\t\tif (thing !== undefined && thing !== null && helpers.isArray(thing) !== true) {\n\t\t\t\tlongest = helpers.measureText(ctx, data, gc, longest, thing);\n\t\t\t} else if (helpers.isArray(thing)) {\n\t\t\t\t// if it is an array lets measure each element\n\t\t\t\t// to do maybe simplify this function a bit so we can do this more recursively?\n\t\t\t\thelpers.each(thing, function(nestedThing) {\n\t\t\t\t\t// Undefined strings and arrays should not be measured\n\t\t\t\t\tif (nestedThing !== undefined && nestedThing !== null && !helpers.isArray(nestedThing)) {\n\t\t\t\t\t\tlongest = helpers.measureText(ctx, data, gc, longest, nestedThing);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\n\t\tvar gcLen = gc.length / 2;\n\t\tif (gcLen > arrayOfThings.length) {\n\t\t\tfor (var i = 0; i < gcLen; i++) {\n\t\t\t\tdelete data[gc[i]];\n\t\t\t}\n\t\t\tgc.splice(0, gcLen);\n\t\t}\n\t\treturn longest;\n\t};\n\thelpers.measureText = function(ctx, data, gc, longest, string) {\n\t\tvar textWidth = data[string];\n\t\tif (!textWidth) {\n\t\t\ttextWidth = data[string] = ctx.measureText(string).width;\n\t\t\tgc.push(string);\n\t\t}\n\t\tif (textWidth > longest) {\n\t\t\tlongest = textWidth;\n\t\t}\n\t\treturn longest;\n\t};\n\thelpers.numberOfLabelLines = function(arrayOfThings) {\n\t\tvar numberOfLines = 1;\n\t\thelpers.each(arrayOfThings, function(thing) {\n\t\t\tif (helpers.isArray(thing)) {\n\t\t\t\tif (thing.length > numberOfLines) {\n\t\t\t\t\tnumberOfLines = thing.length;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\treturn numberOfLines;\n\t};\n\thelpers.drawRoundedRectangle = function(ctx, x, y, width, height, radius) {\n\t\tctx.beginPath();\n\t\tctx.moveTo(x + radius, y);\n\t\tctx.lineTo(x + width - radius, y);\n\t\tctx.quadraticCurveTo(x + width, y, x + width, y + radius);\n\t\tctx.lineTo(x + width, y + height - radius);\n\t\tctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);\n\t\tctx.lineTo(x + radius, y + height);\n\t\tctx.quadraticCurveTo(x, y + height, x, y + height - radius);\n\t\tctx.lineTo(x, y + radius);\n\t\tctx.quadraticCurveTo(x, y, x + radius, y);\n\t\tctx.closePath();\n\t};\n\thelpers.color = function(c) {\n\t\tif (!color) {\n\t\t\tconsole.error('Color.js not found!');\n\t\t\treturn c;\n\t\t}\n\n\t\t/* global CanvasGradient */\n\t\tif (c instanceof CanvasGradient) {\n\t\t\treturn color(Chart.defaults.global.defaultColor);\n\t\t}\n\n\t\treturn color(c);\n\t};\n\thelpers.isArray = Array.isArray?\n\t\tfunction(obj) {\n\t\t\treturn Array.isArray(obj);\n\t\t} :\n\t\tfunction(obj) {\n\t\t\treturn Object.prototype.toString.call(obj) === '[object Array]';\n\t\t};\n\t// ! @see http://stackoverflow.com/a/14853974\n\thelpers.arrayEquals = function(a0, a1) {\n\t\tvar i, ilen, v0, v1;\n\n\t\tif (!a0 || !a1 || a0.length !== a1.length) {\n\t\t\treturn false;\n\t\t}\n\n\t\tfor (i = 0, ilen=a0.length; i < ilen; ++i) {\n\t\t\tv0 = a0[i];\n\t\t\tv1 = a1[i];\n\n\t\t\tif (v0 instanceof Array && v1 instanceof Array) {\n\t\t\t\tif (!helpers.arrayEquals(v0, v1)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t} else if (v0 !== v1) {\n\t\t\t\t// NOTE: two different object instances will never be equal: {x:20} != {x:20}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t};\n\thelpers.callCallback = function(fn, args, _tArg) {\n\t\tif (fn && typeof fn.call === 'function') {\n\t\t\tfn.apply(_tArg, args);\n\t\t}\n\t};\n\thelpers.getHoverColor = function(colorValue) {\n\t\t/* global CanvasPattern */\n\t\treturn (colorValue instanceof CanvasPattern) ?\n\t\t\tcolorValue :\n\t\t\thelpers.color(colorValue).saturate(0.5).darken(0.1).rgbString();\n\t};\n};\n\n},{\"3\":3}],27:[function(require,module,exports){\n'use strict';\n\nmodule.exports = function(Chart) {\n\tvar helpers = Chart.helpers;\n\n\t/**\n\t * Helper function to get relative position for an event\n\t * @param {Event|IEvent} event - The event to get the position for\n\t * @param {Chart} chart - The chart\n\t * @returns {Point} the event position\n\t */\n\tfunction getRelativePosition(e, chart) {\n\t\tif (e.native) {\n\t\t\treturn {\n\t\t\t\tx: e.x,\n\t\t\t\ty: e.y\n\t\t\t};\n\t\t}\n\n\t\treturn helpers.getRelativePosition(e, chart);\n\t}\n\n\t/**\n\t * Helper function to traverse all of the visible elements in the chart\n\t * @param chart {chart} the chart\n\t * @param handler {Function} the callback to execute for each visible item\n\t */\n\tfunction parseVisibleItems(chart, handler) {\n\t\tvar datasets = chart.data.datasets;\n\t\tvar meta, i, j, ilen, jlen;\n\n\t\tfor (i = 0, ilen = datasets.length; i < ilen; ++i) {\n\t\t\tif (!chart.isDatasetVisible(i)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tmeta = chart.getDatasetMeta(i);\n\t\t\tfor (j = 0, jlen = meta.data.length; j < jlen; ++j) {\n\t\t\t\tvar element = meta.data[j];\n\t\t\t\tif (!element._view.skip) {\n\t\t\t\t\thandler(element);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Helper function to get the items that intersect the event position\n\t * @param items {ChartElement[]} elements to filter\n\t * @param position {Point} the point to be nearest to\n\t * @return {ChartElement[]} the nearest items\n\t */\n\tfunction getIntersectItems(chart, position) {\n\t\tvar elements = [];\n\n\t\tparseVisibleItems(chart, function(element) {\n\t\t\tif (element.inRange(position.x, position.y)) {\n\t\t\t\telements.push(element);\n\t\t\t}\n\t\t});\n\n\t\treturn elements;\n\t}\n\n\t/**\n\t * Helper function to get the items nearest to the event position considering all visible items in teh chart\n\t * @param chart {Chart} the chart to look at elements from\n\t * @param position {Point} the point to be nearest to\n\t * @param intersect {Boolean} if true, only consider items that intersect the position\n\t * @param distanceMetric {Function} Optional function to provide the distance between\n\t * @return {ChartElement[]} the nearest items\n\t */\n\tfunction getNearestItems(chart, position, intersect, distanceMetric) {\n\t\tvar minDistance = Number.POSITIVE_INFINITY;\n\t\tvar nearestItems = [];\n\n\t\tif (!distanceMetric) {\n\t\t\tdistanceMetric = helpers.distanceBetweenPoints;\n\t\t}\n\n\t\tparseVisibleItems(chart, function(element) {\n\t\t\tif (intersect && !element.inRange(position.x, position.y)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar center = element.getCenterPoint();\n\t\t\tvar distance = distanceMetric(position, center);\n\n\t\t\tif (distance < minDistance) {\n\t\t\t\tnearestItems = [element];\n\t\t\t\tminDistance = distance;\n\t\t\t} else if (distance === minDistance) {\n\t\t\t\t// Can have multiple items at the same distance in which case we sort by size\n\t\t\t\tnearestItems.push(element);\n\t\t\t}\n\t\t});\n\n\t\treturn nearestItems;\n\t}\n\n\tfunction indexMode(chart, e, options) {\n\t\tvar position = getRelativePosition(e, chart.chart);\n\t\tvar distanceMetric = function(pt1, pt2) {\n\t\t\treturn Math.abs(pt1.x - pt2.x);\n\t\t};\n\t\tvar items = options.intersect ? getIntersectItems(chart, position) : getNearestItems(chart, position, false, distanceMetric);\n\t\tvar elements = [];\n\n\t\tif (!items.length) {\n\t\t\treturn [];\n\t\t}\n\n\t\tchart.data.datasets.forEach(function(dataset, datasetIndex) {\n\t\t\tif (chart.isDatasetVisible(datasetIndex)) {\n\t\t\t\tvar meta = chart.getDatasetMeta(datasetIndex),\n\t\t\t\t\telement = meta.data[items[0]._index];\n\n\t\t\t\t// don't count items that are skipped (null data)\n\t\t\t\tif (element && !element._view.skip) {\n\t\t\t\t\telements.push(element);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\treturn elements;\n\t}\n\n\t/**\n\t * @interface IInteractionOptions\n\t */\n\t/**\n\t * If true, only consider items that intersect the point\n\t * @name IInterfaceOptions#boolean\n\t * @type Boolean\n\t */\n\n\t/**\n\t * Contains interaction related functions\n\t * @namespace Chart.Interaction\n\t */\n\tChart.Interaction = {\n\t\t// Helper function for different modes\n\t\tmodes: {\n\t\t\tsingle: function(chart, e) {\n\t\t\t\tvar position = getRelativePosition(e, chart.chart);\n\t\t\t\tvar elements = [];\n\n\t\t\t\tparseVisibleItems(chart, function(element) {\n\t\t\t\t\tif (element.inRange(position.x, position.y)) {\n\t\t\t\t\t\telements.push(element);\n\t\t\t\t\t\treturn elements;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\treturn elements.slice(0, 1);\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * @function Chart.Interaction.modes.label\n\t\t\t * @deprecated since version 2.4.0\n\t\t\t */\n\t\t\tlabel: indexMode,\n\n\t\t\t/**\n\t\t\t * Returns items at the same index. If the options.intersect parameter is true, we only return items if we intersect something\n\t\t\t * If the options.intersect mode is false, we find the nearest item and return the items at the same index as that item\n\t\t\t * @function Chart.Interaction.modes.index\n\t\t\t * @since v2.4.0\n\t\t\t * @param chart {chart} the chart we are returning items from\n\t\t\t * @param e {Event} the event we are find things at\n\t\t\t * @param options {IInteractionOptions} options to use during interaction\n\t\t\t * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\n\t\t\t */\n\t\t\tindex: indexMode,\n\n\t\t\t/**\n\t\t\t * Returns items in the same dataset. If the options.intersect parameter is true, we only return items if we intersect something\n\t\t\t * If the options.intersect is false, we find the nearest item and return the items in that dataset\n\t\t\t * @function Chart.Interaction.modes.dataset\n\t\t\t * @param chart {chart} the chart we are returning items from\n\t\t\t * @param e {Event} the event we are find things at\n\t\t\t * @param options {IInteractionOptions} options to use during interaction\n\t\t\t * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\n\t\t\t */\n\t\t\tdataset: function(chart, e, options) {\n\t\t\t\tvar position = getRelativePosition(e, chart.chart);\n\t\t\t\tvar items = options.intersect ? getIntersectItems(chart, position) : getNearestItems(chart, position, false);\n\n\t\t\t\tif (items.length > 0) {\n\t\t\t\t\titems = chart.getDatasetMeta(items[0]._datasetIndex).data;\n\t\t\t\t}\n\n\t\t\t\treturn items;\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * @function Chart.Interaction.modes.x-axis\n\t\t\t * @deprecated since version 2.4.0. Use index mode and intersect == true\n\t\t\t */\n\t\t\t'x-axis': function(chart, e) {\n\t\t\t\treturn indexMode(chart, e, true);\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Point mode returns all elements that hit test based on the event position\n\t\t\t * of the event\n\t\t\t * @function Chart.Interaction.modes.intersect\n\t\t\t * @param chart {chart} the chart we are returning items from\n\t\t\t * @param e {Event} the event we are find things at\n\t\t\t * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\n\t\t\t */\n\t\t\tpoint: function(chart, e) {\n\t\t\t\tvar position = getRelativePosition(e, chart.chart);\n\t\t\t\treturn getIntersectItems(chart, position);\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * nearest mode returns the element closest to the point\n\t\t\t * @function Chart.Interaction.modes.intersect\n\t\t\t * @param chart {chart} the chart we are returning items from\n\t\t\t * @param e {Event} the event we are find things at\n\t\t\t * @param options {IInteractionOptions} options to use\n\t\t\t * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\n\t\t\t */\n\t\t\tnearest: function(chart, e, options) {\n\t\t\t\tvar position = getRelativePosition(e, chart.chart);\n\t\t\t\tvar nearestItems = getNearestItems(chart, position, options.intersect);\n\n\t\t\t\t// We have multiple items at the same distance from the event. Now sort by smallest\n\t\t\t\tif (nearestItems.length > 1) {\n\t\t\t\t\tnearestItems.sort(function(a, b) {\n\t\t\t\t\t\tvar sizeA = a.getArea();\n\t\t\t\t\t\tvar sizeB = b.getArea();\n\t\t\t\t\t\tvar ret = sizeA - sizeB;\n\n\t\t\t\t\t\tif (ret === 0) {\n\t\t\t\t\t\t\t// if equal sort by dataset index\n\t\t\t\t\t\t\tret = a._datasetIndex - b._datasetIndex;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn ret;\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t// Return only 1 item\n\t\t\t\treturn nearestItems.slice(0, 1);\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * x mode returns the elements that hit-test at the current x coordinate\n\t\t\t * @function Chart.Interaction.modes.x\n\t\t\t * @param chart {chart} the chart we are returning items from\n\t\t\t * @param e {Event} the event we are find things at\n\t\t\t * @param options {IInteractionOptions} options to use\n\t\t\t * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\n\t\t\t */\n\t\t\tx: function(chart, e, options) {\n\t\t\t\tvar position = getRelativePosition(e, chart.chart);\n\t\t\t\tvar items = [];\n\t\t\t\tvar intersectsItem = false;\n\n\t\t\t\tparseVisibleItems(chart, function(element) {\n\t\t\t\t\tif (element.inXRange(position.x)) {\n\t\t\t\t\t\titems.push(element);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (element.inRange(position.x, position.y)) {\n\t\t\t\t\t\tintersectsItem = true;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\t// If we want to trigger on an intersect and we don't have any items\n\t\t\t\t// that intersect the position, return nothing\n\t\t\t\tif (options.intersect && !intersectsItem) {\n\t\t\t\t\titems = [];\n\t\t\t\t}\n\t\t\t\treturn items;\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * y mode returns the elements that hit-test at the current y coordinate\n\t\t\t * @function Chart.Interaction.modes.y\n\t\t\t * @param chart {chart} the chart we are returning items from\n\t\t\t * @param e {Event} the event we are find things at\n\t\t\t * @param options {IInteractionOptions} options to use\n\t\t\t * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\n\t\t\t */\n\t\t\ty: function(chart, e, options) {\n\t\t\t\tvar position = getRelativePosition(e, chart.chart);\n\t\t\t\tvar items = [];\n\t\t\t\tvar intersectsItem = false;\n\n\t\t\t\tparseVisibleItems(chart, function(element) {\n\t\t\t\t\tif (element.inYRange(position.y)) {\n\t\t\t\t\t\titems.push(element);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (element.inRange(position.x, position.y)) {\n\t\t\t\t\t\tintersectsItem = true;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\t// If we want to trigger on an intersect and we don't have any items\n\t\t\t\t// that intersect the position, return nothing\n\t\t\t\tif (options.intersect && !intersectsItem) {\n\t\t\t\t\titems = [];\n\t\t\t\t}\n\t\t\t\treturn items;\n\t\t\t}\n\t\t}\n\t};\n};\n\n},{}],28:[function(require,module,exports){\n'use strict';\n\nmodule.exports = function() {\n\n\t// Occupy the global variable of Chart, and create a simple base class\n\tvar Chart = function(item, config) {\n\t\tthis.controller = new Chart.Controller(item, config, this);\n\t\treturn this.controller;\n\t};\n\n\t// Globally expose the defaults to allow for user updating/changing\n\tChart.defaults = {\n\t\tglobal: {\n\t\t\tresponsive: true,\n\t\t\tresponsiveAnimationDuration: 0,\n\t\t\tmaintainAspectRatio: true,\n\t\t\tevents: ['mousemove', 'mouseout', 'click', 'touchstart', 'touchmove'],\n\t\t\thover: {\n\t\t\t\tonHover: null,\n\t\t\t\tmode: 'nearest',\n\t\t\t\tintersect: true,\n\t\t\t\tanimationDuration: 400\n\t\t\t},\n\t\t\tonClick: null,\n\t\t\tdefaultColor: 'rgba(0,0,0,0.1)',\n\t\t\tdefaultFontColor: '#666',\n\t\t\tdefaultFontFamily: \"'Helvetica Neue', 'Helvetica', 'Arial', sans-serif\",\n\t\t\tdefaultFontSize: 12,\n\t\t\tdefaultFontStyle: 'normal',\n\t\t\tshowLines: true,\n\n\t\t\t// Element defaults defined in element extensions\n\t\t\telements: {},\n\n\t\t\t// Legend callback string\n\t\t\tlegendCallback: function(chart) {\n\t\t\t\tvar text = [];\n\t\t\t\ttext.push('<ul class=\"' + chart.id + '-legend\">');\n\t\t\t\tfor (var i = 0; i < chart.data.datasets.length; i++) {\n\t\t\t\t\ttext.push('<li><span style=\"background-color:' + chart.data.datasets[i].backgroundColor + '\"></span>');\n\t\t\t\t\tif (chart.data.datasets[i].label) {\n\t\t\t\t\t\ttext.push(chart.data.datasets[i].label);\n\t\t\t\t\t}\n\t\t\t\t\ttext.push('</li>');\n\t\t\t\t}\n\t\t\t\ttext.push('</ul>');\n\n\t\t\t\treturn text.join('');\n\t\t\t}\n\t\t}\n\t};\n\n\tChart.Chart = Chart;\n\n\treturn Chart;\n};\n\n},{}],29:[function(require,module,exports){\n'use strict';\n\nmodule.exports = function(Chart) {\n\n\tvar helpers = Chart.helpers;\n\n\t// The layout service is very self explanatory.  It's responsible for the layout within a chart.\n\t// Scales, Legends and Plugins all rely on the layout service and can easily register to be placed anywhere they need\n\t// It is this service's responsibility of carrying out that layout.\n\tChart.layoutService = {\n\t\tdefaults: {},\n\n\t\t// Register a box to a chartInstance. A box is simply a reference to an object that requires layout. eg. Scales, Legend, Plugins.\n\t\taddBox: function(chartInstance, box) {\n\t\t\tif (!chartInstance.boxes) {\n\t\t\t\tchartInstance.boxes = [];\n\t\t\t}\n\t\t\tchartInstance.boxes.push(box);\n\t\t},\n\n\t\tremoveBox: function(chartInstance, box) {\n\t\t\tif (!chartInstance.boxes) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tchartInstance.boxes.splice(chartInstance.boxes.indexOf(box), 1);\n\t\t},\n\n\t\t// The most important function\n\t\tupdate: function(chartInstance, width, height) {\n\n\t\t\tif (!chartInstance) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar layoutOptions = chartInstance.options.layout;\n\t\t\tvar padding = layoutOptions ? layoutOptions.padding : null;\n\n\t\t\tvar leftPadding = 0;\n\t\t\tvar rightPadding = 0;\n\t\t\tvar topPadding = 0;\n\t\t\tvar bottomPadding = 0;\n\n\t\t\tif (!isNaN(padding)) {\n\t\t\t\t// options.layout.padding is a number. assign to all\n\t\t\t\tleftPadding = padding;\n\t\t\t\trightPadding = padding;\n\t\t\t\ttopPadding = padding;\n\t\t\t\tbottomPadding = padding;\n\t\t\t} else {\n\t\t\t\tleftPadding = padding.left || 0;\n\t\t\t\trightPadding = padding.right || 0;\n\t\t\t\ttopPadding = padding.top || 0;\n\t\t\t\tbottomPadding = padding.bottom || 0;\n\t\t\t}\n\n\t\t\tvar leftBoxes = helpers.where(chartInstance.boxes, function(box) {\n\t\t\t\treturn box.options.position === 'left';\n\t\t\t});\n\t\t\tvar rightBoxes = helpers.where(chartInstance.boxes, function(box) {\n\t\t\t\treturn box.options.position === 'right';\n\t\t\t});\n\t\t\tvar topBoxes = helpers.where(chartInstance.boxes, function(box) {\n\t\t\t\treturn box.options.position === 'top';\n\t\t\t});\n\t\t\tvar bottomBoxes = helpers.where(chartInstance.boxes, function(box) {\n\t\t\t\treturn box.options.position === 'bottom';\n\t\t\t});\n\n\t\t\t// Boxes that overlay the chartarea such as the radialLinear scale\n\t\t\tvar chartAreaBoxes = helpers.where(chartInstance.boxes, function(box) {\n\t\t\t\treturn box.options.position === 'chartArea';\n\t\t\t});\n\n\t\t\t// Ensure that full width boxes are at the very top / bottom\n\t\t\ttopBoxes.sort(function(a, b) {\n\t\t\t\treturn (b.options.fullWidth ? 1 : 0) - (a.options.fullWidth ? 1 : 0);\n\t\t\t});\n\t\t\tbottomBoxes.sort(function(a, b) {\n\t\t\t\treturn (a.options.fullWidth ? 1 : 0) - (b.options.fullWidth ? 1 : 0);\n\t\t\t});\n\n\t\t\t// Essentially we now have any number of boxes on each of the 4 sides.\n\t\t\t// Our canvas looks like the following.\n\t\t\t// The areas L1 and L2 are the left axes. R1 is the right axis, T1 is the top axis and\n\t\t\t// B1 is the bottom axis\n\t\t\t// There are also 4 quadrant-like locations (left to right instead of clockwise) reserved for chart overlays\n\t\t\t// These locations are single-box locations only, when trying to register a chartArea location that is already taken,\n\t\t\t// an error will be thrown.\n\t\t\t//\n\t\t\t// |----------------------------------------------------|\n\t\t\t// |                  T1 (Full Width)                   |\n\t\t\t// |----------------------------------------------------|\n\t\t\t// |    |    |                 T2                  |    |\n\t\t\t// |    |----|-------------------------------------|----|\n\t\t\t// |    |    | C1 |                           | C2 |    |\n\t\t\t// |    |    |----|                           |----|    |\n\t\t\t// |    |    |                                     |    |\n\t\t\t// | L1 | L2 |           ChartArea (C0)            | R1 |\n\t\t\t// |    |    |                                     |    |\n\t\t\t// |    |    |----|                           |----|    |\n\t\t\t// |    |    | C3 |                           | C4 |    |\n\t\t\t// |    |----|-------------------------------------|----|\n\t\t\t// |    |    |                 B1                  |    |\n\t\t\t// |----------------------------------------------------|\n\t\t\t// |                  B2 (Full Width)                   |\n\t\t\t// |----------------------------------------------------|\n\t\t\t//\n\t\t\t// What we do to find the best sizing, we do the following\n\t\t\t// 1. Determine the minimum size of the chart area.\n\t\t\t// 2. Split the remaining width equally between each vertical axis\n\t\t\t// 3. Split the remaining height equally between each horizontal axis\n\t\t\t// 4. Give each layout the maximum size it can be. The layout will return it's minimum size\n\t\t\t// 5. Adjust the sizes of each axis based on it's minimum reported size.\n\t\t\t// 6. Refit each axis\n\t\t\t// 7. Position each axis in the final location\n\t\t\t// 8. Tell the chart the final location of the chart area\n\t\t\t// 9. Tell any axes that overlay the chart area the positions of the chart area\n\n\t\t\t// Step 1\n\t\t\tvar chartWidth = width - leftPadding - rightPadding;\n\t\t\tvar chartHeight = height - topPadding - bottomPadding;\n\t\t\tvar chartAreaWidth = chartWidth / 2; // min 50%\n\t\t\tvar chartAreaHeight = chartHeight / 2; // min 50%\n\n\t\t\t// Step 2\n\t\t\tvar verticalBoxWidth = (width - chartAreaWidth) / (leftBoxes.length + rightBoxes.length);\n\n\t\t\t// Step 3\n\t\t\tvar horizontalBoxHeight = (height - chartAreaHeight) / (topBoxes.length + bottomBoxes.length);\n\n\t\t\t// Step 4\n\t\t\tvar maxChartAreaWidth = chartWidth;\n\t\t\tvar maxChartAreaHeight = chartHeight;\n\t\t\tvar minBoxSizes = [];\n\n\t\t\tfunction getMinimumBoxSize(box) {\n\t\t\t\tvar minSize;\n\t\t\t\tvar isHorizontal = box.isHorizontal();\n\n\t\t\t\tif (isHorizontal) {\n\t\t\t\t\tminSize = box.update(box.options.fullWidth ? chartWidth : maxChartAreaWidth, horizontalBoxHeight);\n\t\t\t\t\tmaxChartAreaHeight -= minSize.height;\n\t\t\t\t} else {\n\t\t\t\t\tminSize = box.update(verticalBoxWidth, chartAreaHeight);\n\t\t\t\t\tmaxChartAreaWidth -= minSize.width;\n\t\t\t\t}\n\n\t\t\t\tminBoxSizes.push({\n\t\t\t\t\thorizontal: isHorizontal,\n\t\t\t\t\tminSize: minSize,\n\t\t\t\t\tbox: box,\n\t\t\t\t});\n\t\t\t}\n\n\t\t\thelpers.each(leftBoxes.concat(rightBoxes, topBoxes, bottomBoxes), getMinimumBoxSize);\n\n\t\t\t// If a horizontal box has padding, we move the left boxes over to avoid ugly charts (see issue #2478)\n\t\t\tvar maxHorizontalLeftPadding = 0;\n\t\t\tvar maxHorizontalRightPadding = 0;\n\t\t\tvar maxVerticalTopPadding = 0;\n\t\t\tvar maxVerticalBottomPadding = 0;\n\n\t\t\thelpers.each(topBoxes.concat(bottomBoxes), function(horizontalBox) {\n\t\t\t\tif (horizontalBox.getPadding) {\n\t\t\t\t\tvar boxPadding = horizontalBox.getPadding();\n\t\t\t\t\tmaxHorizontalLeftPadding = Math.max(maxHorizontalLeftPadding, boxPadding.left);\n\t\t\t\t\tmaxHorizontalRightPadding = Math.max(maxHorizontalRightPadding, boxPadding.right);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\thelpers.each(leftBoxes.concat(rightBoxes), function(verticalBox) {\n\t\t\t\tif (verticalBox.getPadding) {\n\t\t\t\t\tvar boxPadding = verticalBox.getPadding();\n\t\t\t\t\tmaxVerticalTopPadding = Math.max(maxVerticalTopPadding, boxPadding.top);\n\t\t\t\t\tmaxVerticalBottomPadding = Math.max(maxVerticalBottomPadding, boxPadding.bottom);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// At this point, maxChartAreaHeight and maxChartAreaWidth are the size the chart area could\n\t\t\t// be if the axes are drawn at their minimum sizes.\n\t\t\t// Steps 5 & 6\n\t\t\tvar totalLeftBoxesWidth = leftPadding;\n\t\t\tvar totalRightBoxesWidth = rightPadding;\n\t\t\tvar totalTopBoxesHeight = topPadding;\n\t\t\tvar totalBottomBoxesHeight = bottomPadding;\n\n\t\t\t// Function to fit a box\n\t\t\tfunction fitBox(box) {\n\t\t\t\tvar minBoxSize = helpers.findNextWhere(minBoxSizes, function(minBox) {\n\t\t\t\t\treturn minBox.box === box;\n\t\t\t\t});\n\n\t\t\t\tif (minBoxSize) {\n\t\t\t\t\tif (box.isHorizontal()) {\n\t\t\t\t\t\tvar scaleMargin = {\n\t\t\t\t\t\t\tleft: Math.max(totalLeftBoxesWidth, maxHorizontalLeftPadding),\n\t\t\t\t\t\t\tright: Math.max(totalRightBoxesWidth, maxHorizontalRightPadding),\n\t\t\t\t\t\t\ttop: 0,\n\t\t\t\t\t\t\tbottom: 0\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\t// Don't use min size here because of label rotation. When the labels are rotated, their rotation highly depends\n\t\t\t\t\t\t// on the margin. Sometimes they need to increase in size slightly\n\t\t\t\t\t\tbox.update(box.options.fullWidth ? chartWidth : maxChartAreaWidth, chartHeight / 2, scaleMargin);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbox.update(minBoxSize.minSize.width, maxChartAreaHeight);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Update, and calculate the left and right margins for the horizontal boxes\n\t\t\thelpers.each(leftBoxes.concat(rightBoxes), fitBox);\n\n\t\t\thelpers.each(leftBoxes, function(box) {\n\t\t\t\ttotalLeftBoxesWidth += box.width;\n\t\t\t});\n\n\t\t\thelpers.each(rightBoxes, function(box) {\n\t\t\t\ttotalRightBoxesWidth += box.width;\n\t\t\t});\n\n\t\t\t// Set the Left and Right margins for the horizontal boxes\n\t\t\thelpers.each(topBoxes.concat(bottomBoxes), fitBox);\n\n\t\t\t// Figure out how much margin is on the top and bottom of the vertical boxes\n\t\t\thelpers.each(topBoxes, function(box) {\n\t\t\t\ttotalTopBoxesHeight += box.height;\n\t\t\t});\n\n\t\t\thelpers.each(bottomBoxes, function(box) {\n\t\t\t\ttotalBottomBoxesHeight += box.height;\n\t\t\t});\n\n\t\t\tfunction finalFitVerticalBox(box) {\n\t\t\t\tvar minBoxSize = helpers.findNextWhere(minBoxSizes, function(minSize) {\n\t\t\t\t\treturn minSize.box === box;\n\t\t\t\t});\n\n\t\t\t\tvar scaleMargin = {\n\t\t\t\t\tleft: 0,\n\t\t\t\t\tright: 0,\n\t\t\t\t\ttop: totalTopBoxesHeight,\n\t\t\t\t\tbottom: totalBottomBoxesHeight\n\t\t\t\t};\n\n\t\t\t\tif (minBoxSize) {\n\t\t\t\t\tbox.update(minBoxSize.minSize.width, maxChartAreaHeight, scaleMargin);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Let the left layout know the final margin\n\t\t\thelpers.each(leftBoxes.concat(rightBoxes), finalFitVerticalBox);\n\n\t\t\t// Recalculate because the size of each layout might have changed slightly due to the margins (label rotation for instance)\n\t\t\ttotalLeftBoxesWidth = leftPadding;\n\t\t\ttotalRightBoxesWidth = rightPadding;\n\t\t\ttotalTopBoxesHeight = topPadding;\n\t\t\ttotalBottomBoxesHeight = bottomPadding;\n\n\t\t\thelpers.each(leftBoxes, function(box) {\n\t\t\t\ttotalLeftBoxesWidth += box.width;\n\t\t\t});\n\n\t\t\thelpers.each(rightBoxes, function(box) {\n\t\t\t\ttotalRightBoxesWidth += box.width;\n\t\t\t});\n\n\t\t\thelpers.each(topBoxes, function(box) {\n\t\t\t\ttotalTopBoxesHeight += box.height;\n\t\t\t});\n\t\t\thelpers.each(bottomBoxes, function(box) {\n\t\t\t\ttotalBottomBoxesHeight += box.height;\n\t\t\t});\n\n\t\t\t// We may be adding some padding to account for rotated x axis labels\n\t\t\tvar leftPaddingAddition = Math.max(maxHorizontalLeftPadding - totalLeftBoxesWidth, 0);\n\t\t\ttotalLeftBoxesWidth += leftPaddingAddition;\n\t\t\ttotalRightBoxesWidth += Math.max(maxHorizontalRightPadding - totalRightBoxesWidth, 0);\n\n\t\t\tvar topPaddingAddition = Math.max(maxVerticalTopPadding - totalTopBoxesHeight, 0);\n\t\t\ttotalTopBoxesHeight += topPaddingAddition;\n\t\t\ttotalBottomBoxesHeight += Math.max(maxVerticalBottomPadding - totalBottomBoxesHeight, 0);\n\n\t\t\t// Figure out if our chart area changed. This would occur if the dataset layout label rotation\n\t\t\t// changed due to the application of the margins in step 6. Since we can only get bigger, this is safe to do\n\t\t\t// without calling `fit` again\n\t\t\tvar newMaxChartAreaHeight = height - totalTopBoxesHeight - totalBottomBoxesHeight;\n\t\t\tvar newMaxChartAreaWidth = width - totalLeftBoxesWidth - totalRightBoxesWidth;\n\n\t\t\tif (newMaxChartAreaWidth !== maxChartAreaWidth || newMaxChartAreaHeight !== maxChartAreaHeight) {\n\t\t\t\thelpers.each(leftBoxes, function(box) {\n\t\t\t\t\tbox.height = newMaxChartAreaHeight;\n\t\t\t\t});\n\n\t\t\t\thelpers.each(rightBoxes, function(box) {\n\t\t\t\t\tbox.height = newMaxChartAreaHeight;\n\t\t\t\t});\n\n\t\t\t\thelpers.each(topBoxes, function(box) {\n\t\t\t\t\tif (!box.options.fullWidth) {\n\t\t\t\t\t\tbox.width = newMaxChartAreaWidth;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\thelpers.each(bottomBoxes, function(box) {\n\t\t\t\t\tif (!box.options.fullWidth) {\n\t\t\t\t\t\tbox.width = newMaxChartAreaWidth;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tmaxChartAreaHeight = newMaxChartAreaHeight;\n\t\t\t\tmaxChartAreaWidth = newMaxChartAreaWidth;\n\t\t\t}\n\n\t\t\t// Step 7 - Position the boxes\n\t\t\tvar left = leftPadding + leftPaddingAddition;\n\t\t\tvar top = topPadding + topPaddingAddition;\n\n\t\t\tfunction placeBox(box) {\n\t\t\t\tif (box.isHorizontal()) {\n\t\t\t\t\tbox.left = box.options.fullWidth ? leftPadding : totalLeftBoxesWidth;\n\t\t\t\t\tbox.right = box.options.fullWidth ? width - rightPadding : totalLeftBoxesWidth + maxChartAreaWidth;\n\t\t\t\t\tbox.top = top;\n\t\t\t\t\tbox.bottom = top + box.height;\n\n\t\t\t\t\t// Move to next point\n\t\t\t\t\ttop = box.bottom;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tbox.left = left;\n\t\t\t\t\tbox.right = left + box.width;\n\t\t\t\t\tbox.top = totalTopBoxesHeight;\n\t\t\t\t\tbox.bottom = totalTopBoxesHeight + maxChartAreaHeight;\n\n\t\t\t\t\t// Move to next point\n\t\t\t\t\tleft = box.right;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\thelpers.each(leftBoxes.concat(topBoxes), placeBox);\n\n\t\t\t// Account for chart width and height\n\t\t\tleft += maxChartAreaWidth;\n\t\t\ttop += maxChartAreaHeight;\n\n\t\t\thelpers.each(rightBoxes, placeBox);\n\t\t\thelpers.each(bottomBoxes, placeBox);\n\n\t\t\t// Step 8\n\t\t\tchartInstance.chartArea = {\n\t\t\t\tleft: totalLeftBoxesWidth,\n\t\t\t\ttop: totalTopBoxesHeight,\n\t\t\t\tright: totalLeftBoxesWidth + maxChartAreaWidth,\n\t\t\t\tbottom: totalTopBoxesHeight + maxChartAreaHeight\n\t\t\t};\n\n\t\t\t// Step 9\n\t\t\thelpers.each(chartAreaBoxes, function(box) {\n\t\t\t\tbox.left = chartInstance.chartArea.left;\n\t\t\t\tbox.top = chartInstance.chartArea.top;\n\t\t\t\tbox.right = chartInstance.chartArea.right;\n\t\t\t\tbox.bottom = chartInstance.chartArea.bottom;\n\n\t\t\t\tbox.update(maxChartAreaWidth, maxChartAreaHeight);\n\t\t\t});\n\t\t}\n\t};\n};\n\n},{}],30:[function(require,module,exports){\n'use strict';\n\nmodule.exports = function(Chart) {\n\n\tvar helpers = Chart.helpers;\n\tvar noop = helpers.noop;\n\n\tChart.defaults.global.legend = {\n\n\t\tdisplay: true,\n\t\tposition: 'top',\n\t\tfullWidth: true, // marks that this box should take the full width of the canvas (pushing down other boxes)\n\t\treverse: false,\n\n\t\t// a callback that will handle\n\t\tonClick: function(e, legendItem) {\n\t\t\tvar index = legendItem.datasetIndex;\n\t\t\tvar ci = this.chart;\n\t\t\tvar meta = ci.getDatasetMeta(index);\n\n\t\t\t// See controller.isDatasetVisible comment\n\t\t\tmeta.hidden = meta.hidden === null? !ci.data.datasets[index].hidden : null;\n\n\t\t\t// We hid a dataset ... rerender the chart\n\t\t\tci.update();\n\t\t},\n\n\t\tonHover: null,\n\n\t\tlabels: {\n\t\t\tboxWidth: 40,\n\t\t\tpadding: 10,\n\t\t\t// Generates labels shown in the legend\n\t\t\t// Valid properties to return:\n\t\t\t// text : text to display\n\t\t\t// fillStyle : fill of coloured box\n\t\t\t// strokeStyle: stroke of coloured box\n\t\t\t// hidden : if this legend item refers to a hidden item\n\t\t\t// lineCap : cap style for line\n\t\t\t// lineDash\n\t\t\t// lineDashOffset :\n\t\t\t// lineJoin :\n\t\t\t// lineWidth :\n\t\t\tgenerateLabels: function(chart) {\n\t\t\t\tvar data = chart.data;\n\t\t\t\treturn helpers.isArray(data.datasets) ? data.datasets.map(function(dataset, i) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\ttext: dataset.label,\n\t\t\t\t\t\tfillStyle: (!helpers.isArray(dataset.backgroundColor) ? dataset.backgroundColor : dataset.backgroundColor[0]),\n\t\t\t\t\t\thidden: !chart.isDatasetVisible(i),\n\t\t\t\t\t\tlineCap: dataset.borderCapStyle,\n\t\t\t\t\t\tlineDash: dataset.borderDash,\n\t\t\t\t\t\tlineDashOffset: dataset.borderDashOffset,\n\t\t\t\t\t\tlineJoin: dataset.borderJoinStyle,\n\t\t\t\t\t\tlineWidth: dataset.borderWidth,\n\t\t\t\t\t\tstrokeStyle: dataset.borderColor,\n\t\t\t\t\t\tpointStyle: dataset.pointStyle,\n\n\t\t\t\t\t\t// Below is extra data used for toggling the datasets\n\t\t\t\t\t\tdatasetIndex: i\n\t\t\t\t\t};\n\t\t\t\t}, this) : [];\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * Helper function to get the box width based on the usePointStyle option\n\t * @param labelopts {Object} the label options on the legend\n\t * @param fontSize {Number} the label font size\n\t * @return {Number} width of the color box area\n\t */\n\tfunction getBoxWidth(labelOpts, fontSize) {\n\t\treturn labelOpts.usePointStyle ?\n\t\t\tfontSize * Math.SQRT2 :\n\t\t\tlabelOpts.boxWidth;\n\t}\n\n\tChart.Legend = Chart.Element.extend({\n\n\t\tinitialize: function(config) {\n\t\t\thelpers.extend(this, config);\n\n\t\t\t// Contains hit boxes for each dataset (in dataset order)\n\t\t\tthis.legendHitBoxes = [];\n\n\t\t\t// Are we in doughnut mode which has a different data type\n\t\t\tthis.doughnutMode = false;\n\t\t},\n\n\t\t// These methods are ordered by lifecycle. Utilities then follow.\n\t\t// Any function defined here is inherited by all legend types.\n\t\t// Any function can be extended by the legend type\n\n\t\tbeforeUpdate: noop,\n\t\tupdate: function(maxWidth, maxHeight, margins) {\n\t\t\tvar me = this;\n\n\t\t\t// Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)\n\t\t\tme.beforeUpdate();\n\n\t\t\t// Absorb the master measurements\n\t\t\tme.maxWidth = maxWidth;\n\t\t\tme.maxHeight = maxHeight;\n\t\t\tme.margins = margins;\n\n\t\t\t// Dimensions\n\t\t\tme.beforeSetDimensions();\n\t\t\tme.setDimensions();\n\t\t\tme.afterSetDimensions();\n\t\t\t// Labels\n\t\t\tme.beforeBuildLabels();\n\t\t\tme.buildLabels();\n\t\t\tme.afterBuildLabels();\n\n\t\t\t// Fit\n\t\t\tme.beforeFit();\n\t\t\tme.fit();\n\t\t\tme.afterFit();\n\t\t\t//\n\t\t\tme.afterUpdate();\n\n\t\t\treturn me.minSize;\n\t\t},\n\t\tafterUpdate: noop,\n\n\t\t//\n\n\t\tbeforeSetDimensions: noop,\n\t\tsetDimensions: function() {\n\t\t\tvar me = this;\n\t\t\t// Set the unconstrained dimension before label rotation\n\t\t\tif (me.isHorizontal()) {\n\t\t\t\t// Reset position before calculating rotation\n\t\t\t\tme.width = me.maxWidth;\n\t\t\t\tme.left = 0;\n\t\t\t\tme.right = me.width;\n\t\t\t} else {\n\t\t\t\tme.height = me.maxHeight;\n\n\t\t\t\t// Reset position before calculating rotation\n\t\t\t\tme.top = 0;\n\t\t\t\tme.bottom = me.height;\n\t\t\t}\n\n\t\t\t// Reset padding\n\t\t\tme.paddingLeft = 0;\n\t\t\tme.paddingTop = 0;\n\t\t\tme.paddingRight = 0;\n\t\t\tme.paddingBottom = 0;\n\n\t\t\t// Reset minSize\n\t\t\tme.minSize = {\n\t\t\t\twidth: 0,\n\t\t\t\theight: 0\n\t\t\t};\n\t\t},\n\t\tafterSetDimensions: noop,\n\n\t\t//\n\n\t\tbeforeBuildLabels: noop,\n\t\tbuildLabels: function() {\n\t\t\tvar me = this;\n\t\t\tvar labelOpts = me.options.labels;\n\t\t\tvar legendItems = labelOpts.generateLabels.call(me, me.chart);\n\n\t\t\tif (labelOpts.filter) {\n\t\t\t\tlegendItems = legendItems.filter(function(item) {\n\t\t\t\t\treturn labelOpts.filter(item, me.chart.data);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (me.options.reverse) {\n\t\t\t\tlegendItems.reverse();\n\t\t\t}\n\n\t\t\tme.legendItems = legendItems;\n\t\t},\n\t\tafterBuildLabels: noop,\n\n\t\t//\n\n\t\tbeforeFit: noop,\n\t\tfit: function() {\n\t\t\tvar me = this;\n\t\t\tvar opts = me.options;\n\t\t\tvar labelOpts = opts.labels;\n\t\t\tvar display = opts.display;\n\n\t\t\tvar ctx = me.ctx;\n\n\t\t\tvar globalDefault = Chart.defaults.global,\n\t\t\t\titemOrDefault = helpers.getValueOrDefault,\n\t\t\t\tfontSize = itemOrDefault(labelOpts.fontSize, globalDefault.defaultFontSize),\n\t\t\t\tfontStyle = itemOrDefault(labelOpts.fontStyle, globalDefault.defaultFontStyle),\n\t\t\t\tfontFamily = itemOrDefault(labelOpts.fontFamily, globalDefault.defaultFontFamily),\n\t\t\t\tlabelFont = helpers.fontString(fontSize, fontStyle, fontFamily);\n\n\t\t\t// Reset hit boxes\n\t\t\tvar hitboxes = me.legendHitBoxes = [];\n\n\t\t\tvar minSize = me.minSize;\n\t\t\tvar isHorizontal = me.isHorizontal();\n\n\t\t\tif (isHorizontal) {\n\t\t\t\tminSize.width = me.maxWidth; // fill all the width\n\t\t\t\tminSize.height = display ? 10 : 0;\n\t\t\t} else {\n\t\t\t\tminSize.width = display ? 10 : 0;\n\t\t\t\tminSize.height = me.maxHeight; // fill all the height\n\t\t\t}\n\n\t\t\t// Increase sizes here\n\t\t\tif (display) {\n\t\t\t\tctx.font = labelFont;\n\n\t\t\t\tif (isHorizontal) {\n\t\t\t\t\t// Labels\n\n\t\t\t\t\t// Width of each line of legend boxes. Labels wrap onto multiple lines when there are too many to fit on one\n\t\t\t\t\tvar lineWidths = me.lineWidths = [0];\n\t\t\t\t\tvar totalHeight = me.legendItems.length ? fontSize + (labelOpts.padding) : 0;\n\n\t\t\t\t\tctx.textAlign = 'left';\n\t\t\t\t\tctx.textBaseline = 'top';\n\n\t\t\t\t\thelpers.each(me.legendItems, function(legendItem, i) {\n\t\t\t\t\t\tvar boxWidth = getBoxWidth(labelOpts, fontSize);\n\t\t\t\t\t\tvar width = boxWidth + (fontSize / 2) + ctx.measureText(legendItem.text).width;\n\n\t\t\t\t\t\tif (lineWidths[lineWidths.length - 1] + width + labelOpts.padding >= me.width) {\n\t\t\t\t\t\t\ttotalHeight += fontSize + (labelOpts.padding);\n\t\t\t\t\t\t\tlineWidths[lineWidths.length] = me.left;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Store the hitbox width and height here. Final position will be updated in `draw`\n\t\t\t\t\t\thitboxes[i] = {\n\t\t\t\t\t\t\tleft: 0,\n\t\t\t\t\t\t\ttop: 0,\n\t\t\t\t\t\t\twidth: width,\n\t\t\t\t\t\t\theight: fontSize\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tlineWidths[lineWidths.length - 1] += width + labelOpts.padding;\n\t\t\t\t\t});\n\n\t\t\t\t\tminSize.height += totalHeight;\n\n\t\t\t\t} else {\n\t\t\t\t\tvar vPadding = labelOpts.padding;\n\t\t\t\t\tvar columnWidths = me.columnWidths = [];\n\t\t\t\t\tvar totalWidth = labelOpts.padding;\n\t\t\t\t\tvar currentColWidth = 0;\n\t\t\t\t\tvar currentColHeight = 0;\n\t\t\t\t\tvar itemHeight = fontSize + vPadding;\n\n\t\t\t\t\thelpers.each(me.legendItems, function(legendItem, i) {\n\t\t\t\t\t\tvar boxWidth = getBoxWidth(labelOpts, fontSize);\n\t\t\t\t\t\tvar itemWidth = boxWidth + (fontSize / 2) + ctx.measureText(legendItem.text).width;\n\n\t\t\t\t\t\t// If too tall, go to new column\n\t\t\t\t\t\tif (currentColHeight + itemHeight > minSize.height) {\n\t\t\t\t\t\t\ttotalWidth += currentColWidth + labelOpts.padding;\n\t\t\t\t\t\t\tcolumnWidths.push(currentColWidth); // previous column width\n\n\t\t\t\t\t\t\tcurrentColWidth = 0;\n\t\t\t\t\t\t\tcurrentColHeight = 0;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Get max width\n\t\t\t\t\t\tcurrentColWidth = Math.max(currentColWidth, itemWidth);\n\t\t\t\t\t\tcurrentColHeight += itemHeight;\n\n\t\t\t\t\t\t// Store the hitbox width and height here. Final position will be updated in `draw`\n\t\t\t\t\t\thitboxes[i] = {\n\t\t\t\t\t\t\tleft: 0,\n\t\t\t\t\t\t\ttop: 0,\n\t\t\t\t\t\t\twidth: itemWidth,\n\t\t\t\t\t\t\theight: fontSize\n\t\t\t\t\t\t};\n\t\t\t\t\t});\n\n\t\t\t\t\ttotalWidth += currentColWidth;\n\t\t\t\t\tcolumnWidths.push(currentColWidth);\n\t\t\t\t\tminSize.width += totalWidth;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tme.width = minSize.width;\n\t\t\tme.height = minSize.height;\n\t\t},\n\t\tafterFit: noop,\n\n\t\t// Shared Methods\n\t\tisHorizontal: function() {\n\t\t\treturn this.options.position === 'top' || this.options.position === 'bottom';\n\t\t},\n\n\t\t// Actually draw the legend on the canvas\n\t\tdraw: function() {\n\t\t\tvar me = this;\n\t\t\tvar opts = me.options;\n\t\t\tvar labelOpts = opts.labels;\n\t\t\tvar globalDefault = Chart.defaults.global,\n\t\t\t\tlineDefault = globalDefault.elements.line,\n\t\t\t\tlegendWidth = me.width,\n\t\t\t\tlineWidths = me.lineWidths;\n\n\t\t\tif (opts.display) {\n\t\t\t\tvar ctx = me.ctx,\n\t\t\t\t\tcursor,\n\t\t\t\t\titemOrDefault = helpers.getValueOrDefault,\n\t\t\t\t\tfontColor = itemOrDefault(labelOpts.fontColor, globalDefault.defaultFontColor),\n\t\t\t\t\tfontSize = itemOrDefault(labelOpts.fontSize, globalDefault.defaultFontSize),\n\t\t\t\t\tfontStyle = itemOrDefault(labelOpts.fontStyle, globalDefault.defaultFontStyle),\n\t\t\t\t\tfontFamily = itemOrDefault(labelOpts.fontFamily, globalDefault.defaultFontFamily),\n\t\t\t\t\tlabelFont = helpers.fontString(fontSize, fontStyle, fontFamily);\n\n\t\t\t\t// Canvas setup\n\t\t\t\tctx.textAlign = 'left';\n\t\t\t\tctx.textBaseline = 'top';\n\t\t\t\tctx.lineWidth = 0.5;\n\t\t\t\tctx.strokeStyle = fontColor; // for strikethrough effect\n\t\t\t\tctx.fillStyle = fontColor; // render in correct colour\n\t\t\t\tctx.font = labelFont;\n\n\t\t\t\tvar boxWidth = getBoxWidth(labelOpts, fontSize),\n\t\t\t\t\thitboxes = me.legendHitBoxes;\n\n\t\t\t\t// current position\n\t\t\t\tvar drawLegendBox = function(x, y, legendItem) {\n\t\t\t\t\tif (isNaN(boxWidth) || boxWidth <= 0) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Set the ctx for the box\n\t\t\t\t\tctx.save();\n\n\t\t\t\t\tctx.fillStyle = itemOrDefault(legendItem.fillStyle, globalDefault.defaultColor);\n\t\t\t\t\tctx.lineCap = itemOrDefault(legendItem.lineCap, lineDefault.borderCapStyle);\n\t\t\t\t\tctx.lineDashOffset = itemOrDefault(legendItem.lineDashOffset, lineDefault.borderDashOffset);\n\t\t\t\t\tctx.lineJoin = itemOrDefault(legendItem.lineJoin, lineDefault.borderJoinStyle);\n\t\t\t\t\tctx.lineWidth = itemOrDefault(legendItem.lineWidth, lineDefault.borderWidth);\n\t\t\t\t\tctx.strokeStyle = itemOrDefault(legendItem.strokeStyle, globalDefault.defaultColor);\n\t\t\t\t\tvar isLineWidthZero = (itemOrDefault(legendItem.lineWidth, lineDefault.borderWidth) === 0);\n\n\t\t\t\t\tif (ctx.setLineDash) {\n\t\t\t\t\t\t// IE 9 and 10 do not support line dash\n\t\t\t\t\t\tctx.setLineDash(itemOrDefault(legendItem.lineDash, lineDefault.borderDash));\n\t\t\t\t\t}\n\n\t\t\t\t\tif (opts.labels && opts.labels.usePointStyle) {\n\t\t\t\t\t\t// Recalculate x and y for drawPoint() because its expecting\n\t\t\t\t\t\t// x and y to be center of figure (instead of top left)\n\t\t\t\t\t\tvar radius = fontSize * Math.SQRT2 / 2;\n\t\t\t\t\t\tvar offSet = radius / Math.SQRT2;\n\t\t\t\t\t\tvar centerX = x + offSet;\n\t\t\t\t\t\tvar centerY = y + offSet;\n\n\t\t\t\t\t\t// Draw pointStyle as legend symbol\n\t\t\t\t\t\tChart.canvasHelpers.drawPoint(ctx, legendItem.pointStyle, radius, centerX, centerY);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Draw box as legend symbol\n\t\t\t\t\t\tif (!isLineWidthZero) {\n\t\t\t\t\t\t\tctx.strokeRect(x, y, boxWidth, fontSize);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tctx.fillRect(x, y, boxWidth, fontSize);\n\t\t\t\t\t}\n\n\t\t\t\t\tctx.restore();\n\t\t\t\t};\n\t\t\t\tvar fillText = function(x, y, legendItem, textWidth) {\n\t\t\t\t\tctx.fillText(legendItem.text, boxWidth + (fontSize / 2) + x, y);\n\n\t\t\t\t\tif (legendItem.hidden) {\n\t\t\t\t\t\t// Strikethrough the text if hidden\n\t\t\t\t\t\tctx.beginPath();\n\t\t\t\t\t\tctx.lineWidth = 2;\n\t\t\t\t\t\tctx.moveTo(boxWidth + (fontSize / 2) + x, y + (fontSize / 2));\n\t\t\t\t\t\tctx.lineTo(boxWidth + (fontSize / 2) + x + textWidth, y + (fontSize / 2));\n\t\t\t\t\t\tctx.stroke();\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\t// Horizontal\n\t\t\t\tvar isHorizontal = me.isHorizontal();\n\t\t\t\tif (isHorizontal) {\n\t\t\t\t\tcursor = {\n\t\t\t\t\t\tx: me.left + ((legendWidth - lineWidths[0]) / 2),\n\t\t\t\t\t\ty: me.top + labelOpts.padding,\n\t\t\t\t\t\tline: 0\n\t\t\t\t\t};\n\t\t\t\t} else {\n\t\t\t\t\tcursor = {\n\t\t\t\t\t\tx: me.left + labelOpts.padding,\n\t\t\t\t\t\ty: me.top + labelOpts.padding,\n\t\t\t\t\t\tline: 0\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\tvar itemHeight = fontSize + labelOpts.padding;\n\t\t\t\thelpers.each(me.legendItems, function(legendItem, i) {\n\t\t\t\t\tvar textWidth = ctx.measureText(legendItem.text).width,\n\t\t\t\t\t\twidth = boxWidth + (fontSize / 2) + textWidth,\n\t\t\t\t\t\tx = cursor.x,\n\t\t\t\t\t\ty = cursor.y;\n\n\t\t\t\t\tif (isHorizontal) {\n\t\t\t\t\t\tif (x + width >= legendWidth) {\n\t\t\t\t\t\t\ty = cursor.y += itemHeight;\n\t\t\t\t\t\t\tcursor.line++;\n\t\t\t\t\t\t\tx = cursor.x = me.left + ((legendWidth - lineWidths[cursor.line]) / 2);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (y + itemHeight > me.bottom) {\n\t\t\t\t\t\tx = cursor.x = x + me.columnWidths[cursor.line] + labelOpts.padding;\n\t\t\t\t\t\ty = cursor.y = me.top + labelOpts.padding;\n\t\t\t\t\t\tcursor.line++;\n\t\t\t\t\t}\n\n\t\t\t\t\tdrawLegendBox(x, y, legendItem);\n\n\t\t\t\t\thitboxes[i].left = x;\n\t\t\t\t\thitboxes[i].top = y;\n\n\t\t\t\t\t// Fill the actual label\n\t\t\t\t\tfillText(x, y, legendItem, textWidth);\n\n\t\t\t\t\tif (isHorizontal) {\n\t\t\t\t\t\tcursor.x += width + (labelOpts.padding);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcursor.y += itemHeight;\n\t\t\t\t\t}\n\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Handle an event\n\t\t * @private\n\t\t * @param {IEvent} event - The event to handle\n\t\t * @return {Boolean} true if a change occured\n\t\t */\n\t\thandleEvent: function(e) {\n\t\t\tvar me = this;\n\t\t\tvar opts = me.options;\n\t\t\tvar type = e.type === 'mouseup' ? 'click' : e.type;\n\t\t\tvar changed = false;\n\n\t\t\tif (type === 'mousemove') {\n\t\t\t\tif (!opts.onHover) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else if (type === 'click') {\n\t\t\t\tif (!opts.onClick) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Chart event already has relative position in it\n\t\t\tvar x = e.x,\n\t\t\t\ty = e.y;\n\n\t\t\tif (x >= me.left && x <= me.right && y >= me.top && y <= me.bottom) {\n\t\t\t\t// See if we are touching one of the dataset boxes\n\t\t\t\tvar lh = me.legendHitBoxes;\n\t\t\t\tfor (var i = 0; i < lh.length; ++i) {\n\t\t\t\t\tvar hitBox = lh[i];\n\n\t\t\t\t\tif (x >= hitBox.left && x <= hitBox.left + hitBox.width && y >= hitBox.top && y <= hitBox.top + hitBox.height) {\n\t\t\t\t\t\t// Touching an element\n\t\t\t\t\t\tif (type === 'click') {\n\t\t\t\t\t\t\t// use e.native for backwards compatibility\n\t\t\t\t\t\t\topts.onClick.call(me, e.native, me.legendItems[i]);\n\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else if (type === 'mousemove') {\n\t\t\t\t\t\t\t// use e.native for backwards compatibility\n\t\t\t\t\t\t\topts.onHover.call(me, e.native, me.legendItems[i]);\n\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn changed;\n\t\t}\n\t});\n\n\tfunction createNewLegendAndAttach(chartInstance, legendOpts) {\n\t\tvar legend = new Chart.Legend({\n\t\t\tctx: chartInstance.chart.ctx,\n\t\t\toptions: legendOpts,\n\t\t\tchart: chartInstance\n\t\t});\n\t\tchartInstance.legend = legend;\n\t\tChart.layoutService.addBox(chartInstance, legend);\n\t}\n\n\t// Register the legend plugin\n\tChart.plugins.register({\n\t\tbeforeInit: function(chartInstance) {\n\t\t\tvar legendOpts = chartInstance.options.legend;\n\n\t\t\tif (legendOpts) {\n\t\t\t\tcreateNewLegendAndAttach(chartInstance, legendOpts);\n\t\t\t}\n\t\t},\n\t\tbeforeUpdate: function(chartInstance) {\n\t\t\tvar legendOpts = chartInstance.options.legend;\n\n\t\t\tif (legendOpts) {\n\t\t\t\tlegendOpts = helpers.configMerge(Chart.defaults.global.legend, legendOpts);\n\n\t\t\t\tif (chartInstance.legend) {\n\t\t\t\t\tchartInstance.legend.options = legendOpts;\n\t\t\t\t} else {\n\t\t\t\t\tcreateNewLegendAndAttach(chartInstance, legendOpts);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tChart.layoutService.removeBox(chartInstance, chartInstance.legend);\n\t\t\t\tdelete chartInstance.legend;\n\t\t\t}\n\t\t},\n\t\tafterEvent: function(chartInstance, e) {\n\t\t\tvar legend = chartInstance.legend;\n\t\t\tif (legend) {\n\t\t\t\tlegend.handleEvent(e);\n\t\t\t}\n\t\t}\n\t});\n};\n\n},{}],31:[function(require,module,exports){\n'use strict';\n\nmodule.exports = function(Chart) {\n\n\tvar helpers = Chart.helpers;\n\n\tChart.defaults.global.plugins = {};\n\n\t/**\n\t * The plugin service singleton\n\t * @namespace Chart.plugins\n\t * @since 2.1.0\n\t */\n\tChart.plugins = {\n\t\t/**\n\t\t * Globally registered plugins.\n\t\t * @private\n\t\t */\n\t\t_plugins: [],\n\n\t\t/**\n\t\t * This identifier is used to invalidate the descriptors cache attached to each chart\n\t\t * when a global plugin is registered or unregistered. In this case, the cache ID is\n\t\t * incremented and descriptors are regenerated during following API calls.\n\t\t * @private\n\t\t */\n\t\t_cacheId: 0,\n\n\t\t/**\n\t\t * Registers the given plugin(s) if not already registered.\n\t\t * @param {Array|Object} plugins plugin instance(s).\n\t\t */\n\t\tregister: function(plugins) {\n\t\t\tvar p = this._plugins;\n\t\t\t([]).concat(plugins).forEach(function(plugin) {\n\t\t\t\tif (p.indexOf(plugin) === -1) {\n\t\t\t\t\tp.push(plugin);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tthis._cacheId++;\n\t\t},\n\n\t\t/**\n\t\t * Unregisters the given plugin(s) only if registered.\n\t\t * @param {Array|Object} plugins plugin instance(s).\n\t\t */\n\t\tunregister: function(plugins) {\n\t\t\tvar p = this._plugins;\n\t\t\t([]).concat(plugins).forEach(function(plugin) {\n\t\t\t\tvar idx = p.indexOf(plugin);\n\t\t\t\tif (idx !== -1) {\n\t\t\t\t\tp.splice(idx, 1);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tthis._cacheId++;\n\t\t},\n\n\t\t/**\n\t\t * Remove all registered plugins.\n\t\t * @since 2.1.5\n\t\t */\n\t\tclear: function() {\n\t\t\tthis._plugins = [];\n\t\t\tthis._cacheId++;\n\t\t},\n\n\t\t/**\n\t\t * Returns the number of registered plugins?\n\t\t * @returns {Number}\n\t\t * @since 2.1.5\n\t\t */\n\t\tcount: function() {\n\t\t\treturn this._plugins.length;\n\t\t},\n\n\t\t/**\n\t\t * Returns all registered plugin instances.\n\t\t * @returns {Array} array of plugin objects.\n\t\t * @since 2.1.5\n\t\t */\n\t\tgetAll: function() {\n\t\t\treturn this._plugins;\n\t\t},\n\n\t\t/**\n\t\t * Calls enabled plugins for `chart` on the specified hook and with the given args.\n\t\t * This method immediately returns as soon as a plugin explicitly returns false. The\n\t\t * returned value can be used, for instance, to interrupt the current action.\n\t\t * @param {Object} chart - The chart instance for which plugins should be called.\n\t\t * @param {String} hook - The name of the plugin method to call (e.g. 'beforeUpdate').\n\t\t * @param {Array} [args] - Extra arguments to apply to the hook call.\n\t\t * @returns {Boolean} false if any of the plugins return false, else returns true.\n\t\t */\n\t\tnotify: function(chart, hook, args) {\n\t\t\tvar descriptors = this.descriptors(chart);\n\t\t\tvar ilen = descriptors.length;\n\t\t\tvar i, descriptor, plugin, params, method;\n\n\t\t\tfor (i=0; i<ilen; ++i) {\n\t\t\t\tdescriptor = descriptors[i];\n\t\t\t\tplugin = descriptor.plugin;\n\t\t\t\tmethod = plugin[hook];\n\t\t\t\tif (typeof method === 'function') {\n\t\t\t\t\tparams = [chart].concat(args || []);\n\t\t\t\t\tparams.push(descriptor.options);\n\t\t\t\t\tif (method.apply(plugin, params) === false) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn true;\n\t\t},\n\n\t\t/**\n\t\t * Returns descriptors of enabled plugins for the given chart.\n\t\t * @returns {Array} [{ plugin, options }]\n\t\t * @private\n\t\t */\n\t\tdescriptors: function(chart) {\n\t\t\tvar cache = chart._plugins || (chart._plugins = {});\n\t\t\tif (cache.id === this._cacheId) {\n\t\t\t\treturn cache.descriptors;\n\t\t\t}\n\n\t\t\tvar plugins = [];\n\t\t\tvar descriptors = [];\n\t\t\tvar config = (chart && chart.config) || {};\n\t\t\tvar defaults = Chart.defaults.global.plugins;\n\t\t\tvar options = (config.options && config.options.plugins) || {};\n\n\t\t\tthis._plugins.concat(config.plugins || []).forEach(function(plugin) {\n\t\t\t\tvar idx = plugins.indexOf(plugin);\n\t\t\t\tif (idx !== -1) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tvar id = plugin.id;\n\t\t\t\tvar opts = options[id];\n\t\t\t\tif (opts === false) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (opts === true) {\n\t\t\t\t\topts = helpers.clone(defaults[id]);\n\t\t\t\t}\n\n\t\t\t\tplugins.push(plugin);\n\t\t\t\tdescriptors.push({\n\t\t\t\t\tplugin: plugin,\n\t\t\t\t\toptions: opts || {}\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tcache.descriptors = descriptors;\n\t\t\tcache.id = this._cacheId;\n\t\t\treturn descriptors;\n\t\t}\n\t};\n\n\t/**\n\t * Plugin extension hooks.\n\t * @interface IPlugin\n\t * @since 2.1.0\n\t */\n\t/**\n\t * @method IPlugin#beforeInit\n\t * @desc Called before initializing `chart`.\n\t * @param {Chart.Controller} chart - The chart instance.\n\t * @param {Object} options - The plugin options.\n\t */\n\t/**\n\t * @method IPlugin#afterInit\n\t * @desc Called after `chart` has been initialized and before the first update.\n\t * @param {Chart.Controller} chart - The chart instance.\n\t * @param {Object} options - The plugin options.\n\t */\n\t/**\n\t * @method IPlugin#beforeUpdate\n\t * @desc Called before updating `chart`. If any plugin returns `false`, the update\n\t * is cancelled (and thus subsequent render(s)) until another `update` is triggered.\n\t * @param {Chart.Controller} chart - The chart instance.\n\t * @param {Object} options - The plugin options.\n\t * @returns {Boolean} `false` to cancel the chart update.\n\t */\n\t/**\n\t * @method IPlugin#afterUpdate\n\t * @desc Called after `chart` has been updated and before rendering. Note that this\n\t * hook will not be called if the chart update has been previously cancelled.\n\t * @param {Chart.Controller} chart - The chart instance.\n\t * @param {Object} options - The plugin options.\n\t */\n\t/**\n\t * @method IPlugin#beforeDatasetsUpdate\n \t * @desc Called before updating the `chart` datasets. If any plugin returns `false`,\n\t * the datasets update is cancelled until another `update` is triggered.\n\t * @param {Chart.Controller} chart - The chart instance.\n\t * @param {Object} options - The plugin options.\n\t * @returns {Boolean} false to cancel the datasets update.\n\t * @since version 2.1.5\n\t */\n\t/**\n\t * @method IPlugin#afterDatasetsUpdate\n\t * @desc Called after the `chart` datasets have been updated. Note that this hook\n\t * will not be called if the datasets update has been previously cancelled.\n\t * @param {Chart.Controller} chart - The chart instance.\n\t * @param {Object} options - The plugin options.\n\t * @since version 2.1.5\n\t */\n\t/**\n\t * @method IPlugin#beforeLayout\n\t * @desc Called before laying out `chart`. If any plugin returns `false`,\n\t * the layout update is cancelled until another `update` is triggered.\n\t * @param {Chart.Controller} chart - The chart instance.\n\t * @param {Object} options - The plugin options.\n\t * @returns {Boolean} `false` to cancel the chart layout.\n\t */\n\t/**\n\t * @method IPlugin#afterLayout\n\t * @desc Called after the `chart` has been layed out. Note that this hook will not\n\t * be called if the layout update has been previously cancelled.\n\t * @param {Chart.Controller} chart - The chart instance.\n\t * @param {Object} options - The plugin options.\n\t */\n\t/**\n\t * @method IPlugin#beforeRender\n\t * @desc Called before rendering `chart`. If any plugin returns `false`,\n\t * the rendering is cancelled until another `render` is triggered.\n\t * @param {Chart.Controller} chart - The chart instance.\n\t * @param {Object} options - The plugin options.\n\t * @returns {Boolean} `false` to cancel the chart rendering.\n\t */\n\t/**\n\t * @method IPlugin#afterRender\n\t * @desc Called after the `chart` has been fully rendered (and animation completed). Note\n\t * that this hook will not be called if the rendering has been previously cancelled.\n\t * @param {Chart.Controller} chart - The chart instance.\n\t * @param {Object} options - The plugin options.\n\t */\n\t/**\n\t * @method IPlugin#beforeDraw\n\t * @desc Called before drawing `chart` at every animation frame specified by the given\n\t * easing value. If any plugin returns `false`, the frame drawing is cancelled until\n\t * another `render` is triggered.\n\t * @param {Chart.Controller} chart - The chart instance.\n\t * @param {Number} easingValue - The current animation value, between 0.0 and 1.0.\n\t * @param {Object} options - The plugin options.\n\t * @returns {Boolean} `false` to cancel the chart drawing.\n\t */\n\t/**\n\t * @method IPlugin#afterDraw\n\t * @desc Called after the `chart` has been drawn for the specific easing value. Note\n\t * that this hook will not be called if the drawing has been previously cancelled.\n\t * @param {Chart.Controller} chart - The chart instance.\n\t * @param {Number} easingValue - The current animation value, between 0.0 and 1.0.\n\t * @param {Object} options - The plugin options.\n\t */\n\t/**\n\t * @method IPlugin#beforeDatasetsDraw\n \t * @desc Called before drawing the `chart` datasets. If any plugin returns `false`,\n\t * the datasets drawing is cancelled until another `render` is triggered.\n\t * @param {Chart.Controller} chart - The chart instance.\n\t * @param {Number} easingValue - The current animation value, between 0.0 and 1.0.\n\t * @param {Object} options - The plugin options.\n\t * @returns {Boolean} `false` to cancel the chart datasets drawing.\n\t */\n\t/**\n\t * @method IPlugin#afterDatasetsDraw\n\t * @desc Called after the `chart` datasets have been drawn. Note that this hook\n\t * will not be called if the datasets drawing has been previously cancelled.\n\t * @param {Chart.Controller} chart - The chart instance.\n\t * @param {Number} easingValue - The current animation value, between 0.0 and 1.0.\n\t * @param {Object} options - The plugin options.\n\t */\n\t/**\n\t * @method IPlugin#beforeEvent\n \t * @desc Called before processing the specified `event`. If any plugin returns `false`,\n\t * the event will be discarded.\n\t * @param {Chart.Controller} chart - The chart instance.\n\t * @param {IEvent} event - The event object.\n\t * @param {Object} options - The plugin options.\n\t */\n\t/**\n\t * @method IPlugin#afterEvent\n\t * @desc Called after the `event` has been consumed. Note that this hook\n\t * will not be called if the `event` has been previously discarded.\n\t * @param {Chart.Controller} chart - The chart instance.\n\t * @param {IEvent} event - The event object.\n\t * @param {Object} options - The plugin options.\n\t */\n\t/**\n\t * @method IPlugin#resize\n\t * @desc Called after the chart as been resized.\n\t * @param {Chart.Controller} chart - The chart instance.\n\t * @param {Number} size - The new canvas display size (eq. canvas.style width & height).\n\t * @param {Object} options - The plugin options.\n\t */\n\t/**\n\t * @method IPlugin#destroy\n\t * @desc Called after the chart as been destroyed.\n\t * @param {Chart.Controller} chart - The chart instance.\n\t * @param {Object} options - The plugin options.\n\t */\n\n\t/**\n\t * Provided for backward compatibility, use Chart.plugins instead\n\t * @namespace Chart.pluginService\n\t * @deprecated since version 2.1.5\n\t * @todo remove at version 3\n\t * @private\n\t */\n\tChart.pluginService = Chart.plugins;\n\n\t/**\n\t * Provided for backward compatibility, inheriting from Chart.PlugingBase has no\n\t * effect, instead simply create/register plugins via plain JavaScript objects.\n\t * @interface Chart.PluginBase\n\t * @deprecated since version 2.5.0\n\t * @todo remove at version 3\n\t * @private\n\t */\n\tChart.PluginBase = helpers.inherits({});\n};\n\n},{}],32:[function(require,module,exports){\n'use strict';\n\nmodule.exports = function(Chart) {\n\n\tvar helpers = Chart.helpers;\n\n\tChart.defaults.scale = {\n\t\tdisplay: true,\n\t\tposition: 'left',\n\n\t\t// grid line settings\n\t\tgridLines: {\n\t\t\tdisplay: true,\n\t\t\tcolor: 'rgba(0, 0, 0, 0.1)',\n\t\t\tlineWidth: 1,\n\t\t\tdrawBorder: true,\n\t\t\tdrawOnChartArea: true,\n\t\t\tdrawTicks: true,\n\t\t\ttickMarkLength: 10,\n\t\t\tzeroLineWidth: 1,\n\t\t\tzeroLineColor: 'rgba(0,0,0,0.25)',\n\t\t\toffsetGridLines: false,\n\t\t\tborderDash: [],\n\t\t\tborderDashOffset: 0.0\n\t\t},\n\n\t\t// scale label\n\t\tscaleLabel: {\n\t\t\t// actual label\n\t\t\tlabelString: '',\n\n\t\t\t// display property\n\t\t\tdisplay: false\n\t\t},\n\n\t\t// label settings\n\t\tticks: {\n\t\t\tbeginAtZero: false,\n\t\t\tminRotation: 0,\n\t\t\tmaxRotation: 50,\n\t\t\tmirror: false,\n\t\t\tpadding: 0,\n\t\t\treverse: false,\n\t\t\tdisplay: true,\n\t\t\tautoSkip: true,\n\t\t\tautoSkipPadding: 0,\n\t\t\tlabelOffset: 0,\n\t\t\t// We pass through arrays to be rendered as multiline labels, we convert Others to strings here.\n\t\t\tcallback: Chart.Ticks.formatters.values\n\t\t}\n\t};\n\n\tfunction computeTextSize(context, tick, font) {\n\t\treturn helpers.isArray(tick) ?\n\t\t\thelpers.longestText(context, font, tick) :\n\t\t\tcontext.measureText(tick).width;\n\t}\n\n\tfunction parseFontOptions(options) {\n\t\tvar getValueOrDefault = helpers.getValueOrDefault;\n\t\tvar globalDefaults = Chart.defaults.global;\n\t\tvar size = getValueOrDefault(options.fontSize, globalDefaults.defaultFontSize);\n\t\tvar style = getValueOrDefault(options.fontStyle, globalDefaults.defaultFontStyle);\n\t\tvar family = getValueOrDefault(options.fontFamily, globalDefaults.defaultFontFamily);\n\n\t\treturn {\n\t\t\tsize: size,\n\t\t\tstyle: style,\n\t\t\tfamily: family,\n\t\t\tfont: helpers.fontString(size, style, family)\n\t\t};\n\t}\n\n\tChart.Scale = Chart.Element.extend({\n\t\t/**\n\t\t * Get the padding needed for the scale\n\t\t * @method getPadding\n\t\t * @private\n\t\t * @returns {Padding} the necessary padding\n\t\t */\n\t\tgetPadding: function() {\n\t\t\tvar me = this;\n\t\t\treturn {\n\t\t\t\tleft: me.paddingLeft || 0,\n\t\t\t\ttop: me.paddingTop || 0,\n\t\t\t\tright: me.paddingRight || 0,\n\t\t\t\tbottom: me.paddingBottom || 0\n\t\t\t};\n\t\t},\n\n\t\t// These methods are ordered by lifecyle. Utilities then follow.\n\t\t// Any function defined here is inherited by all scale types.\n\t\t// Any function can be extended by the scale type\n\n\t\tbeforeUpdate: function() {\n\t\t\thelpers.callCallback(this.options.beforeUpdate, [this]);\n\t\t},\n\t\tupdate: function(maxWidth, maxHeight, margins) {\n\t\t\tvar me = this;\n\n\t\t\t// Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)\n\t\t\tme.beforeUpdate();\n\n\t\t\t// Absorb the master measurements\n\t\t\tme.maxWidth = maxWidth;\n\t\t\tme.maxHeight = maxHeight;\n\t\t\tme.margins = helpers.extend({\n\t\t\t\tleft: 0,\n\t\t\t\tright: 0,\n\t\t\t\ttop: 0,\n\t\t\t\tbottom: 0\n\t\t\t}, margins);\n\t\t\tme.longestTextCache = me.longestTextCache || {};\n\n\t\t\t// Dimensions\n\t\t\tme.beforeSetDimensions();\n\t\t\tme.setDimensions();\n\t\t\tme.afterSetDimensions();\n\n\t\t\t// Data min/max\n\t\t\tme.beforeDataLimits();\n\t\t\tme.determineDataLimits();\n\t\t\tme.afterDataLimits();\n\n\t\t\t// Ticks\n\t\t\tme.beforeBuildTicks();\n\t\t\tme.buildTicks();\n\t\t\tme.afterBuildTicks();\n\n\t\t\tme.beforeTickToLabelConversion();\n\t\t\tme.convertTicksToLabels();\n\t\t\tme.afterTickToLabelConversion();\n\n\t\t\t// Tick Rotation\n\t\t\tme.beforeCalculateTickRotation();\n\t\t\tme.calculateTickRotation();\n\t\t\tme.afterCalculateTickRotation();\n\t\t\t// Fit\n\t\t\tme.beforeFit();\n\t\t\tme.fit();\n\t\t\tme.afterFit();\n\t\t\t//\n\t\t\tme.afterUpdate();\n\n\t\t\treturn me.minSize;\n\n\t\t},\n\t\tafterUpdate: function() {\n\t\t\thelpers.callCallback(this.options.afterUpdate, [this]);\n\t\t},\n\n\t\t//\n\n\t\tbeforeSetDimensions: function() {\n\t\t\thelpers.callCallback(this.options.beforeSetDimensions, [this]);\n\t\t},\n\t\tsetDimensions: function() {\n\t\t\tvar me = this;\n\t\t\t// Set the unconstrained dimension before label rotation\n\t\t\tif (me.isHorizontal()) {\n\t\t\t\t// Reset position before calculating rotation\n\t\t\t\tme.width = me.maxWidth;\n\t\t\t\tme.left = 0;\n\t\t\t\tme.right = me.width;\n\t\t\t} else {\n\t\t\t\tme.height = me.maxHeight;\n\n\t\t\t\t// Reset position before calculating rotation\n\t\t\t\tme.top = 0;\n\t\t\t\tme.bottom = me.height;\n\t\t\t}\n\n\t\t\t// Reset padding\n\t\t\tme.paddingLeft = 0;\n\t\t\tme.paddingTop = 0;\n\t\t\tme.paddingRight = 0;\n\t\t\tme.paddingBottom = 0;\n\t\t},\n\t\tafterSetDimensions: function() {\n\t\t\thelpers.callCallback(this.options.afterSetDimensions, [this]);\n\t\t},\n\n\t\t// Data limits\n\t\tbeforeDataLimits: function() {\n\t\t\thelpers.callCallback(this.options.beforeDataLimits, [this]);\n\t\t},\n\t\tdetermineDataLimits: helpers.noop,\n\t\tafterDataLimits: function() {\n\t\t\thelpers.callCallback(this.options.afterDataLimits, [this]);\n\t\t},\n\n\t\t//\n\t\tbeforeBuildTicks: function() {\n\t\t\thelpers.callCallback(this.options.beforeBuildTicks, [this]);\n\t\t},\n\t\tbuildTicks: helpers.noop,\n\t\tafterBuildTicks: function() {\n\t\t\thelpers.callCallback(this.options.afterBuildTicks, [this]);\n\t\t},\n\n\t\tbeforeTickToLabelConversion: function() {\n\t\t\thelpers.callCallback(this.options.beforeTickToLabelConversion, [this]);\n\t\t},\n\t\tconvertTicksToLabels: function() {\n\t\t\tvar me = this;\n\t\t\t// Convert ticks to strings\n\t\t\tvar tickOpts = me.options.ticks;\n\t\t\tme.ticks = me.ticks.map(tickOpts.userCallback || tickOpts.callback);\n\t\t},\n\t\tafterTickToLabelConversion: function() {\n\t\t\thelpers.callCallback(this.options.afterTickToLabelConversion, [this]);\n\t\t},\n\n\t\t//\n\n\t\tbeforeCalculateTickRotation: function() {\n\t\t\thelpers.callCallback(this.options.beforeCalculateTickRotation, [this]);\n\t\t},\n\t\tcalculateTickRotation: function() {\n\t\t\tvar me = this;\n\t\t\tvar context = me.ctx;\n\t\t\tvar tickOpts = me.options.ticks;\n\n\t\t\t// Get the width of each grid by calculating the difference\n\t\t\t// between x offsets between 0 and 1.\n\t\t\tvar tickFont = parseFontOptions(tickOpts);\n\t\t\tcontext.font = tickFont.font;\n\n\t\t\tvar labelRotation = tickOpts.minRotation || 0;\n\n\t\t\tif (me.options.display && me.isHorizontal()) {\n\t\t\t\tvar originalLabelWidth = helpers.longestText(context, tickFont.font, me.ticks, me.longestTextCache);\n\t\t\t\tvar labelWidth = originalLabelWidth;\n\t\t\t\tvar cosRotation;\n\t\t\t\tvar sinRotation;\n\n\t\t\t\t// Allow 3 pixels x2 padding either side for label readability\n\t\t\t\tvar tickWidth = me.getPixelForTick(1) - me.getPixelForTick(0) - 6;\n\n\t\t\t\t// Max label rotation can be set or default to 90 - also act as a loop counter\n\t\t\t\twhile (labelWidth > tickWidth && labelRotation < tickOpts.maxRotation) {\n\t\t\t\t\tvar angleRadians = helpers.toRadians(labelRotation);\n\t\t\t\t\tcosRotation = Math.cos(angleRadians);\n\t\t\t\t\tsinRotation = Math.sin(angleRadians);\n\n\t\t\t\t\tif (sinRotation * originalLabelWidth > me.maxHeight) {\n\t\t\t\t\t\t// go back one step\n\t\t\t\t\t\tlabelRotation--;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tlabelRotation++;\n\t\t\t\t\tlabelWidth = cosRotation * originalLabelWidth;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tme.labelRotation = labelRotation;\n\t\t},\n\t\tafterCalculateTickRotation: function() {\n\t\t\thelpers.callCallback(this.options.afterCalculateTickRotation, [this]);\n\t\t},\n\n\t\t//\n\n\t\tbeforeFit: function() {\n\t\t\thelpers.callCallback(this.options.beforeFit, [this]);\n\t\t},\n\t\tfit: function() {\n\t\t\tvar me = this;\n\t\t\t// Reset\n\t\t\tvar minSize = me.minSize = {\n\t\t\t\twidth: 0,\n\t\t\t\theight: 0\n\t\t\t};\n\n\t\t\tvar opts = me.options;\n\t\t\tvar tickOpts = opts.ticks;\n\t\t\tvar scaleLabelOpts = opts.scaleLabel;\n\t\t\tvar gridLineOpts = opts.gridLines;\n\t\t\tvar display = opts.display;\n\t\t\tvar isHorizontal = me.isHorizontal();\n\n\t\t\tvar tickFont = parseFontOptions(tickOpts);\n\t\t\tvar scaleLabelFontSize = parseFontOptions(scaleLabelOpts).size * 1.5;\n\t\t\tvar tickMarkLength = opts.gridLines.tickMarkLength;\n\n\t\t\t// Width\n\t\t\tif (isHorizontal) {\n\t\t\t\t// subtract the margins to line up with the chartArea if we are a full width scale\n\t\t\t\tminSize.width = me.isFullWidth() ? me.maxWidth - me.margins.left - me.margins.right : me.maxWidth;\n\t\t\t} else {\n\t\t\t\tminSize.width = display && gridLineOpts.drawTicks ? tickMarkLength : 0;\n\t\t\t}\n\n\t\t\t// height\n\t\t\tif (isHorizontal) {\n\t\t\t\tminSize.height = display && gridLineOpts.drawTicks ? tickMarkLength : 0;\n\t\t\t} else {\n\t\t\t\tminSize.height = me.maxHeight; // fill all the height\n\t\t\t}\n\n\t\t\t// Are we showing a title for the scale?\n\t\t\tif (scaleLabelOpts.display && display) {\n\t\t\t\tif (isHorizontal) {\n\t\t\t\t\tminSize.height += scaleLabelFontSize;\n\t\t\t\t} else {\n\t\t\t\t\tminSize.width += scaleLabelFontSize;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Don't bother fitting the ticks if we are not showing them\n\t\t\tif (tickOpts.display && display) {\n\t\t\t\tvar largestTextWidth = helpers.longestText(me.ctx, tickFont.font, me.ticks, me.longestTextCache);\n\t\t\t\tvar tallestLabelHeightInLines = helpers.numberOfLabelLines(me.ticks);\n\t\t\t\tvar lineSpace = tickFont.size * 0.5;\n\n\t\t\t\tif (isHorizontal) {\n\t\t\t\t\t// A horizontal axis is more constrained by the height.\n\t\t\t\t\tme.longestLabelWidth = largestTextWidth;\n\n\t\t\t\t\tvar angleRadians = helpers.toRadians(me.labelRotation);\n\t\t\t\t\tvar cosRotation = Math.cos(angleRadians);\n\t\t\t\t\tvar sinRotation = Math.sin(angleRadians);\n\n\t\t\t\t\t// TODO - improve this calculation\n\t\t\t\t\tvar labelHeight = (sinRotation * largestTextWidth)\n\t\t\t\t\t\t+ (tickFont.size * tallestLabelHeightInLines)\n\t\t\t\t\t\t+ (lineSpace * tallestLabelHeightInLines);\n\n\t\t\t\t\tminSize.height = Math.min(me.maxHeight, minSize.height + labelHeight);\n\t\t\t\t\tme.ctx.font = tickFont.font;\n\n\t\t\t\t\tvar firstTick = me.ticks[0];\n\t\t\t\t\tvar firstLabelWidth = computeTextSize(me.ctx, firstTick, tickFont.font);\n\n\t\t\t\t\tvar lastTick = me.ticks[me.ticks.length - 1];\n\t\t\t\t\tvar lastLabelWidth = computeTextSize(me.ctx, lastTick, tickFont.font);\n\n\t\t\t\t\t// Ensure that our ticks are always inside the canvas. When rotated, ticks are right aligned which means that the right padding is dominated\n\t\t\t\t\t// by the font height\n\t\t\t\t\tif (me.labelRotation !== 0) {\n\t\t\t\t\t\tme.paddingLeft = opts.position === 'bottom'? (cosRotation * firstLabelWidth) + 3: (cosRotation * lineSpace) + 3; // add 3 px to move away from canvas edges\n\t\t\t\t\t\tme.paddingRight = opts.position === 'bottom'? (cosRotation * lineSpace) + 3: (cosRotation * lastLabelWidth) + 3;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tme.paddingLeft = firstLabelWidth / 2 + 3; // add 3 px to move away from canvas edges\n\t\t\t\t\t\tme.paddingRight = lastLabelWidth / 2 + 3;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// A vertical axis is more constrained by the width. Labels are the dominant factor here, so get that length first\n\t\t\t\t\t// Account for padding\n\n\t\t\t\t\tif (tickOpts.mirror) {\n\t\t\t\t\t\tlargestTextWidth = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlargestTextWidth += me.options.ticks.padding;\n\t\t\t\t\t}\n\t\t\t\t\tminSize.width += largestTextWidth;\n\t\t\t\t\tme.paddingTop = tickFont.size / 2;\n\t\t\t\t\tme.paddingBottom = tickFont.size / 2;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tme.handleMargins();\n\n\t\t\tme.width = minSize.width;\n\t\t\tme.height = minSize.height;\n\t\t},\n\n\t\t/**\n\t\t * Handle margins and padding interactions\n\t\t * @private\n\t\t */\n\t\thandleMargins: function() {\n\t\t\tvar me = this;\n\t\t\tif (me.margins) {\n\t\t\t\tme.paddingLeft = Math.max(me.paddingLeft - me.margins.left, 0);\n\t\t\t\tme.paddingTop = Math.max(me.paddingTop - me.margins.top, 0);\n\t\t\t\tme.paddingRight = Math.max(me.paddingRight - me.margins.right, 0);\n\t\t\t\tme.paddingBottom = Math.max(me.paddingBottom - me.margins.bottom, 0);\n\t\t\t}\n\t\t},\n\n\t\tafterFit: function() {\n\t\t\thelpers.callCallback(this.options.afterFit, [this]);\n\t\t},\n\n\t\t// Shared Methods\n\t\tisHorizontal: function() {\n\t\t\treturn this.options.position === 'top' || this.options.position === 'bottom';\n\t\t},\n\t\tisFullWidth: function() {\n\t\t\treturn (this.options.fullWidth);\n\t\t},\n\n\t\t// Get the correct value. NaN bad inputs, If the value type is object get the x or y based on whether we are horizontal or not\n\t\tgetRightValue: function(rawValue) {\n\t\t\t// Null and undefined values first\n\t\t\tif (rawValue === null || typeof(rawValue) === 'undefined') {\n\t\t\t\treturn NaN;\n\t\t\t}\n\t\t\t// isNaN(object) returns true, so make sure NaN is checking for a number; Discard Infinite values\n\t\t\tif (typeof(rawValue) === 'number' && !isFinite(rawValue)) {\n\t\t\t\treturn NaN;\n\t\t\t}\n\t\t\t// If it is in fact an object, dive in one more level\n\t\t\tif (typeof(rawValue) === 'object') {\n\t\t\t\tif ((rawValue instanceof Date) || (rawValue.isValid)) {\n\t\t\t\t\treturn rawValue;\n\t\t\t\t}\n\t\t\t\treturn this.getRightValue(this.isHorizontal() ? rawValue.x : rawValue.y);\n\t\t\t}\n\n\t\t\t// Value is good, return it\n\t\t\treturn rawValue;\n\t\t},\n\n\t\t// Used to get the value to display in the tooltip for the data at the given index\n\t\t// function getLabelForIndex(index, datasetIndex)\n\t\tgetLabelForIndex: helpers.noop,\n\n\t\t// Used to get data value locations.  Value can either be an index or a numerical value\n\t\tgetPixelForValue: helpers.noop,\n\n\t\t// Used to get the data value from a given pixel. This is the inverse of getPixelForValue\n\t\tgetValueForPixel: helpers.noop,\n\n\t\t// Used for tick location, should\n\t\tgetPixelForTick: function(index, includeOffset) {\n\t\t\tvar me = this;\n\t\t\tif (me.isHorizontal()) {\n\t\t\t\tvar innerWidth = me.width - (me.paddingLeft + me.paddingRight);\n\t\t\t\tvar tickWidth = innerWidth / Math.max((me.ticks.length - ((me.options.gridLines.offsetGridLines) ? 0 : 1)), 1);\n\t\t\t\tvar pixel = (tickWidth * index) + me.paddingLeft;\n\n\t\t\t\tif (includeOffset) {\n\t\t\t\t\tpixel += tickWidth / 2;\n\t\t\t\t}\n\n\t\t\t\tvar finalVal = me.left + Math.round(pixel);\n\t\t\t\tfinalVal += me.isFullWidth() ? me.margins.left : 0;\n\t\t\t\treturn finalVal;\n\t\t\t}\n\t\t\tvar innerHeight = me.height - (me.paddingTop + me.paddingBottom);\n\t\t\treturn me.top + (index * (innerHeight / (me.ticks.length - 1)));\n\t\t},\n\n\t\t// Utility for getting the pixel location of a percentage of scale\n\t\tgetPixelForDecimal: function(decimal /* , includeOffset*/) {\n\t\t\tvar me = this;\n\t\t\tif (me.isHorizontal()) {\n\t\t\t\tvar innerWidth = me.width - (me.paddingLeft + me.paddingRight);\n\t\t\t\tvar valueOffset = (innerWidth * decimal) + me.paddingLeft;\n\n\t\t\t\tvar finalVal = me.left + Math.round(valueOffset);\n\t\t\t\tfinalVal += me.isFullWidth() ? me.margins.left : 0;\n\t\t\t\treturn finalVal;\n\t\t\t}\n\t\t\treturn me.top + (decimal * me.height);\n\t\t},\n\n\t\tgetBasePixel: function() {\n\t\t\treturn this.getPixelForValue(this.getBaseValue());\n\t\t},\n\n\t\tgetBaseValue: function() {\n\t\t\tvar me = this;\n\t\t\tvar min = me.min;\n\t\t\tvar max = me.max;\n\n\t\t\treturn me.beginAtZero ? 0:\n\t\t\t\tmin < 0 && max < 0? max :\n\t\t\t\tmin > 0 && max > 0? min :\n\t\t\t\t0;\n\t\t},\n\n\t\t// Actually draw the scale on the canvas\n\t\t// @param {rectangle} chartArea : the area of the chart to draw full grid lines on\n\t\tdraw: function(chartArea) {\n\t\t\tvar me = this;\n\t\t\tvar options = me.options;\n\t\t\tif (!options.display) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar context = me.ctx;\n\t\t\tvar globalDefaults = Chart.defaults.global;\n\t\t\tvar optionTicks = options.ticks;\n\t\t\tvar gridLines = options.gridLines;\n\t\t\tvar scaleLabel = options.scaleLabel;\n\n\t\t\tvar isRotated = me.labelRotation !== 0;\n\t\t\tvar skipRatio;\n\t\t\tvar useAutoskipper = optionTicks.autoSkip;\n\t\t\tvar isHorizontal = me.isHorizontal();\n\n\t\t\t// figure out the maximum number of gridlines to show\n\t\t\tvar maxTicks;\n\t\t\tif (optionTicks.maxTicksLimit) {\n\t\t\t\tmaxTicks = optionTicks.maxTicksLimit;\n\t\t\t}\n\n\t\t\tvar tickFontColor = helpers.getValueOrDefault(optionTicks.fontColor, globalDefaults.defaultFontColor);\n\t\t\tvar tickFont = parseFontOptions(optionTicks);\n\n\t\t\tvar tl = gridLines.drawTicks ? gridLines.tickMarkLength : 0;\n\t\t\tvar borderDash = helpers.getValueOrDefault(gridLines.borderDash, globalDefaults.borderDash);\n\t\t\tvar borderDashOffset = helpers.getValueOrDefault(gridLines.borderDashOffset, globalDefaults.borderDashOffset);\n\n\t\t\tvar scaleLabelFontColor = helpers.getValueOrDefault(scaleLabel.fontColor, globalDefaults.defaultFontColor);\n\t\t\tvar scaleLabelFont = parseFontOptions(scaleLabel);\n\n\t\t\tvar labelRotationRadians = helpers.toRadians(me.labelRotation);\n\t\t\tvar cosRotation = Math.cos(labelRotationRadians);\n\t\t\tvar longestRotatedLabel = me.longestLabelWidth * cosRotation;\n\n\t\t\t// Make sure we draw text in the correct color and font\n\t\t\tcontext.fillStyle = tickFontColor;\n\n\t\t\tvar itemsToDraw = [];\n\n\t\t\tif (isHorizontal) {\n\t\t\t\tskipRatio = false;\n\n\t\t\t\t// Only calculate the skip ratio with the half width of longestRotateLabel if we got an actual rotation\n\t\t\t\t// See #2584\n\t\t\t\tif (isRotated) {\n\t\t\t\t\tlongestRotatedLabel /= 2;\n\t\t\t\t}\n\n\t\t\t\tif ((longestRotatedLabel + optionTicks.autoSkipPadding) * me.ticks.length > (me.width - (me.paddingLeft + me.paddingRight))) {\n\t\t\t\t\tskipRatio = 1 + Math.floor(((longestRotatedLabel + optionTicks.autoSkipPadding) * me.ticks.length) / (me.width - (me.paddingLeft + me.paddingRight)));\n\t\t\t\t}\n\n\t\t\t\t// if they defined a max number of optionTicks,\n\t\t\t\t// increase skipRatio until that number is met\n\t\t\t\tif (maxTicks && me.ticks.length > maxTicks) {\n\t\t\t\t\twhile (!skipRatio || me.ticks.length / (skipRatio || 1) > maxTicks) {\n\t\t\t\t\t\tif (!skipRatio) {\n\t\t\t\t\t\t\tskipRatio = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tskipRatio += 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!useAutoskipper) {\n\t\t\t\t\tskipRatio = false;\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\tvar xTickStart = options.position === 'right' ? me.left : me.right - tl;\n\t\t\tvar xTickEnd = options.position === 'right' ? me.left + tl : me.right;\n\t\t\tvar yTickStart = options.position === 'bottom' ? me.top : me.bottom - tl;\n\t\t\tvar yTickEnd = options.position === 'bottom' ? me.top + tl : me.bottom;\n\n\t\t\thelpers.each(me.ticks, function(label, index) {\n\t\t\t\t// If the callback returned a null or undefined value, do not draw this line\n\t\t\t\tif (label === undefined || label === null) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tvar isLastTick = me.ticks.length === index + 1;\n\n\t\t\t\t// Since we always show the last tick,we need may need to hide the last shown one before\n\t\t\t\tvar shouldSkip = (skipRatio > 1 && index % skipRatio > 0) || (index % skipRatio === 0 && index + skipRatio >= me.ticks.length);\n\t\t\t\tif (shouldSkip && !isLastTick || (label === undefined || label === null)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tvar lineWidth, lineColor;\n\t\t\t\tif (index === (typeof me.zeroLineIndex !== 'undefined' ? me.zeroLineIndex : 0)) {\n\t\t\t\t\t// Draw the first index specially\n\t\t\t\t\tlineWidth = gridLines.zeroLineWidth;\n\t\t\t\t\tlineColor = gridLines.zeroLineColor;\n\t\t\t\t} else {\n\t\t\t\t\tlineWidth = helpers.getValueAtIndexOrDefault(gridLines.lineWidth, index);\n\t\t\t\t\tlineColor = helpers.getValueAtIndexOrDefault(gridLines.color, index);\n\t\t\t\t}\n\n\t\t\t\t// Common properties\n\t\t\t\tvar tx1, ty1, tx2, ty2, x1, y1, x2, y2, labelX, labelY;\n\t\t\t\tvar textAlign = 'middle';\n\t\t\t\tvar textBaseline = 'middle';\n\n\t\t\t\tif (isHorizontal) {\n\n\t\t\t\t\tif (options.position === 'bottom') {\n\t\t\t\t\t\t// bottom\n\t\t\t\t\t\ttextBaseline = !isRotated? 'top':'middle';\n\t\t\t\t\t\ttextAlign = !isRotated? 'center': 'right';\n\t\t\t\t\t\tlabelY = me.top + tl;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// top\n\t\t\t\t\t\ttextBaseline = !isRotated? 'bottom':'middle';\n\t\t\t\t\t\ttextAlign = !isRotated? 'center': 'left';\n\t\t\t\t\t\tlabelY = me.bottom - tl;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar xLineValue = me.getPixelForTick(index) + helpers.aliasPixel(lineWidth); // xvalues for grid lines\n\t\t\t\t\tlabelX = me.getPixelForTick(index, gridLines.offsetGridLines) + optionTicks.labelOffset; // x values for optionTicks (need to consider offsetLabel option)\n\n\t\t\t\t\ttx1 = tx2 = x1 = x2 = xLineValue;\n\t\t\t\t\tty1 = yTickStart;\n\t\t\t\t\tty2 = yTickEnd;\n\t\t\t\t\ty1 = chartArea.top;\n\t\t\t\t\ty2 = chartArea.bottom;\n\t\t\t\t} else {\n\t\t\t\t\tvar isLeft = options.position === 'left';\n\t\t\t\t\tvar tickPadding = optionTicks.padding;\n\t\t\t\t\tvar labelXOffset;\n\n\t\t\t\t\tif (optionTicks.mirror) {\n\t\t\t\t\t\ttextAlign = isLeft ? 'left' : 'right';\n\t\t\t\t\t\tlabelXOffset = tickPadding;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttextAlign = isLeft ? 'right' : 'left';\n\t\t\t\t\t\tlabelXOffset = tl + tickPadding;\n\t\t\t\t\t}\n\n\t\t\t\t\tlabelX = isLeft ? me.right - labelXOffset : me.left + labelXOffset;\n\n\t\t\t\t\tvar yLineValue = me.getPixelForTick(index); // xvalues for grid lines\n\t\t\t\t\tyLineValue += helpers.aliasPixel(lineWidth);\n\t\t\t\t\tlabelY = me.getPixelForTick(index, gridLines.offsetGridLines);\n\n\t\t\t\t\ttx1 = xTickStart;\n\t\t\t\t\ttx2 = xTickEnd;\n\t\t\t\t\tx1 = chartArea.left;\n\t\t\t\t\tx2 = chartArea.right;\n\t\t\t\t\tty1 = ty2 = y1 = y2 = yLineValue;\n\t\t\t\t}\n\n\t\t\t\titemsToDraw.push({\n\t\t\t\t\ttx1: tx1,\n\t\t\t\t\tty1: ty1,\n\t\t\t\t\ttx2: tx2,\n\t\t\t\t\tty2: ty2,\n\t\t\t\t\tx1: x1,\n\t\t\t\t\ty1: y1,\n\t\t\t\t\tx2: x2,\n\t\t\t\t\ty2: y2,\n\t\t\t\t\tlabelX: labelX,\n\t\t\t\t\tlabelY: labelY,\n\t\t\t\t\tglWidth: lineWidth,\n\t\t\t\t\tglColor: lineColor,\n\t\t\t\t\tglBorderDash: borderDash,\n\t\t\t\t\tglBorderDashOffset: borderDashOffset,\n\t\t\t\t\trotation: -1 * labelRotationRadians,\n\t\t\t\t\tlabel: label,\n\t\t\t\t\ttextBaseline: textBaseline,\n\t\t\t\t\ttextAlign: textAlign\n\t\t\t\t});\n\t\t\t});\n\n\t\t\t// Draw all of the tick labels, tick marks, and grid lines at the correct places\n\t\t\thelpers.each(itemsToDraw, function(itemToDraw) {\n\t\t\t\tif (gridLines.display) {\n\t\t\t\t\tcontext.save();\n\t\t\t\t\tcontext.lineWidth = itemToDraw.glWidth;\n\t\t\t\t\tcontext.strokeStyle = itemToDraw.glColor;\n\t\t\t\t\tif (context.setLineDash) {\n\t\t\t\t\t\tcontext.setLineDash(itemToDraw.glBorderDash);\n\t\t\t\t\t\tcontext.lineDashOffset = itemToDraw.glBorderDashOffset;\n\t\t\t\t\t}\n\n\t\t\t\t\tcontext.beginPath();\n\n\t\t\t\t\tif (gridLines.drawTicks) {\n\t\t\t\t\t\tcontext.moveTo(itemToDraw.tx1, itemToDraw.ty1);\n\t\t\t\t\t\tcontext.lineTo(itemToDraw.tx2, itemToDraw.ty2);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (gridLines.drawOnChartArea) {\n\t\t\t\t\t\tcontext.moveTo(itemToDraw.x1, itemToDraw.y1);\n\t\t\t\t\t\tcontext.lineTo(itemToDraw.x2, itemToDraw.y2);\n\t\t\t\t\t}\n\n\t\t\t\t\tcontext.stroke();\n\t\t\t\t\tcontext.restore();\n\t\t\t\t}\n\n\t\t\t\tif (optionTicks.display) {\n\t\t\t\t\tcontext.save();\n\t\t\t\t\tcontext.translate(itemToDraw.labelX, itemToDraw.labelY);\n\t\t\t\t\tcontext.rotate(itemToDraw.rotation);\n\t\t\t\t\tcontext.font = tickFont.font;\n\t\t\t\t\tcontext.textBaseline = itemToDraw.textBaseline;\n\t\t\t\t\tcontext.textAlign = itemToDraw.textAlign;\n\n\t\t\t\t\tvar label = itemToDraw.label;\n\t\t\t\t\tif (helpers.isArray(label)) {\n\t\t\t\t\t\tfor (var i = 0, y = 0; i < label.length; ++i) {\n\t\t\t\t\t\t\t// We just make sure the multiline element is a string here..\n\t\t\t\t\t\t\tcontext.fillText('' + label[i], 0, y);\n\t\t\t\t\t\t\t// apply same lineSpacing as calculated @ L#320\n\t\t\t\t\t\t\ty += (tickFont.size * 1.5);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcontext.fillText(label, 0, 0);\n\t\t\t\t\t}\n\t\t\t\t\tcontext.restore();\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tif (scaleLabel.display) {\n\t\t\t\t// Draw the scale label\n\t\t\t\tvar scaleLabelX;\n\t\t\t\tvar scaleLabelY;\n\t\t\t\tvar rotation = 0;\n\n\t\t\t\tif (isHorizontal) {\n\t\t\t\t\tscaleLabelX = me.left + ((me.right - me.left) / 2); // midpoint of the width\n\t\t\t\t\tscaleLabelY = options.position === 'bottom' ? me.bottom - (scaleLabelFont.size / 2) : me.top + (scaleLabelFont.size / 2);\n\t\t\t\t} else {\n\t\t\t\t\tvar isLeft = options.position === 'left';\n\t\t\t\t\tscaleLabelX = isLeft ? me.left + (scaleLabelFont.size / 2) : me.right - (scaleLabelFont.size / 2);\n\t\t\t\t\tscaleLabelY = me.top + ((me.bottom - me.top) / 2);\n\t\t\t\t\trotation = isLeft ? -0.5 * Math.PI : 0.5 * Math.PI;\n\t\t\t\t}\n\n\t\t\t\tcontext.save();\n\t\t\t\tcontext.translate(scaleLabelX, scaleLabelY);\n\t\t\t\tcontext.rotate(rotation);\n\t\t\t\tcontext.textAlign = 'center';\n\t\t\t\tcontext.textBaseline = 'middle';\n\t\t\t\tcontext.fillStyle = scaleLabelFontColor; // render in correct colour\n\t\t\t\tcontext.font = scaleLabelFont.font;\n\t\t\t\tcontext.fillText(scaleLabel.labelString, 0, 0);\n\t\t\t\tcontext.restore();\n\t\t\t}\n\n\t\t\tif (gridLines.drawBorder) {\n\t\t\t\t// Draw the line at the edge of the axis\n\t\t\t\tcontext.lineWidth = helpers.getValueAtIndexOrDefault(gridLines.lineWidth, 0);\n\t\t\t\tcontext.strokeStyle = helpers.getValueAtIndexOrDefault(gridLines.color, 0);\n\t\t\t\tvar x1 = me.left,\n\t\t\t\t\tx2 = me.right,\n\t\t\t\t\ty1 = me.top,\n\t\t\t\t\ty2 = me.bottom;\n\n\t\t\t\tvar aliasPixel = helpers.aliasPixel(context.lineWidth);\n\t\t\t\tif (isHorizontal) {\n\t\t\t\t\ty1 = y2 = options.position === 'top' ? me.bottom : me.top;\n\t\t\t\t\ty1 += aliasPixel;\n\t\t\t\t\ty2 += aliasPixel;\n\t\t\t\t} else {\n\t\t\t\t\tx1 = x2 = options.position === 'left' ? me.right : me.left;\n\t\t\t\t\tx1 += aliasPixel;\n\t\t\t\t\tx2 += aliasPixel;\n\t\t\t\t}\n\n\t\t\t\tcontext.beginPath();\n\t\t\t\tcontext.moveTo(x1, y1);\n\t\t\t\tcontext.lineTo(x2, y2);\n\t\t\t\tcontext.stroke();\n\t\t\t}\n\t\t}\n\t});\n};\n\n},{}],33:[function(require,module,exports){\n'use strict';\n\nmodule.exports = function(Chart) {\n\n\tvar helpers = Chart.helpers;\n\n\tChart.scaleService = {\n\t\t// Scale registration object. Extensions can register new scale types (such as log or DB scales) and then\n\t\t// use the new chart options to grab the correct scale\n\t\tconstructors: {},\n\t\t// Use a registration function so that we can move to an ES6 map when we no longer need to support\n\t\t// old browsers\n\n\t\t// Scale config defaults\n\t\tdefaults: {},\n\t\tregisterScaleType: function(type, scaleConstructor, defaults) {\n\t\t\tthis.constructors[type] = scaleConstructor;\n\t\t\tthis.defaults[type] = helpers.clone(defaults);\n\t\t},\n\t\tgetScaleConstructor: function(type) {\n\t\t\treturn this.constructors.hasOwnProperty(type) ? this.constructors[type] : undefined;\n\t\t},\n\t\tgetScaleDefaults: function(type) {\n\t\t\t// Return the scale defaults merged with the global settings so that we always use the latest ones\n\t\t\treturn this.defaults.hasOwnProperty(type) ? helpers.scaleMerge(Chart.defaults.scale, this.defaults[type]) : {};\n\t\t},\n\t\tupdateScaleDefaults: function(type, additions) {\n\t\t\tvar defaults = this.defaults;\n\t\t\tif (defaults.hasOwnProperty(type)) {\n\t\t\t\tdefaults[type] = helpers.extend(defaults[type], additions);\n\t\t\t}\n\t\t},\n\t\taddScalesToLayout: function(chartInstance) {\n\t\t\t// Adds each scale to the chart.boxes array to be sized accordingly\n\t\t\thelpers.each(chartInstance.scales, function(scale) {\n\t\t\t\tChart.layoutService.addBox(chartInstance, scale);\n\t\t\t});\n\t\t}\n\t};\n};\n\n},{}],34:[function(require,module,exports){\n'use strict';\n\nmodule.exports = function(Chart) {\n\n\tvar helpers = Chart.helpers;\n\n\t/**\n\t * Namespace to hold static tick generation functions\n\t * @namespace Chart.Ticks\n\t */\n\tChart.Ticks = {\n\t\t/**\n\t\t * Namespace to hold generators for different types of ticks\n\t\t * @namespace Chart.Ticks.generators\n\t\t */\n\t\tgenerators: {\n\t\t\t/**\n\t\t\t * Interface for the options provided to the numeric tick generator\n\t\t\t * @interface INumericTickGenerationOptions\n\t\t\t */\n\t\t\t/**\n\t\t\t * The maximum number of ticks to display\n\t\t\t * @name INumericTickGenerationOptions#maxTicks\n\t\t\t * @type Number\n\t\t\t */\n\t\t\t/**\n\t\t\t * The distance between each tick.\n\t\t\t * @name INumericTickGenerationOptions#stepSize\n\t\t\t * @type Number\n\t\t\t * @optional\n\t\t\t */\n\t\t\t/**\n\t\t\t * Forced minimum for the ticks. If not specified, the minimum of the data range is used to calculate the tick minimum\n\t\t\t * @name INumericTickGenerationOptions#min\n\t\t\t * @type Number\n\t\t\t * @optional\n\t\t\t */\n\t\t\t/**\n\t\t\t * The maximum value of the ticks. If not specified, the maximum of the data range is used to calculate the tick maximum\n\t\t\t * @name INumericTickGenerationOptions#max\n\t\t\t * @type Number\n\t\t\t * @optional\n\t\t\t */\n\n\t\t\t/**\n\t\t\t * Generate a set of linear ticks\n\t\t\t * @method Chart.Ticks.generators.linear\n\t\t\t * @param generationOptions {INumericTickGenerationOptions} the options used to generate the ticks\n\t\t\t * @param dataRange {IRange} the range of the data\n\t\t\t * @returns {Array<Number>} array of tick values\n\t\t\t */\n\t\t\tlinear: function(generationOptions, dataRange) {\n\t\t\t\tvar ticks = [];\n\t\t\t\t// To get a \"nice\" value for the tick spacing, we will use the appropriately named\n\t\t\t\t// \"nice number\" algorithm. See http://stackoverflow.com/questions/8506881/nice-label-algorithm-for-charts-with-minimum-ticks\n\t\t\t\t// for details.\n\n\t\t\t\tvar spacing;\n\t\t\t\tif (generationOptions.stepSize && generationOptions.stepSize > 0) {\n\t\t\t\t\tspacing = generationOptions.stepSize;\n\t\t\t\t} else {\n\t\t\t\t\tvar niceRange = helpers.niceNum(dataRange.max - dataRange.min, false);\n\t\t\t\t\tspacing = helpers.niceNum(niceRange / (generationOptions.maxTicks - 1), true);\n\t\t\t\t}\n\t\t\t\tvar niceMin = Math.floor(dataRange.min / spacing) * spacing;\n\t\t\t\tvar niceMax = Math.ceil(dataRange.max / spacing) * spacing;\n\n\t\t\t\t// If min, max and stepSize is set and they make an evenly spaced scale use it.\n\t\t\t\tif (generationOptions.min && generationOptions.max && generationOptions.stepSize) {\n\t\t\t\t\t// If very close to our whole number, use it.\n\t\t\t\t\tif (helpers.almostWhole((generationOptions.max - generationOptions.min) / generationOptions.stepSize, spacing / 1000)) {\n\t\t\t\t\t\tniceMin = generationOptions.min;\n\t\t\t\t\t\tniceMax = generationOptions.max;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tvar numSpaces = (niceMax - niceMin) / spacing;\n\t\t\t\t// If very close to our rounded value, use it.\n\t\t\t\tif (helpers.almostEquals(numSpaces, Math.round(numSpaces), spacing / 1000)) {\n\t\t\t\t\tnumSpaces = Math.round(numSpaces);\n\t\t\t\t} else {\n\t\t\t\t\tnumSpaces = Math.ceil(numSpaces);\n\t\t\t\t}\n\n\t\t\t\t// Put the values into the ticks array\n\t\t\t\tticks.push(generationOptions.min !== undefined ? generationOptions.min : niceMin);\n\t\t\t\tfor (var j = 1; j < numSpaces; ++j) {\n\t\t\t\t\tticks.push(niceMin + (j * spacing));\n\t\t\t\t}\n\t\t\t\tticks.push(generationOptions.max !== undefined ? generationOptions.max : niceMax);\n\n\t\t\t\treturn ticks;\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Generate a set of logarithmic ticks\n\t\t\t * @method Chart.Ticks.generators.logarithmic\n\t\t\t * @param generationOptions {INumericTickGenerationOptions} the options used to generate the ticks\n\t\t\t * @param dataRange {IRange} the range of the data\n\t\t\t * @returns {Array<Number>} array of tick values\n\t\t\t */\n\t\t\tlogarithmic: function(generationOptions, dataRange) {\n\t\t\t\tvar ticks = [];\n\t\t\t\tvar getValueOrDefault = helpers.getValueOrDefault;\n\n\t\t\t\t// Figure out what the max number of ticks we can support it is based on the size of\n\t\t\t\t// the axis area. For now, we say that the minimum tick spacing in pixels must be 50\n\t\t\t\t// We also limit the maximum number of ticks to 11 which gives a nice 10 squares on\n\t\t\t\t// the graph\n\t\t\t\tvar tickVal = getValueOrDefault(generationOptions.min, Math.pow(10, Math.floor(helpers.log10(dataRange.min))));\n\n\t\t\t\tvar endExp = Math.floor(helpers.log10(dataRange.max));\n\t\t\t\tvar endSignificand = Math.ceil(dataRange.max / Math.pow(10, endExp));\n\t\t\t\tvar exp;\n\t\t\t\tvar significand;\n\n\t\t\t\tif (tickVal === 0) {\n\t\t\t\t\texp = Math.floor(helpers.log10(dataRange.minNotZero));\n\t\t\t\t\tsignificand = Math.floor(dataRange.minNotZero / Math.pow(10, exp));\n\n\t\t\t\t\tticks.push(tickVal);\n\t\t\t\t\ttickVal = significand * Math.pow(10, exp);\n\t\t\t\t} else {\n\t\t\t\t\texp = Math.floor(helpers.log10(tickVal));\n\t\t\t\t\tsignificand = Math.floor(tickVal / Math.pow(10, exp));\n\t\t\t\t}\n\n\t\t\t\tdo {\n\t\t\t\t\tticks.push(tickVal);\n\n\t\t\t\t\t++significand;\n\t\t\t\t\tif (significand === 10) {\n\t\t\t\t\t\tsignificand = 1;\n\t\t\t\t\t\t++exp;\n\t\t\t\t\t}\n\n\t\t\t\t\ttickVal = significand * Math.pow(10, exp);\n\t\t\t\t} while (exp < endExp || (exp === endExp && significand < endSignificand));\n\n\t\t\t\tvar lastTick = getValueOrDefault(generationOptions.max, tickVal);\n\t\t\t\tticks.push(lastTick);\n\n\t\t\t\treturn ticks;\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Namespace to hold formatters for different types of ticks\n\t\t * @namespace Chart.Ticks.formatters\n\t\t */\n\t\tformatters: {\n\t\t\t/**\n\t\t\t * Formatter for value labels\n\t\t\t * @method Chart.Ticks.formatters.values\n\t\t\t * @param value the value to display\n\t\t\t * @return {String|Array} the label to display\n\t\t\t */\n\t\t\tvalues: function(value) {\n\t\t\t\treturn helpers.isArray(value) ? value : '' + value;\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Formatter for linear numeric ticks\n\t\t\t * @method Chart.Ticks.formatters.linear\n\t\t\t * @param tickValue {Number} the value to be formatted\n\t\t\t * @param index {Number} the position of the tickValue parameter in the ticks array\n\t\t\t * @param ticks {Array<Number>} the list of ticks being converted\n\t\t\t * @return {String} string representation of the tickValue parameter\n\t\t\t */\n\t\t\tlinear: function(tickValue, index, ticks) {\n\t\t\t\t// If we have lots of ticks, don't use the ones\n\t\t\t\tvar delta = ticks.length > 3 ? ticks[2] - ticks[1] : ticks[1] - ticks[0];\n\n\t\t\t\t// If we have a number like 2.5 as the delta, figure out how many decimal places we need\n\t\t\t\tif (Math.abs(delta) > 1) {\n\t\t\t\t\tif (tickValue !== Math.floor(tickValue)) {\n\t\t\t\t\t\t// not an integer\n\t\t\t\t\t\tdelta = tickValue - Math.floor(tickValue);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tvar logDelta = helpers.log10(Math.abs(delta));\n\t\t\t\tvar tickString = '';\n\n\t\t\t\tif (tickValue !== 0) {\n\t\t\t\t\tvar numDecimal = -1 * Math.floor(logDelta);\n\t\t\t\t\tnumDecimal = Math.max(Math.min(numDecimal, 20), 0); // toFixed has a max of 20 decimal places\n\t\t\t\t\ttickString = tickValue.toFixed(numDecimal);\n\t\t\t\t} else {\n\t\t\t\t\ttickString = '0'; // never show decimal places for 0\n\t\t\t\t}\n\n\t\t\t\treturn tickString;\n\t\t\t},\n\n\t\t\tlogarithmic: function(tickValue, index, ticks) {\n\t\t\t\tvar remain = tickValue / (Math.pow(10, Math.floor(helpers.log10(tickValue))));\n\n\t\t\t\tif (tickValue === 0) {\n\t\t\t\t\treturn '0';\n\t\t\t\t} else if (remain === 1 || remain === 2 || remain === 5 || index === 0 || index === ticks.length - 1) {\n\t\t\t\t\treturn tickValue.toExponential();\n\t\t\t\t}\n\t\t\t\treturn '';\n\t\t\t}\n\t\t}\n\t};\n};\n\n},{}],35:[function(require,module,exports){\n'use strict';\n\nmodule.exports = function(Chart) {\n\n\tvar helpers = Chart.helpers;\n\n\tChart.defaults.global.title = {\n\t\tdisplay: false,\n\t\tposition: 'top',\n\t\tfullWidth: true, // marks that this box should take the full width of the canvas (pushing down other boxes)\n\n\t\tfontStyle: 'bold',\n\t\tpadding: 10,\n\n\t\t// actual title\n\t\ttext: ''\n\t};\n\n\tvar noop = helpers.noop;\n\tChart.Title = Chart.Element.extend({\n\n\t\tinitialize: function(config) {\n\t\t\tvar me = this;\n\t\t\thelpers.extend(me, config);\n\n\t\t\t// Contains hit boxes for each dataset (in dataset order)\n\t\t\tme.legendHitBoxes = [];\n\t\t},\n\n\t\t// These methods are ordered by lifecycle. Utilities then follow.\n\n\t\tbeforeUpdate: noop,\n\t\tupdate: function(maxWidth, maxHeight, margins) {\n\t\t\tvar me = this;\n\n\t\t\t// Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)\n\t\t\tme.beforeUpdate();\n\n\t\t\t// Absorb the master measurements\n\t\t\tme.maxWidth = maxWidth;\n\t\t\tme.maxHeight = maxHeight;\n\t\t\tme.margins = margins;\n\n\t\t\t// Dimensions\n\t\t\tme.beforeSetDimensions();\n\t\t\tme.setDimensions();\n\t\t\tme.afterSetDimensions();\n\t\t\t// Labels\n\t\t\tme.beforeBuildLabels();\n\t\t\tme.buildLabels();\n\t\t\tme.afterBuildLabels();\n\n\t\t\t// Fit\n\t\t\tme.beforeFit();\n\t\t\tme.fit();\n\t\t\tme.afterFit();\n\t\t\t//\n\t\t\tme.afterUpdate();\n\n\t\t\treturn me.minSize;\n\n\t\t},\n\t\tafterUpdate: noop,\n\n\t\t//\n\n\t\tbeforeSetDimensions: noop,\n\t\tsetDimensions: function() {\n\t\t\tvar me = this;\n\t\t\t// Set the unconstrained dimension before label rotation\n\t\t\tif (me.isHorizontal()) {\n\t\t\t\t// Reset position before calculating rotation\n\t\t\t\tme.width = me.maxWidth;\n\t\t\t\tme.left = 0;\n\t\t\t\tme.right = me.width;\n\t\t\t} else {\n\t\t\t\tme.height = me.maxHeight;\n\n\t\t\t\t// Reset position before calculating rotation\n\t\t\t\tme.top = 0;\n\t\t\t\tme.bottom = me.height;\n\t\t\t}\n\n\t\t\t// Reset padding\n\t\t\tme.paddingLeft = 0;\n\t\t\tme.paddingTop = 0;\n\t\t\tme.paddingRight = 0;\n\t\t\tme.paddingBottom = 0;\n\n\t\t\t// Reset minSize\n\t\t\tme.minSize = {\n\t\t\t\twidth: 0,\n\t\t\t\theight: 0\n\t\t\t};\n\t\t},\n\t\tafterSetDimensions: noop,\n\n\t\t//\n\n\t\tbeforeBuildLabels: noop,\n\t\tbuildLabels: noop,\n\t\tafterBuildLabels: noop,\n\n\t\t//\n\n\t\tbeforeFit: noop,\n\t\tfit: function() {\n\t\t\tvar me = this,\n\t\t\t\tvalueOrDefault = helpers.getValueOrDefault,\n\t\t\t\topts = me.options,\n\t\t\t\tglobalDefaults = Chart.defaults.global,\n\t\t\t\tdisplay = opts.display,\n\t\t\t\tfontSize = valueOrDefault(opts.fontSize, globalDefaults.defaultFontSize),\n\t\t\t\tminSize = me.minSize;\n\n\t\t\tif (me.isHorizontal()) {\n\t\t\t\tminSize.width = me.maxWidth; // fill all the width\n\t\t\t\tminSize.height = display ? fontSize + (opts.padding * 2) : 0;\n\t\t\t} else {\n\t\t\t\tminSize.width = display ? fontSize + (opts.padding * 2) : 0;\n\t\t\t\tminSize.height = me.maxHeight; // fill all the height\n\t\t\t}\n\n\t\t\tme.width = minSize.width;\n\t\t\tme.height = minSize.height;\n\n\t\t},\n\t\tafterFit: noop,\n\n\t\t// Shared Methods\n\t\tisHorizontal: function() {\n\t\t\tvar pos = this.options.position;\n\t\t\treturn pos === 'top' || pos === 'bottom';\n\t\t},\n\n\t\t// Actually draw the title block on the canvas\n\t\tdraw: function() {\n\t\t\tvar me = this,\n\t\t\t\tctx = me.ctx,\n\t\t\t\tvalueOrDefault = helpers.getValueOrDefault,\n\t\t\t\topts = me.options,\n\t\t\t\tglobalDefaults = Chart.defaults.global;\n\n\t\t\tif (opts.display) {\n\t\t\t\tvar fontSize = valueOrDefault(opts.fontSize, globalDefaults.defaultFontSize),\n\t\t\t\t\tfontStyle = valueOrDefault(opts.fontStyle, globalDefaults.defaultFontStyle),\n\t\t\t\t\tfontFamily = valueOrDefault(opts.fontFamily, globalDefaults.defaultFontFamily),\n\t\t\t\t\ttitleFont = helpers.fontString(fontSize, fontStyle, fontFamily),\n\t\t\t\t\trotation = 0,\n\t\t\t\t\ttitleX,\n\t\t\t\t\ttitleY,\n\t\t\t\t\ttop = me.top,\n\t\t\t\t\tleft = me.left,\n\t\t\t\t\tbottom = me.bottom,\n\t\t\t\t\tright = me.right,\n\t\t\t\t\tmaxWidth;\n\n\t\t\t\tctx.fillStyle = valueOrDefault(opts.fontColor, globalDefaults.defaultFontColor); // render in correct colour\n\t\t\t\tctx.font = titleFont;\n\n\t\t\t\t// Horizontal\n\t\t\t\tif (me.isHorizontal()) {\n\t\t\t\t\ttitleX = left + ((right - left) / 2); // midpoint of the width\n\t\t\t\t\ttitleY = top + ((bottom - top) / 2); // midpoint of the height\n\t\t\t\t\tmaxWidth = right - left;\n\t\t\t\t} else {\n\t\t\t\t\ttitleX = opts.position === 'left' ? left + (fontSize / 2) : right - (fontSize / 2);\n\t\t\t\t\ttitleY = top + ((bottom - top) / 2);\n\t\t\t\t\tmaxWidth = bottom - top;\n\t\t\t\t\trotation = Math.PI * (opts.position === 'left' ? -0.5 : 0.5);\n\t\t\t\t}\n\n\t\t\t\tctx.save();\n\t\t\t\tctx.translate(titleX, titleY);\n\t\t\t\tctx.rotate(rotation);\n\t\t\t\tctx.textAlign = 'center';\n\t\t\t\tctx.textBaseline = 'middle';\n\t\t\t\tctx.fillText(opts.text, 0, 0, maxWidth);\n\t\t\t\tctx.restore();\n\t\t\t}\n\t\t}\n\t});\n\n\tfunction createNewTitleBlockAndAttach(chartInstance, titleOpts) {\n\t\tvar title = new Chart.Title({\n\t\t\tctx: chartInstance.chart.ctx,\n\t\t\toptions: titleOpts,\n\t\t\tchart: chartInstance\n\t\t});\n\t\tchartInstance.titleBlock = title;\n\t\tChart.layoutService.addBox(chartInstance, title);\n\t}\n\n\t// Register the title plugin\n\tChart.plugins.register({\n\t\tbeforeInit: function(chartInstance) {\n\t\t\tvar titleOpts = chartInstance.options.title;\n\n\t\t\tif (titleOpts) {\n\t\t\t\tcreateNewTitleBlockAndAttach(chartInstance, titleOpts);\n\t\t\t}\n\t\t},\n\t\tbeforeUpdate: function(chartInstance) {\n\t\t\tvar titleOpts = chartInstance.options.title;\n\n\t\t\tif (titleOpts) {\n\t\t\t\ttitleOpts = helpers.configMerge(Chart.defaults.global.title, titleOpts);\n\n\t\t\t\tif (chartInstance.titleBlock) {\n\t\t\t\t\tchartInstance.titleBlock.options = titleOpts;\n\t\t\t\t} else {\n\t\t\t\t\tcreateNewTitleBlockAndAttach(chartInstance, titleOpts);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tChart.layoutService.removeBox(chartInstance, chartInstance.titleBlock);\n\t\t\t\tdelete chartInstance.titleBlock;\n\t\t\t}\n\t\t}\n\t});\n};\n\n},{}],36:[function(require,module,exports){\n'use strict';\n\nmodule.exports = function(Chart) {\n\n\tvar helpers = Chart.helpers;\n\n\t/**\n \t * Helper method to merge the opacity into a color\n \t */\n\tfunction mergeOpacity(colorString, opacity) {\n\t\tvar color = helpers.color(colorString);\n\t\treturn color.alpha(opacity * color.alpha()).rgbaString();\n\t}\n\n\tChart.defaults.global.tooltips = {\n\t\tenabled: true,\n\t\tcustom: null,\n\t\tmode: 'nearest',\n\t\tposition: 'average',\n\t\tintersect: true,\n\t\tbackgroundColor: 'rgba(0,0,0,0.8)',\n\t\ttitleFontStyle: 'bold',\n\t\ttitleSpacing: 2,\n\t\ttitleMarginBottom: 6,\n\t\ttitleFontColor: '#fff',\n\t\ttitleAlign: 'left',\n\t\tbodySpacing: 2,\n\t\tbodyFontColor: '#fff',\n\t\tbodyAlign: 'left',\n\t\tfooterFontStyle: 'bold',\n\t\tfooterSpacing: 2,\n\t\tfooterMarginTop: 6,\n\t\tfooterFontColor: '#fff',\n\t\tfooterAlign: 'left',\n\t\tyPadding: 6,\n\t\txPadding: 6,\n\t\tcaretSize: 5,\n\t\tcornerRadius: 6,\n\t\tmultiKeyBackground: '#fff',\n\t\tdisplayColors: true,\n\t\tcallbacks: {\n\t\t\t// Args are: (tooltipItems, data)\n\t\t\tbeforeTitle: helpers.noop,\n\t\t\ttitle: function(tooltipItems, data) {\n\t\t\t\t// Pick first xLabel for now\n\t\t\t\tvar title = '';\n\t\t\t\tvar labels = data.labels;\n\t\t\t\tvar labelCount = labels ? labels.length : 0;\n\n\t\t\t\tif (tooltipItems.length > 0) {\n\t\t\t\t\tvar item = tooltipItems[0];\n\n\t\t\t\t\tif (item.xLabel) {\n\t\t\t\t\t\ttitle = item.xLabel;\n\t\t\t\t\t} else if (labelCount > 0 && item.index < labelCount) {\n\t\t\t\t\t\ttitle = labels[item.index];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn title;\n\t\t\t},\n\t\t\tafterTitle: helpers.noop,\n\n\t\t\t// Args are: (tooltipItems, data)\n\t\t\tbeforeBody: helpers.noop,\n\n\t\t\t// Args are: (tooltipItem, data)\n\t\t\tbeforeLabel: helpers.noop,\n\t\t\tlabel: function(tooltipItem, data) {\n\t\t\t\tvar datasetLabel = data.datasets[tooltipItem.datasetIndex].label || '';\n\t\t\t\treturn datasetLabel + ': ' + tooltipItem.yLabel;\n\t\t\t},\n\t\t\tlabelColor: function(tooltipItem, chartInstance) {\n\t\t\t\tvar meta = chartInstance.getDatasetMeta(tooltipItem.datasetIndex);\n\t\t\t\tvar activeElement = meta.data[tooltipItem.index];\n\t\t\t\tvar view = activeElement._view;\n\t\t\t\treturn {\n\t\t\t\t\tborderColor: view.borderColor,\n\t\t\t\t\tbackgroundColor: view.backgroundColor\n\t\t\t\t};\n\t\t\t},\n\t\t\tafterLabel: helpers.noop,\n\n\t\t\t// Args are: (tooltipItems, data)\n\t\t\tafterBody: helpers.noop,\n\n\t\t\t// Args are: (tooltipItems, data)\n\t\t\tbeforeFooter: helpers.noop,\n\t\t\tfooter: helpers.noop,\n\t\t\tafterFooter: helpers.noop\n\t\t}\n\t};\n\n\t// Helper to push or concat based on if the 2nd parameter is an array or not\n\tfunction pushOrConcat(base, toPush) {\n\t\tif (toPush) {\n\t\t\tif (helpers.isArray(toPush)) {\n\t\t\t\t// base = base.concat(toPush);\n\t\t\t\tArray.prototype.push.apply(base, toPush);\n\t\t\t} else {\n\t\t\t\tbase.push(toPush);\n\t\t\t}\n\t\t}\n\n\t\treturn base;\n\t}\n\n\t// Private helper to create a tooltip item model\n\t// @param element : the chart element (point, arc, bar) to create the tooltip item for\n\t// @return : new tooltip item\n\tfunction createTooltipItem(element) {\n\t\tvar xScale = element._xScale;\n\t\tvar yScale = element._yScale || element._scale; // handle radar || polarArea charts\n\t\tvar index = element._index,\n\t\t\tdatasetIndex = element._datasetIndex;\n\n\t\treturn {\n\t\t\txLabel: xScale ? xScale.getLabelForIndex(index, datasetIndex) : '',\n\t\t\tyLabel: yScale ? yScale.getLabelForIndex(index, datasetIndex) : '',\n\t\t\tindex: index,\n\t\t\tdatasetIndex: datasetIndex,\n\t\t\tx: element._model.x,\n\t\t\ty: element._model.y\n\t\t};\n\t}\n\n\t/**\n\t * Helper to get the reset model for the tooltip\n\t * @param tooltipOpts {Object} the tooltip options\n\t */\n\tfunction getBaseModel(tooltipOpts) {\n\t\tvar globalDefaults = Chart.defaults.global;\n\t\tvar getValueOrDefault = helpers.getValueOrDefault;\n\n\t\treturn {\n\t\t\t// Positioning\n\t\t\txPadding: tooltipOpts.xPadding,\n\t\t\tyPadding: tooltipOpts.yPadding,\n\t\t\txAlign: tooltipOpts.xAlign,\n\t\t\tyAlign: tooltipOpts.yAlign,\n\n\t\t\t// Body\n\t\t\tbodyFontColor: tooltipOpts.bodyFontColor,\n\t\t\t_bodyFontFamily: getValueOrDefault(tooltipOpts.bodyFontFamily, globalDefaults.defaultFontFamily),\n\t\t\t_bodyFontStyle: getValueOrDefault(tooltipOpts.bodyFontStyle, globalDefaults.defaultFontStyle),\n\t\t\t_bodyAlign: tooltipOpts.bodyAlign,\n\t\t\tbodyFontSize: getValueOrDefault(tooltipOpts.bodyFontSize, globalDefaults.defaultFontSize),\n\t\t\tbodySpacing: tooltipOpts.bodySpacing,\n\n\t\t\t// Title\n\t\t\ttitleFontColor: tooltipOpts.titleFontColor,\n\t\t\t_titleFontFamily: getValueOrDefault(tooltipOpts.titleFontFamily, globalDefaults.defaultFontFamily),\n\t\t\t_titleFontStyle: getValueOrDefault(tooltipOpts.titleFontStyle, globalDefaults.defaultFontStyle),\n\t\t\ttitleFontSize: getValueOrDefault(tooltipOpts.titleFontSize, globalDefaults.defaultFontSize),\n\t\t\t_titleAlign: tooltipOpts.titleAlign,\n\t\t\ttitleSpacing: tooltipOpts.titleSpacing,\n\t\t\ttitleMarginBottom: tooltipOpts.titleMarginBottom,\n\n\t\t\t// Footer\n\t\t\tfooterFontColor: tooltipOpts.footerFontColor,\n\t\t\t_footerFontFamily: getValueOrDefault(tooltipOpts.footerFontFamily, globalDefaults.defaultFontFamily),\n\t\t\t_footerFontStyle: getValueOrDefault(tooltipOpts.footerFontStyle, globalDefaults.defaultFontStyle),\n\t\t\tfooterFontSize: getValueOrDefault(tooltipOpts.footerFontSize, globalDefaults.defaultFontSize),\n\t\t\t_footerAlign: tooltipOpts.footerAlign,\n\t\t\tfooterSpacing: tooltipOpts.footerSpacing,\n\t\t\tfooterMarginTop: tooltipOpts.footerMarginTop,\n\n\t\t\t// Appearance\n\t\t\tcaretSize: tooltipOpts.caretSize,\n\t\t\tcornerRadius: tooltipOpts.cornerRadius,\n\t\t\tbackgroundColor: tooltipOpts.backgroundColor,\n\t\t\topacity: 0,\n\t\t\tlegendColorBackground: tooltipOpts.multiKeyBackground,\n\t\t\tdisplayColors: tooltipOpts.displayColors\n\t\t};\n\t}\n\n\t/**\n\t * Get the size of the tooltip\n\t */\n\tfunction getTooltipSize(tooltip, model) {\n\t\tvar ctx = tooltip._chart.ctx;\n\n\t\tvar height = model.yPadding * 2; // Tooltip Padding\n\t\tvar width = 0;\n\n\t\t// Count of all lines in the body\n\t\tvar body = model.body;\n\t\tvar combinedBodyLength = body.reduce(function(count, bodyItem) {\n\t\t\treturn count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length;\n\t\t}, 0);\n\t\tcombinedBodyLength += model.beforeBody.length + model.afterBody.length;\n\n\t\tvar titleLineCount = model.title.length;\n\t\tvar footerLineCount = model.footer.length;\n\t\tvar titleFontSize = model.titleFontSize,\n\t\t\tbodyFontSize = model.bodyFontSize,\n\t\t\tfooterFontSize = model.footerFontSize;\n\n\t\theight += titleLineCount * titleFontSize; // Title Lines\n\t\theight += titleLineCount ? (titleLineCount - 1) * model.titleSpacing : 0; // Title Line Spacing\n\t\theight += titleLineCount ? model.titleMarginBottom : 0; // Title's bottom Margin\n\t\theight += combinedBodyLength * bodyFontSize; // Body Lines\n\t\theight += combinedBodyLength ? (combinedBodyLength - 1) * model.bodySpacing : 0; // Body Line Spacing\n\t\theight += footerLineCount ? model.footerMarginTop : 0; // Footer Margin\n\t\theight += footerLineCount * (footerFontSize); // Footer Lines\n\t\theight += footerLineCount ? (footerLineCount - 1) * model.footerSpacing : 0; // Footer Line Spacing\n\n\t\t// Title width\n\t\tvar widthPadding = 0;\n\t\tvar maxLineWidth = function(line) {\n\t\t\twidth = Math.max(width, ctx.measureText(line).width + widthPadding);\n\t\t};\n\n\t\tctx.font = helpers.fontString(titleFontSize, model._titleFontStyle, model._titleFontFamily);\n\t\thelpers.each(model.title, maxLineWidth);\n\n\t\t// Body width\n\t\tctx.font = helpers.fontString(bodyFontSize, model._bodyFontStyle, model._bodyFontFamily);\n\t\thelpers.each(model.beforeBody.concat(model.afterBody), maxLineWidth);\n\n\t\t// Body lines may include some extra width due to the color box\n\t\twidthPadding = model.displayColors ? (bodyFontSize + 2) : 0;\n\t\thelpers.each(body, function(bodyItem) {\n\t\t\thelpers.each(bodyItem.before, maxLineWidth);\n\t\t\thelpers.each(bodyItem.lines, maxLineWidth);\n\t\t\thelpers.each(bodyItem.after, maxLineWidth);\n\t\t});\n\n\t\t// Reset back to 0\n\t\twidthPadding = 0;\n\n\t\t// Footer width\n\t\tctx.font = helpers.fontString(footerFontSize, model._footerFontStyle, model._footerFontFamily);\n\t\thelpers.each(model.footer, maxLineWidth);\n\n\t\t// Add padding\n\t\twidth += 2 * model.xPadding;\n\n\t\treturn {\n\t\t\twidth: width,\n\t\t\theight: height\n\t\t};\n\t}\n\n\t/**\n\t * Helper to get the alignment of a tooltip given the size\n\t */\n\tfunction determineAlignment(tooltip, size) {\n\t\tvar model = tooltip._model;\n\t\tvar chart = tooltip._chart;\n\t\tvar chartArea = tooltip._chartInstance.chartArea;\n\t\tvar xAlign = 'center';\n\t\tvar yAlign = 'center';\n\n\t\tif (model.y < size.height) {\n\t\t\tyAlign = 'top';\n\t\t} else if (model.y > (chart.height - size.height)) {\n\t\t\tyAlign = 'bottom';\n\t\t}\n\n\t\tvar lf, rf; // functions to determine left, right alignment\n\t\tvar olf, orf; // functions to determine if left/right alignment causes tooltip to go outside chart\n\t\tvar yf; // function to get the y alignment if the tooltip goes outside of the left or right edges\n\t\tvar midX = (chartArea.left + chartArea.right) / 2;\n\t\tvar midY = (chartArea.top + chartArea.bottom) / 2;\n\n\t\tif (yAlign === 'center') {\n\t\t\tlf = function(x) {\n\t\t\t\treturn x <= midX;\n\t\t\t};\n\t\t\trf = function(x) {\n\t\t\t\treturn x > midX;\n\t\t\t};\n\t\t} else {\n\t\t\tlf = function(x) {\n\t\t\t\treturn x <= (size.width / 2);\n\t\t\t};\n\t\t\trf = function(x) {\n\t\t\t\treturn x >= (chart.width - (size.width / 2));\n\t\t\t};\n\t\t}\n\n\t\tolf = function(x) {\n\t\t\treturn x + size.width > chart.width;\n\t\t};\n\t\torf = function(x) {\n\t\t\treturn x - size.width < 0;\n\t\t};\n\t\tyf = function(y) {\n\t\t\treturn y <= midY ? 'top' : 'bottom';\n\t\t};\n\n\t\tif (lf(model.x)) {\n\t\t\txAlign = 'left';\n\n\t\t\t// Is tooltip too wide and goes over the right side of the chart.?\n\t\t\tif (olf(model.x)) {\n\t\t\t\txAlign = 'center';\n\t\t\t\tyAlign = yf(model.y);\n\t\t\t}\n\t\t} else if (rf(model.x)) {\n\t\t\txAlign = 'right';\n\n\t\t\t// Is tooltip too wide and goes outside left edge of canvas?\n\t\t\tif (orf(model.x)) {\n\t\t\t\txAlign = 'center';\n\t\t\t\tyAlign = yf(model.y);\n\t\t\t}\n\t\t}\n\n\t\tvar opts = tooltip._options;\n\t\treturn {\n\t\t\txAlign: opts.xAlign ? opts.xAlign : xAlign,\n\t\t\tyAlign: opts.yAlign ? opts.yAlign : yAlign\n\t\t};\n\t}\n\n\t/**\n\t * @Helper to get the location a tooltip needs to be placed at given the initial position (via the vm) and the size and alignment\n\t */\n\tfunction getBackgroundPoint(vm, size, alignment) {\n\t\t// Background Position\n\t\tvar x = vm.x;\n\t\tvar y = vm.y;\n\n\t\tvar caretSize = vm.caretSize,\n\t\t\tcaretPadding = vm.caretPadding,\n\t\t\tcornerRadius = vm.cornerRadius,\n\t\t\txAlign = alignment.xAlign,\n\t\t\tyAlign = alignment.yAlign,\n\t\t\tpaddingAndSize = caretSize + caretPadding,\n\t\t\tradiusAndPadding = cornerRadius + caretPadding;\n\n\t\tif (xAlign === 'right') {\n\t\t\tx -= size.width;\n\t\t} else if (xAlign === 'center') {\n\t\t\tx -= (size.width / 2);\n\t\t}\n\n\t\tif (yAlign === 'top') {\n\t\t\ty += paddingAndSize;\n\t\t} else if (yAlign === 'bottom') {\n\t\t\ty -= size.height + paddingAndSize;\n\t\t} else {\n\t\t\ty -= (size.height / 2);\n\t\t}\n\n\t\tif (yAlign === 'center') {\n\t\t\tif (xAlign === 'left') {\n\t\t\t\tx += paddingAndSize;\n\t\t\t} else if (xAlign === 'right') {\n\t\t\t\tx -= paddingAndSize;\n\t\t\t}\n\t\t} else if (xAlign === 'left') {\n\t\t\tx -= radiusAndPadding;\n\t\t} else if (xAlign === 'right') {\n\t\t\tx += radiusAndPadding;\n\t\t}\n\n\t\treturn {\n\t\t\tx: x,\n\t\t\ty: y\n\t\t};\n\t}\n\n\tChart.Tooltip = Chart.Element.extend({\n\t\tinitialize: function() {\n\t\t\tthis._model = getBaseModel(this._options);\n\t\t},\n\n\t\t// Get the title\n\t\t// Args are: (tooltipItem, data)\n\t\tgetTitle: function() {\n\t\t\tvar me = this;\n\t\t\tvar opts = me._options;\n\t\t\tvar callbacks = opts.callbacks;\n\n\t\t\tvar beforeTitle = callbacks.beforeTitle.apply(me, arguments),\n\t\t\t\ttitle = callbacks.title.apply(me, arguments),\n\t\t\t\tafterTitle = callbacks.afterTitle.apply(me, arguments);\n\n\t\t\tvar lines = [];\n\t\t\tlines = pushOrConcat(lines, beforeTitle);\n\t\t\tlines = pushOrConcat(lines, title);\n\t\t\tlines = pushOrConcat(lines, afterTitle);\n\n\t\t\treturn lines;\n\t\t},\n\n\t\t// Args are: (tooltipItem, data)\n\t\tgetBeforeBody: function() {\n\t\t\tvar lines = this._options.callbacks.beforeBody.apply(this, arguments);\n\t\t\treturn helpers.isArray(lines) ? lines : lines !== undefined ? [lines] : [];\n\t\t},\n\n\t\t// Args are: (tooltipItem, data)\n\t\tgetBody: function(tooltipItems, data) {\n\t\t\tvar me = this;\n\t\t\tvar callbacks = me._options.callbacks;\n\t\t\tvar bodyItems = [];\n\n\t\t\thelpers.each(tooltipItems, function(tooltipItem) {\n\t\t\t\tvar bodyItem = {\n\t\t\t\t\tbefore: [],\n\t\t\t\t\tlines: [],\n\t\t\t\t\tafter: []\n\t\t\t\t};\n\t\t\t\tpushOrConcat(bodyItem.before, callbacks.beforeLabel.call(me, tooltipItem, data));\n\t\t\t\tpushOrConcat(bodyItem.lines, callbacks.label.call(me, tooltipItem, data));\n\t\t\t\tpushOrConcat(bodyItem.after, callbacks.afterLabel.call(me, tooltipItem, data));\n\n\t\t\t\tbodyItems.push(bodyItem);\n\t\t\t});\n\n\t\t\treturn bodyItems;\n\t\t},\n\n\t\t// Args are: (tooltipItem, data)\n\t\tgetAfterBody: function() {\n\t\t\tvar lines = this._options.callbacks.afterBody.apply(this, arguments);\n\t\t\treturn helpers.isArray(lines) ? lines : lines !== undefined ? [lines] : [];\n\t\t},\n\n\t\t// Get the footer and beforeFooter and afterFooter lines\n\t\t// Args are: (tooltipItem, data)\n\t\tgetFooter: function() {\n\t\t\tvar me = this;\n\t\t\tvar callbacks = me._options.callbacks;\n\n\t\t\tvar beforeFooter = callbacks.beforeFooter.apply(me, arguments);\n\t\t\tvar footer = callbacks.footer.apply(me, arguments);\n\t\t\tvar afterFooter = callbacks.afterFooter.apply(me, arguments);\n\n\t\t\tvar lines = [];\n\t\t\tlines = pushOrConcat(lines, beforeFooter);\n\t\t\tlines = pushOrConcat(lines, footer);\n\t\t\tlines = pushOrConcat(lines, afterFooter);\n\n\t\t\treturn lines;\n\t\t},\n\n\t\tupdate: function(changed) {\n\t\t\tvar me = this;\n\t\t\tvar opts = me._options;\n\n\t\t\t// Need to regenerate the model because its faster than using extend and it is necessary due to the optimization in Chart.Element.transition\n\t\t\t// that does _view = _model if ease === 1. This causes the 2nd tooltip update to set properties in both the view and model at the same time\n\t\t\t// which breaks any animations.\n\t\t\tvar existingModel = me._model;\n\t\t\tvar model = me._model = getBaseModel(opts);\n\t\t\tvar active = me._active;\n\n\t\t\tvar data = me._data;\n\t\t\tvar chartInstance = me._chartInstance;\n\n\t\t\t// In the case where active.length === 0 we need to keep these at existing values for good animations\n\t\t\tvar alignment = {\n\t\t\t\txAlign: existingModel.xAlign,\n\t\t\t\tyAlign: existingModel.yAlign\n\t\t\t};\n\t\t\tvar backgroundPoint = {\n\t\t\t\tx: existingModel.x,\n\t\t\t\ty: existingModel.y\n\t\t\t};\n\t\t\tvar tooltipSize = {\n\t\t\t\twidth: existingModel.width,\n\t\t\t\theight: existingModel.height\n\t\t\t};\n\t\t\tvar tooltipPosition = {\n\t\t\t\tx: existingModel.caretX,\n\t\t\t\ty: existingModel.caretY\n\t\t\t};\n\n\t\t\tvar i, len;\n\n\t\t\tif (active.length) {\n\t\t\t\tmodel.opacity = 1;\n\n\t\t\t\tvar labelColors = [];\n\t\t\t\ttooltipPosition = Chart.Tooltip.positioners[opts.position](active, me._eventPosition);\n\n\t\t\t\tvar tooltipItems = [];\n\t\t\t\tfor (i = 0, len = active.length; i < len; ++i) {\n\t\t\t\t\ttooltipItems.push(createTooltipItem(active[i]));\n\t\t\t\t}\n\n\t\t\t\t// If the user provided a filter function, use it to modify the tooltip items\n\t\t\t\tif (opts.filter) {\n\t\t\t\t\ttooltipItems = tooltipItems.filter(function(a) {\n\t\t\t\t\t\treturn opts.filter(a, data);\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t// If the user provided a sorting function, use it to modify the tooltip items\n\t\t\t\tif (opts.itemSort) {\n\t\t\t\t\ttooltipItems = tooltipItems.sort(function(a, b) {\n\t\t\t\t\t\treturn opts.itemSort(a, b, data);\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t// Determine colors for boxes\n\t\t\t\thelpers.each(tooltipItems, function(tooltipItem) {\n\t\t\t\t\tlabelColors.push(opts.callbacks.labelColor.call(me, tooltipItem, chartInstance));\n\t\t\t\t});\n\n\t\t\t\t// Build the Text Lines\n\t\t\t\tmodel.title = me.getTitle(tooltipItems, data);\n\t\t\t\tmodel.beforeBody = me.getBeforeBody(tooltipItems, data);\n\t\t\t\tmodel.body = me.getBody(tooltipItems, data);\n\t\t\t\tmodel.afterBody = me.getAfterBody(tooltipItems, data);\n\t\t\t\tmodel.footer = me.getFooter(tooltipItems, data);\n\n\t\t\t\t// Initial positioning and colors\n\t\t\t\tmodel.x = Math.round(tooltipPosition.x);\n\t\t\t\tmodel.y = Math.round(tooltipPosition.y);\n\t\t\t\tmodel.caretPadding = helpers.getValueOrDefault(tooltipPosition.padding, 2);\n\t\t\t\tmodel.labelColors = labelColors;\n\n\t\t\t\t// data points\n\t\t\t\tmodel.dataPoints = tooltipItems;\n\n\t\t\t\t// We need to determine alignment of the tooltip\n\t\t\t\ttooltipSize = getTooltipSize(this, model);\n\t\t\t\talignment = determineAlignment(this, tooltipSize);\n\t\t\t\t// Final Size and Position\n\t\t\t\tbackgroundPoint = getBackgroundPoint(model, tooltipSize, alignment);\n\t\t\t} else {\n\t\t\t\tmodel.opacity = 0;\n\t\t\t}\n\n\t\t\tmodel.xAlign = alignment.xAlign;\n\t\t\tmodel.yAlign = alignment.yAlign;\n\t\t\tmodel.x = backgroundPoint.x;\n\t\t\tmodel.y = backgroundPoint.y;\n\t\t\tmodel.width = tooltipSize.width;\n\t\t\tmodel.height = tooltipSize.height;\n\n\t\t\t// Point where the caret on the tooltip points to\n\t\t\tmodel.caretX = tooltipPosition.x;\n\t\t\tmodel.caretY = tooltipPosition.y;\n\n\t\t\tme._model = model;\n\n\t\t\tif (changed && opts.custom) {\n\t\t\t\topts.custom.call(me, model);\n\t\t\t}\n\n\t\t\treturn me;\n\t\t},\n\t\tdrawCaret: function(tooltipPoint, size, opacity) {\n\t\t\tvar vm = this._view;\n\t\t\tvar ctx = this._chart.ctx;\n\t\t\tvar x1, x2, x3;\n\t\t\tvar y1, y2, y3;\n\t\t\tvar caretSize = vm.caretSize;\n\t\t\tvar cornerRadius = vm.cornerRadius;\n\t\t\tvar xAlign = vm.xAlign,\n\t\t\t\tyAlign = vm.yAlign;\n\t\t\tvar ptX = tooltipPoint.x,\n\t\t\t\tptY = tooltipPoint.y;\n\t\t\tvar width = size.width,\n\t\t\t\theight = size.height;\n\n\t\t\tif (yAlign === 'center') {\n\t\t\t\t// Left or right side\n\t\t\t\tif (xAlign === 'left') {\n\t\t\t\t\tx1 = ptX;\n\t\t\t\t\tx2 = x1 - caretSize;\n\t\t\t\t\tx3 = x1;\n\t\t\t\t} else {\n\t\t\t\t\tx1 = ptX + width;\n\t\t\t\t\tx2 = x1 + caretSize;\n\t\t\t\t\tx3 = x1;\n\t\t\t\t}\n\n\t\t\t\ty2 = ptY + (height / 2);\n\t\t\t\ty1 = y2 - caretSize;\n\t\t\t\ty3 = y2 + caretSize;\n\t\t\t} else {\n\t\t\t\tif (xAlign === 'left') {\n\t\t\t\t\tx1 = ptX + cornerRadius;\n\t\t\t\t\tx2 = x1 + caretSize;\n\t\t\t\t\tx3 = x2 + caretSize;\n\t\t\t\t} else if (xAlign === 'right') {\n\t\t\t\t\tx1 = ptX + width - cornerRadius;\n\t\t\t\t\tx2 = x1 - caretSize;\n\t\t\t\t\tx3 = x2 - caretSize;\n\t\t\t\t} else {\n\t\t\t\t\tx2 = ptX + (width / 2);\n\t\t\t\t\tx1 = x2 - caretSize;\n\t\t\t\t\tx3 = x2 + caretSize;\n\t\t\t\t}\n\n\t\t\t\tif (yAlign === 'top') {\n\t\t\t\t\ty1 = ptY;\n\t\t\t\t\ty2 = y1 - caretSize;\n\t\t\t\t\ty3 = y1;\n\t\t\t\t} else {\n\t\t\t\t\ty1 = ptY + height;\n\t\t\t\t\ty2 = y1 + caretSize;\n\t\t\t\t\ty3 = y1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tctx.fillStyle = mergeOpacity(vm.backgroundColor, opacity);\n\t\t\tctx.beginPath();\n\t\t\tctx.moveTo(x1, y1);\n\t\t\tctx.lineTo(x2, y2);\n\t\t\tctx.lineTo(x3, y3);\n\t\t\tctx.closePath();\n\t\t\tctx.fill();\n\t\t},\n\t\tdrawTitle: function(pt, vm, ctx, opacity) {\n\t\t\tvar title = vm.title;\n\n\t\t\tif (title.length) {\n\t\t\t\tctx.textAlign = vm._titleAlign;\n\t\t\t\tctx.textBaseline = 'top';\n\n\t\t\t\tvar titleFontSize = vm.titleFontSize,\n\t\t\t\t\ttitleSpacing = vm.titleSpacing;\n\n\t\t\t\tctx.fillStyle = mergeOpacity(vm.titleFontColor, opacity);\n\t\t\t\tctx.font = helpers.fontString(titleFontSize, vm._titleFontStyle, vm._titleFontFamily);\n\n\t\t\t\tvar i, len;\n\t\t\t\tfor (i = 0, len = title.length; i < len; ++i) {\n\t\t\t\t\tctx.fillText(title[i], pt.x, pt.y);\n\t\t\t\t\tpt.y += titleFontSize + titleSpacing; // Line Height and spacing\n\n\t\t\t\t\tif (i + 1 === title.length) {\n\t\t\t\t\t\tpt.y += vm.titleMarginBottom - titleSpacing; // If Last, add margin, remove spacing\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tdrawBody: function(pt, vm, ctx, opacity) {\n\t\t\tvar bodyFontSize = vm.bodyFontSize;\n\t\t\tvar bodySpacing = vm.bodySpacing;\n\t\t\tvar body = vm.body;\n\n\t\t\tctx.textAlign = vm._bodyAlign;\n\t\t\tctx.textBaseline = 'top';\n\n\t\t\tvar textColor = mergeOpacity(vm.bodyFontColor, opacity);\n\t\t\tctx.fillStyle = textColor;\n\t\t\tctx.font = helpers.fontString(bodyFontSize, vm._bodyFontStyle, vm._bodyFontFamily);\n\n\t\t\t// Before Body\n\t\t\tvar xLinePadding = 0;\n\t\t\tvar fillLineOfText = function(line) {\n\t\t\t\tctx.fillText(line, pt.x + xLinePadding, pt.y);\n\t\t\t\tpt.y += bodyFontSize + bodySpacing;\n\t\t\t};\n\n\t\t\t// Before body lines\n\t\t\thelpers.each(vm.beforeBody, fillLineOfText);\n\n\t\t\tvar drawColorBoxes = vm.displayColors;\n\t\t\txLinePadding = drawColorBoxes ? (bodyFontSize + 2) : 0;\n\n\t\t\t// Draw body lines now\n\t\t\thelpers.each(body, function(bodyItem, i) {\n\t\t\t\thelpers.each(bodyItem.before, fillLineOfText);\n\n\t\t\t\thelpers.each(bodyItem.lines, function(line) {\n\t\t\t\t\t// Draw Legend-like boxes if needed\n\t\t\t\t\tif (drawColorBoxes) {\n\t\t\t\t\t\t// Fill a white rect so that colours merge nicely if the opacity is < 1\n\t\t\t\t\t\tctx.fillStyle = mergeOpacity(vm.legendColorBackground, opacity);\n\t\t\t\t\t\tctx.fillRect(pt.x, pt.y, bodyFontSize, bodyFontSize);\n\n\t\t\t\t\t\t// Border\n\t\t\t\t\t\tctx.strokeStyle = mergeOpacity(vm.labelColors[i].borderColor, opacity);\n\t\t\t\t\t\tctx.strokeRect(pt.x, pt.y, bodyFontSize, bodyFontSize);\n\n\t\t\t\t\t\t// Inner square\n\t\t\t\t\t\tctx.fillStyle = mergeOpacity(vm.labelColors[i].backgroundColor, opacity);\n\t\t\t\t\t\tctx.fillRect(pt.x + 1, pt.y + 1, bodyFontSize - 2, bodyFontSize - 2);\n\n\t\t\t\t\t\tctx.fillStyle = textColor;\n\t\t\t\t\t}\n\n\t\t\t\t\tfillLineOfText(line);\n\t\t\t\t});\n\n\t\t\t\thelpers.each(bodyItem.after, fillLineOfText);\n\t\t\t});\n\n\t\t\t// Reset back to 0 for after body\n\t\t\txLinePadding = 0;\n\n\t\t\t// After body lines\n\t\t\thelpers.each(vm.afterBody, fillLineOfText);\n\t\t\tpt.y -= bodySpacing; // Remove last body spacing\n\t\t},\n\t\tdrawFooter: function(pt, vm, ctx, opacity) {\n\t\t\tvar footer = vm.footer;\n\n\t\t\tif (footer.length) {\n\t\t\t\tpt.y += vm.footerMarginTop;\n\n\t\t\t\tctx.textAlign = vm._footerAlign;\n\t\t\t\tctx.textBaseline = 'top';\n\n\t\t\t\tctx.fillStyle = mergeOpacity(vm.footerFontColor, opacity);\n\t\t\t\tctx.font = helpers.fontString(vm.footerFontSize, vm._footerFontStyle, vm._footerFontFamily);\n\n\t\t\t\thelpers.each(footer, function(line) {\n\t\t\t\t\tctx.fillText(line, pt.x, pt.y);\n\t\t\t\t\tpt.y += vm.footerFontSize + vm.footerSpacing;\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\t\tdrawBackground: function(pt, vm, ctx, tooltipSize, opacity) {\n\t\t\tctx.fillStyle = mergeOpacity(vm.backgroundColor, opacity);\n\t\t\thelpers.drawRoundedRectangle(ctx, pt.x, pt.y, tooltipSize.width, tooltipSize.height, vm.cornerRadius);\n\t\t\tctx.fill();\n\t\t},\n\t\tdraw: function() {\n\t\t\tvar ctx = this._chart.ctx;\n\t\t\tvar vm = this._view;\n\n\t\t\tif (vm.opacity === 0) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar tooltipSize = {\n\t\t\t\twidth: vm.width,\n\t\t\t\theight: vm.height\n\t\t\t};\n\t\t\tvar pt = {\n\t\t\t\tx: vm.x,\n\t\t\t\ty: vm.y\n\t\t\t};\n\n\t\t\t// IE11/Edge does not like very small opacities, so snap to 0\n\t\t\tvar opacity = Math.abs(vm.opacity < 1e-3) ? 0 : vm.opacity;\n\n\t\t\tif (this._options.enabled) {\n\t\t\t\t// Draw Background\n\t\t\t\tthis.drawBackground(pt, vm, ctx, tooltipSize, opacity);\n\n\t\t\t\t// Draw Caret\n\t\t\t\tthis.drawCaret(pt, tooltipSize, opacity);\n\n\t\t\t\t// Draw Title, Body, and Footer\n\t\t\t\tpt.x += vm.xPadding;\n\t\t\t\tpt.y += vm.yPadding;\n\n\t\t\t\t// Titles\n\t\t\t\tthis.drawTitle(pt, vm, ctx, opacity);\n\n\t\t\t\t// Body\n\t\t\t\tthis.drawBody(pt, vm, ctx, opacity);\n\n\t\t\t\t// Footer\n\t\t\t\tthis.drawFooter(pt, vm, ctx, opacity);\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Handle an event\n\t\t * @private\n\t\t * @param {IEvent} event - The event to handle\n\t\t * @returns {Boolean} true if the tooltip changed\n\t\t */\n\t\thandleEvent: function(e) {\n\t\t\tvar me = this;\n\t\t\tvar options = me._options;\n\t\t\tvar changed = false;\n\n\t\t\tme._lastActive = me._lastActive || [];\n\n\t\t\t// Find Active Elements for tooltips\n\t\t\tif (e.type === 'mouseout') {\n\t\t\t\tme._active = [];\n\t\t\t} else {\n\t\t\t\tme._active = me._chartInstance.getElementsAtEventForMode(e, options.mode, options);\n\t\t\t}\n\n\t\t\t// Remember Last Actives\n\t\t\tchanged = !helpers.arrayEquals(me._active, me._lastActive);\n\t\t\tme._lastActive = me._active;\n\n\t\t\tif (options.enabled || options.custom) {\n\t\t\t\tme._eventPosition = {\n\t\t\t\t\tx: e.x,\n\t\t\t\t\ty: e.y\n\t\t\t\t};\n\n\t\t\t\tvar model = me._model;\n\t\t\t\tme.update(true);\n\t\t\t\tme.pivot();\n\n\t\t\t\t// See if our tooltip position changed\n\t\t\t\tchanged |= (model.x !== me._model.x) || (model.y !== me._model.y);\n\t\t\t}\n\n\t\t\treturn changed;\n\t\t}\n\t});\n\n\t/**\n\t * @namespace Chart.Tooltip.positioners\n\t */\n\tChart.Tooltip.positioners = {\n\t\t/**\n\t\t * Average mode places the tooltip at the average position of the elements shown\n\t\t * @function Chart.Tooltip.positioners.average\n\t\t * @param elements {ChartElement[]} the elements being displayed in the tooltip\n\t\t * @returns {Point} tooltip position\n\t\t */\n\t\taverage: function(elements) {\n\t\t\tif (!elements.length) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tvar i, len;\n\t\t\tvar x = 0;\n\t\t\tvar y = 0;\n\t\t\tvar count = 0;\n\n\t\t\tfor (i = 0, len = elements.length; i < len; ++i) {\n\t\t\t\tvar el = elements[i];\n\t\t\t\tif (el && el.hasValue()) {\n\t\t\t\t\tvar pos = el.tooltipPosition();\n\t\t\t\t\tx += pos.x;\n\t\t\t\t\ty += pos.y;\n\t\t\t\t\t++count;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tx: Math.round(x / count),\n\t\t\t\ty: Math.round(y / count)\n\t\t\t};\n\t\t},\n\n\t\t/**\n\t\t * Gets the tooltip position nearest of the item nearest to the event position\n\t\t * @function Chart.Tooltip.positioners.nearest\n\t\t * @param elements {Chart.Element[]} the tooltip elements\n\t\t * @param eventPosition {Point} the position of the event in canvas coordinates\n\t\t * @returns {Point} the tooltip position\n\t\t */\n\t\tnearest: function(elements, eventPosition) {\n\t\t\tvar x = eventPosition.x;\n\t\t\tvar y = eventPosition.y;\n\n\t\t\tvar nearestElement;\n\t\t\tvar minDistance = Number.POSITIVE_INFINITY;\n\t\t\tvar i, len;\n\t\t\tfor (i = 0, len = elements.length; i < len; ++i) {\n\t\t\t\tvar el = elements[i];\n\t\t\t\tif (el && el.hasValue()) {\n\t\t\t\t\tvar center = el.getCenterPoint();\n\t\t\t\t\tvar d = helpers.distanceBetweenPoints(eventPosition, center);\n\n\t\t\t\t\tif (d < minDistance) {\n\t\t\t\t\t\tminDistance = d;\n\t\t\t\t\t\tnearestElement = el;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (nearestElement) {\n\t\t\t\tvar tp = nearestElement.tooltipPosition();\n\t\t\t\tx = tp.x;\n\t\t\t\ty = tp.y;\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tx: x,\n\t\t\t\ty: y\n\t\t\t};\n\t\t}\n\t};\n};\n\n},{}],37:[function(require,module,exports){\n'use strict';\n\nmodule.exports = function(Chart) {\n\n\tvar helpers = Chart.helpers,\n\t\tglobalOpts = Chart.defaults.global;\n\n\tglobalOpts.elements.arc = {\n\t\tbackgroundColor: globalOpts.defaultColor,\n\t\tborderColor: '#fff',\n\t\tborderWidth: 2\n\t};\n\n\tChart.elements.Arc = Chart.Element.extend({\n\t\tinLabelRange: function(mouseX) {\n\t\t\tvar vm = this._view;\n\n\t\t\tif (vm) {\n\t\t\t\treturn (Math.pow(mouseX - vm.x, 2) < Math.pow(vm.radius + vm.hoverRadius, 2));\n\t\t\t}\n\t\t\treturn false;\n\t\t},\n\t\tinRange: function(chartX, chartY) {\n\t\t\tvar vm = this._view;\n\n\t\t\tif (vm) {\n\t\t\t\tvar pointRelativePosition = helpers.getAngleFromPoint(vm, {\n\t\t\t\t\t\tx: chartX,\n\t\t\t\t\t\ty: chartY\n\t\t\t\t\t}),\n\t\t\t\t\tangle = pointRelativePosition.angle,\n\t\t\t\t\tdistance = pointRelativePosition.distance;\n\n\t\t\t\t// Sanitise angle range\n\t\t\t\tvar startAngle = vm.startAngle;\n\t\t\t\tvar endAngle = vm.endAngle;\n\t\t\t\twhile (endAngle < startAngle) {\n\t\t\t\t\tendAngle += 2.0 * Math.PI;\n\t\t\t\t}\n\t\t\t\twhile (angle > endAngle) {\n\t\t\t\t\tangle -= 2.0 * Math.PI;\n\t\t\t\t}\n\t\t\t\twhile (angle < startAngle) {\n\t\t\t\t\tangle += 2.0 * Math.PI;\n\t\t\t\t}\n\n\t\t\t\t// Check if within the range of the open/close angle\n\t\t\t\tvar betweenAngles = (angle >= startAngle && angle <= endAngle),\n\t\t\t\t\twithinRadius = (distance >= vm.innerRadius && distance <= vm.outerRadius);\n\n\t\t\t\treturn (betweenAngles && withinRadius);\n\t\t\t}\n\t\t\treturn false;\n\t\t},\n\t\tgetCenterPoint: function() {\n\t\t\tvar vm = this._view;\n\t\t\tvar halfAngle = (vm.startAngle + vm.endAngle) / 2;\n\t\t\tvar halfRadius = (vm.innerRadius + vm.outerRadius) / 2;\n\t\t\treturn {\n\t\t\t\tx: vm.x + Math.cos(halfAngle) * halfRadius,\n\t\t\t\ty: vm.y + Math.sin(halfAngle) * halfRadius\n\t\t\t};\n\t\t},\n\t\tgetArea: function() {\n\t\t\tvar vm = this._view;\n\t\t\treturn Math.PI * ((vm.endAngle - vm.startAngle) / (2 * Math.PI)) * (Math.pow(vm.outerRadius, 2) - Math.pow(vm.innerRadius, 2));\n\t\t},\n\t\ttooltipPosition: function() {\n\t\t\tvar vm = this._view;\n\n\t\t\tvar centreAngle = vm.startAngle + ((vm.endAngle - vm.startAngle) / 2),\n\t\t\t\trangeFromCentre = (vm.outerRadius - vm.innerRadius) / 2 + vm.innerRadius;\n\t\t\treturn {\n\t\t\t\tx: vm.x + (Math.cos(centreAngle) * rangeFromCentre),\n\t\t\t\ty: vm.y + (Math.sin(centreAngle) * rangeFromCentre)\n\t\t\t};\n\t\t},\n\t\tdraw: function() {\n\n\t\t\tvar ctx = this._chart.ctx,\n\t\t\t\tvm = this._view,\n\t\t\t\tsA = vm.startAngle,\n\t\t\t\teA = vm.endAngle;\n\n\t\t\tctx.beginPath();\n\n\t\t\tctx.arc(vm.x, vm.y, vm.outerRadius, sA, eA);\n\t\t\tctx.arc(vm.x, vm.y, vm.innerRadius, eA, sA, true);\n\n\t\t\tctx.closePath();\n\t\t\tctx.strokeStyle = vm.borderColor;\n\t\t\tctx.lineWidth = vm.borderWidth;\n\n\t\t\tctx.fillStyle = vm.backgroundColor;\n\n\t\t\tctx.fill();\n\t\t\tctx.lineJoin = 'bevel';\n\n\t\t\tif (vm.borderWidth) {\n\t\t\t\tctx.stroke();\n\t\t\t}\n\t\t}\n\t});\n};\n\n},{}],38:[function(require,module,exports){\n'use strict';\n\nmodule.exports = function(Chart) {\n\n\tvar helpers = Chart.helpers;\n\tvar globalDefaults = Chart.defaults.global;\n\n\tChart.defaults.global.elements.line = {\n\t\ttension: 0.4,\n\t\tbackgroundColor: globalDefaults.defaultColor,\n\t\tborderWidth: 3,\n\t\tborderColor: globalDefaults.defaultColor,\n\t\tborderCapStyle: 'butt',\n\t\tborderDash: [],\n\t\tborderDashOffset: 0.0,\n\t\tborderJoinStyle: 'miter',\n\t\tcapBezierPoints: true,\n\t\tfill: true, // do we fill in the area between the line and its base axis\n\t};\n\n\tChart.elements.Line = Chart.Element.extend({\n\t\tdraw: function() {\n\t\t\tvar me = this;\n\t\t\tvar vm = me._view;\n\t\t\tvar spanGaps = vm.spanGaps;\n\t\t\tvar fillPoint = vm.scaleZero;\n\t\t\tvar loop = me._loop;\n\n\t\t\t// Handle different fill modes for cartesian lines\n\t\t\tif (!loop) {\n\t\t\t\tif (vm.fill === 'top') {\n\t\t\t\t\tfillPoint = vm.scaleTop;\n\t\t\t\t} else if (vm.fill === 'bottom') {\n\t\t\t\t\tfillPoint = vm.scaleBottom;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar ctx = me._chart.ctx;\n\t\t\tctx.save();\n\n\t\t\t// Helper function to draw a line to a point\n\t\t\tfunction lineToPoint(previousPoint, point) {\n\t\t\t\tvar pointVM = point._view;\n\t\t\t\tif (point._view.steppedLine === true) {\n\t\t\t\t\tctx.lineTo(pointVM.x, previousPoint._view.y);\n\t\t\t\t\tctx.lineTo(pointVM.x, pointVM.y);\n\t\t\t\t} else if (point._view.tension === 0) {\n\t\t\t\t\tctx.lineTo(pointVM.x, pointVM.y);\n\t\t\t\t} else {\n\t\t\t\t\tctx.bezierCurveTo(\n\t\t\t\t\t\tpreviousPoint._view.controlPointNextX,\n\t\t\t\t\t\tpreviousPoint._view.controlPointNextY,\n\t\t\t\t\t\tpointVM.controlPointPreviousX,\n\t\t\t\t\t\tpointVM.controlPointPreviousY,\n\t\t\t\t\t\tpointVM.x,\n\t\t\t\t\t\tpointVM.y\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar points = me._children.slice(); // clone array\n\t\t\tvar lastDrawnIndex = -1;\n\n\t\t\t// If we are looping, adding the first point again\n\t\t\tif (loop && points.length) {\n\t\t\t\tpoints.push(points[0]);\n\t\t\t}\n\n\t\t\tvar index, current, previous, currentVM;\n\n\t\t\t// Fill Line\n\t\t\tif (points.length && vm.fill) {\n\t\t\t\tctx.beginPath();\n\n\t\t\t\tfor (index = 0; index < points.length; ++index) {\n\t\t\t\t\tcurrent = points[index];\n\t\t\t\t\tprevious = helpers.previousItem(points, index);\n\t\t\t\t\tcurrentVM = current._view;\n\n\t\t\t\t\t// First point moves to it's starting position no matter what\n\t\t\t\t\tif (index === 0) {\n\t\t\t\t\t\tif (loop) {\n\t\t\t\t\t\t\tctx.moveTo(fillPoint.x, fillPoint.y);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tctx.moveTo(currentVM.x, fillPoint);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (!currentVM.skip) {\n\t\t\t\t\t\t\tlastDrawnIndex = index;\n\t\t\t\t\t\t\tctx.lineTo(currentVM.x, currentVM.y);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tprevious = lastDrawnIndex === -1 ? previous : points[lastDrawnIndex];\n\n\t\t\t\t\t\tif (currentVM.skip) {\n\t\t\t\t\t\t\t// Only do this if this is the first point that is skipped\n\t\t\t\t\t\t\tif (!spanGaps && lastDrawnIndex === (index - 1)) {\n\t\t\t\t\t\t\t\tif (loop) {\n\t\t\t\t\t\t\t\t\tctx.lineTo(fillPoint.x, fillPoint.y);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tctx.lineTo(previous._view.x, fillPoint);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (lastDrawnIndex !== (index - 1)) {\n\t\t\t\t\t\t\t\t// There was a gap and this is the first point after the gap. If we've never drawn a point, this is a special case.\n\t\t\t\t\t\t\t\t// If the first data point is NaN, then there is no real gap to skip\n\t\t\t\t\t\t\t\tif (spanGaps && lastDrawnIndex !== -1) {\n\t\t\t\t\t\t\t\t\t// We are spanning the gap, so simple draw a line to this point\n\t\t\t\t\t\t\t\t\tlineToPoint(previous, current);\n\t\t\t\t\t\t\t\t} else if (loop) {\n\t\t\t\t\t\t\t\t\tctx.lineTo(currentVM.x, currentVM.y);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tctx.lineTo(currentVM.x, fillPoint);\n\t\t\t\t\t\t\t\t\tctx.lineTo(currentVM.x, currentVM.y);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// Line to next point\n\t\t\t\t\t\t\t\tlineToPoint(previous, current);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tlastDrawnIndex = index;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!loop && lastDrawnIndex !== -1) {\n\t\t\t\t\tctx.lineTo(points[lastDrawnIndex]._view.x, fillPoint);\n\t\t\t\t}\n\n\t\t\t\tctx.fillStyle = vm.backgroundColor || globalDefaults.defaultColor;\n\t\t\t\tctx.closePath();\n\t\t\t\tctx.fill();\n\t\t\t}\n\n\t\t\t// Stroke Line Options\n\t\t\tvar globalOptionLineElements = globalDefaults.elements.line;\n\t\t\tctx.lineCap = vm.borderCapStyle || globalOptionLineElements.borderCapStyle;\n\n\t\t\t// IE 9 and 10 do not support line dash\n\t\t\tif (ctx.setLineDash) {\n\t\t\t\tctx.setLineDash(vm.borderDash || globalOptionLineElements.borderDash);\n\t\t\t}\n\n\t\t\tctx.lineDashOffset = vm.borderDashOffset || globalOptionLineElements.borderDashOffset;\n\t\t\tctx.lineJoin = vm.borderJoinStyle || globalOptionLineElements.borderJoinStyle;\n\t\t\tctx.lineWidth = vm.borderWidth || globalOptionLineElements.borderWidth;\n\t\t\tctx.strokeStyle = vm.borderColor || globalDefaults.defaultColor;\n\n\t\t\t// Stroke Line\n\t\t\tctx.beginPath();\n\t\t\tlastDrawnIndex = -1;\n\n\t\t\tfor (index = 0; index < points.length; ++index) {\n\t\t\t\tcurrent = points[index];\n\t\t\t\tprevious = helpers.previousItem(points, index);\n\t\t\t\tcurrentVM = current._view;\n\n\t\t\t\t// First point moves to it's starting position no matter what\n\t\t\t\tif (index === 0) {\n\t\t\t\t\tif (!currentVM.skip) {\n\t\t\t\t\t\tctx.moveTo(currentVM.x, currentVM.y);\n\t\t\t\t\t\tlastDrawnIndex = index;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tprevious = lastDrawnIndex === -1 ? previous : points[lastDrawnIndex];\n\n\t\t\t\t\tif (!currentVM.skip) {\n\t\t\t\t\t\tif ((lastDrawnIndex !== (index - 1) && !spanGaps) || lastDrawnIndex === -1) {\n\t\t\t\t\t\t\t// There was a gap and this is the first point after the gap\n\t\t\t\t\t\t\tctx.moveTo(currentVM.x, currentVM.y);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Line to next point\n\t\t\t\t\t\t\tlineToPoint(previous, current);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlastDrawnIndex = index;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tctx.stroke();\n\t\t\tctx.restore();\n\t\t}\n\t});\n};\n\n},{}],39:[function(require,module,exports){\n'use strict';\n\nmodule.exports = function(Chart) {\n\n\tvar helpers = Chart.helpers,\n\t\tglobalOpts = Chart.defaults.global,\n\t\tdefaultColor = globalOpts.defaultColor;\n\n\tglobalOpts.elements.point = {\n\t\tradius: 3,\n\t\tpointStyle: 'circle',\n\t\tbackgroundColor: defaultColor,\n\t\tborderWidth: 1,\n\t\tborderColor: defaultColor,\n\t\t// Hover\n\t\thitRadius: 1,\n\t\thoverRadius: 4,\n\t\thoverBorderWidth: 1\n\t};\n\n\tfunction xRange(mouseX) {\n\t\tvar vm = this._view;\n\t\treturn vm ? (Math.pow(mouseX - vm.x, 2) < Math.pow(vm.radius + vm.hitRadius, 2)) : false;\n\t}\n\n\tfunction yRange(mouseY) {\n\t\tvar vm = this._view;\n\t\treturn vm ? (Math.pow(mouseY - vm.y, 2) < Math.pow(vm.radius + vm.hitRadius, 2)) : false;\n\t}\n\n\tChart.elements.Point = Chart.Element.extend({\n\t\tinRange: function(mouseX, mouseY) {\n\t\t\tvar vm = this._view;\n\t\t\treturn vm ? ((Math.pow(mouseX - vm.x, 2) + Math.pow(mouseY - vm.y, 2)) < Math.pow(vm.hitRadius + vm.radius, 2)) : false;\n\t\t},\n\n\t\tinLabelRange: xRange,\n\t\tinXRange: xRange,\n\t\tinYRange: yRange,\n\n\t\tgetCenterPoint: function() {\n\t\t\tvar vm = this._view;\n\t\t\treturn {\n\t\t\t\tx: vm.x,\n\t\t\t\ty: vm.y\n\t\t\t};\n\t\t},\n\t\tgetArea: function() {\n\t\t\treturn Math.PI * Math.pow(this._view.radius, 2);\n\t\t},\n\t\ttooltipPosition: function() {\n\t\t\tvar vm = this._view;\n\t\t\treturn {\n\t\t\t\tx: vm.x,\n\t\t\t\ty: vm.y,\n\t\t\t\tpadding: vm.radius + vm.borderWidth\n\t\t\t};\n\t\t},\n\t\tdraw: function(chartArea) {\n\t\t\tvar vm = this._view;\n\t\t\tvar model = this._model;\n\t\t\tvar ctx = this._chart.ctx;\n\t\t\tvar pointStyle = vm.pointStyle;\n\t\t\tvar radius = vm.radius;\n\t\t\tvar x = vm.x;\n\t\t\tvar y = vm.y;\n\t\t\tvar color = Chart.helpers.color;\n\t\t\tvar errMargin = 1.01; // 1.01 is margin for Accumulated error. (Especially Edge, IE.)\n\t\t\tvar ratio = 0;\n\n\t\t\tif (vm.skip) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tctx.strokeStyle = vm.borderColor || defaultColor;\n\t\t\tctx.lineWidth = helpers.getValueOrDefault(vm.borderWidth, globalOpts.elements.point.borderWidth);\n\t\t\tctx.fillStyle = vm.backgroundColor || defaultColor;\n\n\t\t\t// Cliping for Points.\n\t\t\t// going out from inner charArea?\n\t\t\tif ((chartArea !== undefined) && ((model.x < chartArea.left) || (chartArea.right*errMargin < model.x) || (model.y < chartArea.top) || (chartArea.bottom*errMargin < model.y))) {\n\t\t\t\t// Point fade out\n\t\t\t\tif (model.x < chartArea.left) {\n\t\t\t\t\tratio = (x - model.x) / (chartArea.left - model.x);\n\t\t\t\t} else if (chartArea.right*errMargin < model.x) {\n\t\t\t\t\tratio = (model.x - x) / (model.x - chartArea.right);\n\t\t\t\t} else if (model.y < chartArea.top) {\n\t\t\t\t\tratio = (y - model.y) / (chartArea.top - model.y);\n\t\t\t\t} else if (chartArea.bottom*errMargin < model.y) {\n\t\t\t\t\tratio = (model.y - y) / (model.y - chartArea.bottom);\n\t\t\t\t}\n\t\t\t\tratio = Math.round(ratio*100) / 100;\n\t\t\t\tctx.strokeStyle = color(ctx.strokeStyle).alpha(ratio).rgbString();\n\t\t\t\tctx.fillStyle = color(ctx.fillStyle).alpha(ratio).rgbString();\n\t\t\t}\n\n\t\t\tChart.canvasHelpers.drawPoint(ctx, pointStyle, radius, x, y);\n\t\t}\n\t});\n};\n\n},{}],40:[function(require,module,exports){\n'use strict';\n\nmodule.exports = function(Chart) {\n\n\tvar globalOpts = Chart.defaults.global;\n\n\tglobalOpts.elements.rectangle = {\n\t\tbackgroundColor: globalOpts.defaultColor,\n\t\tborderWidth: 0,\n\t\tborderColor: globalOpts.defaultColor,\n\t\tborderSkipped: 'bottom'\n\t};\n\n\tfunction isVertical(bar) {\n\t\treturn bar._view.width !== undefined;\n\t}\n\n\t/**\n\t * Helper function to get the bounds of the bar regardless of the orientation\n\t * @private\n\t * @param bar {Chart.Element.Rectangle} the bar\n\t * @return {Bounds} bounds of the bar\n\t */\n\tfunction getBarBounds(bar) {\n\t\tvar vm = bar._view;\n\t\tvar x1, x2, y1, y2;\n\n\t\tif (isVertical(bar)) {\n\t\t\t// vertical\n\t\t\tvar halfWidth = vm.width / 2;\n\t\t\tx1 = vm.x - halfWidth;\n\t\t\tx2 = vm.x + halfWidth;\n\t\t\ty1 = Math.min(vm.y, vm.base);\n\t\t\ty2 = Math.max(vm.y, vm.base);\n\t\t} else {\n\t\t\t// horizontal bar\n\t\t\tvar halfHeight = vm.height / 2;\n\t\t\tx1 = Math.min(vm.x, vm.base);\n\t\t\tx2 = Math.max(vm.x, vm.base);\n\t\t\ty1 = vm.y - halfHeight;\n\t\t\ty2 = vm.y + halfHeight;\n\t\t}\n\n\t\treturn {\n\t\t\tleft: x1,\n\t\t\ttop: y1,\n\t\t\tright: x2,\n\t\t\tbottom: y2\n\t\t};\n\t}\n\n\tChart.elements.Rectangle = Chart.Element.extend({\n\t\tdraw: function() {\n\t\t\tvar ctx = this._chart.ctx;\n\t\t\tvar vm = this._view;\n\t\t\tvar left, right, top, bottom, signX, signY, borderSkipped;\n\t\t\tvar borderWidth = vm.borderWidth;\n\n\t\t\tif (!vm.horizontal) {\n\t\t\t\t// bar\n\t\t\t\tleft = vm.x - vm.width / 2;\n\t\t\t\tright = vm.x + vm.width / 2;\n\t\t\t\ttop = vm.y;\n\t\t\t\tbottom = vm.base;\n\t\t\t\tsignX = 1;\n\t\t\t\tsignY = bottom > top? 1: -1;\n\t\t\t\tborderSkipped = vm.borderSkipped || 'bottom';\n\t\t\t} else {\n\t\t\t\t// horizontal bar\n\t\t\t\tleft = vm.base;\n\t\t\t\tright = vm.x;\n\t\t\t\ttop = vm.y - vm.height / 2;\n\t\t\t\tbottom = vm.y + vm.height / 2;\n\t\t\t\tsignX = right > left? 1: -1;\n\t\t\t\tsignY = 1;\n\t\t\t\tborderSkipped = vm.borderSkipped || 'left';\n\t\t\t}\n\n\t\t\t// Canvas doesn't allow us to stroke inside the width so we can\n\t\t\t// adjust the sizes to fit if we're setting a stroke on the line\n\t\t\tif (borderWidth) {\n\t\t\t\t// borderWidth shold be less than bar width and bar height.\n\t\t\t\tvar barSize = Math.min(Math.abs(left - right), Math.abs(top - bottom));\n\t\t\t\tborderWidth = borderWidth > barSize? barSize: borderWidth;\n\t\t\t\tvar halfStroke = borderWidth / 2;\n\t\t\t\t// Adjust borderWidth when bar top position is near vm.base(zero).\n\t\t\t\tvar borderLeft = left + (borderSkipped !== 'left'? halfStroke * signX: 0);\n\t\t\t\tvar borderRight = right + (borderSkipped !== 'right'? -halfStroke * signX: 0);\n\t\t\t\tvar borderTop = top + (borderSkipped !== 'top'? halfStroke * signY: 0);\n\t\t\t\tvar borderBottom = bottom + (borderSkipped !== 'bottom'? -halfStroke * signY: 0);\n\t\t\t\t// not become a vertical line?\n\t\t\t\tif (borderLeft !== borderRight) {\n\t\t\t\t\ttop = borderTop;\n\t\t\t\t\tbottom = borderBottom;\n\t\t\t\t}\n\t\t\t\t// not become a horizontal line?\n\t\t\t\tif (borderTop !== borderBottom) {\n\t\t\t\t\tleft = borderLeft;\n\t\t\t\t\tright = borderRight;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tctx.beginPath();\n\t\t\tctx.fillStyle = vm.backgroundColor;\n\t\t\tctx.strokeStyle = vm.borderColor;\n\t\t\tctx.lineWidth = borderWidth;\n\n\t\t\t// Corner points, from bottom-left to bottom-right clockwise\n\t\t\t// | 1 2 |\n\t\t\t// | 0 3 |\n\t\t\tvar corners = [\n\t\t\t\t[left, bottom],\n\t\t\t\t[left, top],\n\t\t\t\t[right, top],\n\t\t\t\t[right, bottom]\n\t\t\t];\n\n\t\t\t// Find first (starting) corner with fallback to 'bottom'\n\t\t\tvar borders = ['bottom', 'left', 'top', 'right'];\n\t\t\tvar startCorner = borders.indexOf(borderSkipped, 0);\n\t\t\tif (startCorner === -1) {\n\t\t\t\tstartCorner = 0;\n\t\t\t}\n\n\t\t\tfunction cornerAt(index) {\n\t\t\t\treturn corners[(startCorner + index) % 4];\n\t\t\t}\n\n\t\t\t// Draw rectangle from 'startCorner'\n\t\t\tvar corner = cornerAt(0);\n\t\t\tctx.moveTo(corner[0], corner[1]);\n\n\t\t\tfor (var i = 1; i < 4; i++) {\n\t\t\t\tcorner = cornerAt(i);\n\t\t\t\tctx.lineTo(corner[0], corner[1]);\n\t\t\t}\n\n\t\t\tctx.fill();\n\t\t\tif (borderWidth) {\n\t\t\t\tctx.stroke();\n\t\t\t}\n\t\t},\n\t\theight: function() {\n\t\t\tvar vm = this._view;\n\t\t\treturn vm.base - vm.y;\n\t\t},\n\t\tinRange: function(mouseX, mouseY) {\n\t\t\tvar inRange = false;\n\n\t\t\tif (this._view) {\n\t\t\t\tvar bounds = getBarBounds(this);\n\t\t\t\tinRange = mouseX >= bounds.left && mouseX <= bounds.right && mouseY >= bounds.top && mouseY <= bounds.bottom;\n\t\t\t}\n\n\t\t\treturn inRange;\n\t\t},\n\t\tinLabelRange: function(mouseX, mouseY) {\n\t\t\tvar me = this;\n\t\t\tif (!me._view) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tvar inRange = false;\n\t\t\tvar bounds = getBarBounds(me);\n\n\t\t\tif (isVertical(me)) {\n\t\t\t\tinRange = mouseX >= bounds.left && mouseX <= bounds.right;\n\t\t\t} else {\n\t\t\t\tinRange = mouseY >= bounds.top && mouseY <= bounds.bottom;\n\t\t\t}\n\n\t\t\treturn inRange;\n\t\t},\n\t\tinXRange: function(mouseX) {\n\t\t\tvar bounds = getBarBounds(this);\n\t\t\treturn mouseX >= bounds.left && mouseX <= bounds.right;\n\t\t},\n\t\tinYRange: function(mouseY) {\n\t\t\tvar bounds = getBarBounds(this);\n\t\t\treturn mouseY >= bounds.top && mouseY <= bounds.bottom;\n\t\t},\n\t\tgetCenterPoint: function() {\n\t\t\tvar vm = this._view;\n\t\t\tvar x, y;\n\t\t\tif (isVertical(this)) {\n\t\t\t\tx = vm.x;\n\t\t\t\ty = (vm.y + vm.base) / 2;\n\t\t\t} else {\n\t\t\t\tx = (vm.x + vm.base) / 2;\n\t\t\t\ty = vm.y;\n\t\t\t}\n\n\t\t\treturn {x: x, y: y};\n\t\t},\n\t\tgetArea: function() {\n\t\t\tvar vm = this._view;\n\t\t\treturn vm.width * Math.abs(vm.y - vm.base);\n\t\t},\n\t\ttooltipPosition: function() {\n\t\t\tvar vm = this._view;\n\t\t\treturn {\n\t\t\t\tx: vm.x,\n\t\t\t\ty: vm.y\n\t\t\t};\n\t\t}\n\t});\n\n};\n\n},{}],41:[function(require,module,exports){\n'use strict';\n\n// Chart.Platform implementation for targeting a web browser\nmodule.exports = function(Chart) {\n\tvar helpers = Chart.helpers;\n\n\t// DOM event types -> Chart.js event types.\n\t// Note: only events with different types are mapped.\n\t// https://developer.mozilla.org/en-US/docs/Web/Events\n\tvar eventTypeMap = {\n\t\t// Touch events\n\t\ttouchstart: 'mousedown',\n\t\ttouchmove: 'mousemove',\n\t\ttouchend: 'mouseup',\n\n\t\t// Pointer events\n\t\tpointerenter: 'mouseenter',\n\t\tpointerdown: 'mousedown',\n\t\tpointermove: 'mousemove',\n\t\tpointerup: 'mouseup',\n\t\tpointerleave: 'mouseout',\n\t\tpointerout: 'mouseout'\n\t};\n\n\t/**\n\t * The \"used\" size is the final value of a dimension property after all calculations have\n\t * been performed. This method uses the computed style of `element` but returns undefined\n\t * if the computed style is not expressed in pixels. That can happen in some cases where\n\t * `element` has a size relative to its parent and this last one is not yet displayed,\n\t * for example because of `display: none` on a parent node.\n\t * @see https://developer.mozilla.org/en-US/docs/Web/CSS/used_value\n\t * @returns {Number} Size in pixels or undefined if unknown.\n\t */\n\tfunction readUsedSize(element, property) {\n\t\tvar value = helpers.getStyle(element, property);\n\t\tvar matches = value && value.match(/(\\d+)px/);\n\t\treturn matches? Number(matches[1]) : undefined;\n\t}\n\n\t/**\n\t * Initializes the canvas style and render size without modifying the canvas display size,\n\t * since responsiveness is handled by the controller.resize() method. The config is used\n\t * to determine the aspect ratio to apply in case no explicit height has been specified.\n\t */\n\tfunction initCanvas(canvas, config) {\n\t\tvar style = canvas.style;\n\n\t\t// NOTE(SB) canvas.getAttribute('width') !== canvas.width: in the first case it\n\t\t// returns null or '' if no explicit value has been set to the canvas attribute.\n\t\tvar renderHeight = canvas.getAttribute('height');\n\t\tvar renderWidth = canvas.getAttribute('width');\n\n\t\t// Chart.js modifies some canvas values that we want to restore on destroy\n\t\tcanvas._chartjs = {\n\t\t\tinitial: {\n\t\t\t\theight: renderHeight,\n\t\t\t\twidth: renderWidth,\n\t\t\t\tstyle: {\n\t\t\t\t\tdisplay: style.display,\n\t\t\t\t\theight: style.height,\n\t\t\t\t\twidth: style.width\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\t// Force canvas to display as block to avoid extra space caused by inline\n\t\t// elements, which would interfere with the responsive resize process.\n\t\t// https://github.com/chartjs/Chart.js/issues/2538\n\t\tstyle.display = style.display || 'block';\n\n\t\tif (renderWidth === null || renderWidth === '') {\n\t\t\tvar displayWidth = readUsedSize(canvas, 'width');\n\t\t\tif (displayWidth !== undefined) {\n\t\t\t\tcanvas.width = displayWidth;\n\t\t\t}\n\t\t}\n\n\t\tif (renderHeight === null || renderHeight === '') {\n\t\t\tif (canvas.style.height === '') {\n\t\t\t\t// If no explicit render height and style height, let's apply the aspect ratio,\n\t\t\t\t// which one can be specified by the user but also by charts as default option\n\t\t\t\t// (i.e. options.aspectRatio). If not specified, use canvas aspect ratio of 2.\n\t\t\t\tcanvas.height = canvas.width / (config.options.aspectRatio || 2);\n\t\t\t} else {\n\t\t\t\tvar displayHeight = readUsedSize(canvas, 'height');\n\t\t\t\tif (displayWidth !== undefined) {\n\t\t\t\t\tcanvas.height = displayHeight;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn canvas;\n\t}\n\n\tfunction createEvent(type, chart, x, y, native) {\n\t\treturn {\n\t\t\ttype: type,\n\t\t\tchart: chart,\n\t\t\tnative: native || null,\n\t\t\tx: x !== undefined? x : null,\n\t\t\ty: y !== undefined? y : null,\n\t\t};\n\t}\n\n\tfunction fromNativeEvent(event, chart) {\n\t\tvar type = eventTypeMap[event.type] || event.type;\n\t\tvar pos = helpers.getRelativePosition(event, chart);\n\t\treturn createEvent(type, chart, pos.x, pos.y, event);\n\t}\n\n\tfunction createResizer(handler) {\n\t\tvar iframe = document.createElement('iframe');\n\t\tiframe.className = 'chartjs-hidden-iframe';\n\t\tiframe.style.cssText =\n\t\t\t'display:block;'+\n\t\t\t'overflow:hidden;'+\n\t\t\t'border:0;'+\n\t\t\t'margin:0;'+\n\t\t\t'top:0;'+\n\t\t\t'left:0;'+\n\t\t\t'bottom:0;'+\n\t\t\t'right:0;'+\n\t\t\t'height:100%;'+\n\t\t\t'width:100%;'+\n\t\t\t'position:absolute;'+\n\t\t\t'pointer-events:none;'+\n\t\t\t'z-index:-1;';\n\n\t\t// Prevent the iframe to gain focus on tab.\n\t\t// https://github.com/chartjs/Chart.js/issues/3090\n\t\tiframe.tabIndex = -1;\n\n\t\t// If the iframe is re-attached to the DOM, the resize listener is removed because the\n\t\t// content is reloaded, so make sure to install the handler after the iframe is loaded.\n\t\t// https://github.com/chartjs/Chart.js/issues/3521\n\t\thelpers.addEvent(iframe, 'load', function() {\n\t\t\thelpers.addEvent(iframe.contentWindow || iframe, 'resize', handler);\n\n\t\t\t// The iframe size might have changed while loading, which can also\n\t\t\t// happen if the size has been changed while detached from the DOM.\n\t\t\thandler();\n\t\t});\n\n\t\treturn iframe;\n\t}\n\n\tfunction addResizeListener(node, listener, chart) {\n\t\tvar stub = node._chartjs = {\n\t\t\tticking: false\n\t\t};\n\n\t\t// Throttle the callback notification until the next animation frame.\n\t\tvar notify = function() {\n\t\t\tif (!stub.ticking) {\n\t\t\t\tstub.ticking = true;\n\t\t\t\thelpers.requestAnimFrame.call(window, function() {\n\t\t\t\t\tif (stub.resizer) {\n\t\t\t\t\t\tstub.ticking = false;\n\t\t\t\t\t\treturn listener(createEvent('resize', chart));\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t};\n\n\t\t// Let's keep track of this added iframe and thus avoid DOM query when removing it.\n\t\tstub.resizer = createResizer(notify);\n\n\t\tnode.insertBefore(stub.resizer, node.firstChild);\n\t}\n\n\tfunction removeResizeListener(node) {\n\t\tif (!node || !node._chartjs) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar resizer = node._chartjs.resizer;\n\t\tif (resizer) {\n\t\t\tresizer.parentNode.removeChild(resizer);\n\t\t\tnode._chartjs.resizer = null;\n\t\t}\n\n\t\tdelete node._chartjs;\n\t}\n\n\treturn {\n\t\tacquireContext: function(item, config) {\n\t\t\tif (typeof item === 'string') {\n\t\t\t\titem = document.getElementById(item);\n\t\t\t} else if (item.length) {\n\t\t\t\t// Support for array based queries (such as jQuery)\n\t\t\t\titem = item[0];\n\t\t\t}\n\n\t\t\tif (item && item.canvas) {\n\t\t\t\t// Support for any object associated to a canvas (including a context2d)\n\t\t\t\titem = item.canvas;\n\t\t\t}\n\n\t\t\tif (item instanceof HTMLCanvasElement) {\n\t\t\t\t// To prevent canvas fingerprinting, some add-ons undefine the getContext\n\t\t\t\t// method, for example: https://github.com/kkapsner/CanvasBlocker\n\t\t\t\t// https://github.com/chartjs/Chart.js/issues/2807\n\t\t\t\tvar context = item.getContext && item.getContext('2d');\n\t\t\t\tif (context instanceof CanvasRenderingContext2D) {\n\t\t\t\t\tinitCanvas(item, config);\n\t\t\t\t\treturn context;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn null;\n\t\t},\n\n\t\treleaseContext: function(context) {\n\t\t\tvar canvas = context.canvas;\n\t\t\tif (!canvas._chartjs) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar initial = canvas._chartjs.initial;\n\t\t\t['height', 'width'].forEach(function(prop) {\n\t\t\t\tvar value = initial[prop];\n\t\t\t\tif (value === undefined || value === null) {\n\t\t\t\t\tcanvas.removeAttribute(prop);\n\t\t\t\t} else {\n\t\t\t\t\tcanvas.setAttribute(prop, value);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\thelpers.each(initial.style || {}, function(value, key) {\n\t\t\t\tcanvas.style[key] = value;\n\t\t\t});\n\n\t\t\t// The canvas render size might have been changed (and thus the state stack discarded),\n\t\t\t// we can't use save() and restore() to restore the initial state. So make sure that at\n\t\t\t// least the canvas context is reset to the default state by setting the canvas width.\n\t\t\t// https://www.w3.org/TR/2011/WD-html5-20110525/the-canvas-element.html\n\t\t\tcanvas.width = canvas.width;\n\n\t\t\tdelete canvas._chartjs;\n\t\t},\n\n\t\taddEventListener: function(chart, type, listener) {\n\t\t\tvar canvas = chart.chart.canvas;\n\t\t\tif (type === 'resize') {\n\t\t\t\t// Note: the resize event is not supported on all browsers.\n\t\t\t\taddResizeListener(canvas.parentNode, listener, chart.chart);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar stub = listener._chartjs || (listener._chartjs = {});\n\t\t\tvar proxies = stub.proxies || (stub.proxies = {});\n\t\t\tvar proxy = proxies[chart.id + '_' + type] = function(event) {\n\t\t\t\tlistener(fromNativeEvent(event, chart.chart));\n\t\t\t};\n\n\t\t\thelpers.addEvent(canvas, type, proxy);\n\t\t},\n\n\t\tremoveEventListener: function(chart, type, listener) {\n\t\t\tvar canvas = chart.chart.canvas;\n\t\t\tif (type === 'resize') {\n\t\t\t\t// Note: the resize event is not supported on all browsers.\n\t\t\t\tremoveResizeListener(canvas.parentNode, listener);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar stub = listener._chartjs || {};\n\t\t\tvar proxies = stub.proxies || {};\n\t\t\tvar proxy = proxies[chart.id + '_' + type];\n\t\t\tif (!proxy) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\thelpers.removeEvent(canvas, type, proxy);\n\t\t}\n\t};\n};\n\n},{}],42:[function(require,module,exports){\n'use strict';\n\n// By default, select the browser (DOM) platform.\n// @TODO Make possible to select another platform at build time.\nvar implementation = require(41);\n\nmodule.exports = function(Chart) {\n\t/**\n\t * @namespace Chart.platform\n\t * @see https://chartjs.gitbooks.io/proposals/content/Platform.html\n\t * @since 2.4.0\n\t */\n\tChart.platform = {\n\t\t/**\n\t\t * Called at chart construction time, returns a context2d instance implementing\n\t\t * the [W3C Canvas 2D Context API standard]{@link https://www.w3.org/TR/2dcontext/}.\n\t\t * @param {*} item - The native item from which to acquire context (platform specific)\n\t\t * @param {Object} options - The chart options\n\t\t * @returns {CanvasRenderingContext2D} context2d instance\n\t\t */\n\t\tacquireContext: function() {},\n\n\t\t/**\n\t\t * Called at chart destruction time, releases any resources associated to the context\n\t\t * previously returned by the acquireContext() method.\n\t\t * @param {CanvasRenderingContext2D} context - The context2d instance\n\t\t * @returns {Boolean} true if the method succeeded, else false\n\t\t */\n\t\treleaseContext: function() {},\n\n\t\t/**\n\t\t * Registers the specified listener on the given chart.\n\t\t * @param {Chart} chart - Chart from which to listen for event\n\t\t * @param {String} type - The ({@link IEvent}) type to listen for\n\t\t * @param {Function} listener - Receives a notification (an object that implements\n\t\t * the {@link IEvent} interface) when an event of the specified type occurs.\n\t\t */\n\t\taddEventListener: function() {},\n\n\t\t/**\n\t\t * Removes the specified listener previously registered with addEventListener.\n\t\t * @param {Chart} chart -Chart from which to remove the listener\n\t\t * @param {String} type - The ({@link IEvent}) type to remove\n\t\t * @param {Function} listener - The listener function to remove from the event target.\n\t\t */\n\t\tremoveEventListener: function() {}\n\t};\n\n\t/**\n\t * @interface IPlatform\n\t * Allows abstracting platform dependencies away from the chart\n\t * @borrows Chart.platform.acquireContext as acquireContext\n\t * @borrows Chart.platform.releaseContext as releaseContext\n\t * @borrows Chart.platform.addEventListener as addEventListener\n\t * @borrows Chart.platform.removeEventListener as removeEventListener\n\t */\n\n\t/**\n\t * @interface IEvent\n\t * @prop {String} type - The event type name, possible values are:\n\t * 'contextmenu', 'mouseenter', 'mousedown', 'mousemove', 'mouseup', 'mouseout',\n\t * 'click', 'dblclick', 'keydown', 'keypress', 'keyup' and 'resize'\n\t * @prop {*} native - The original native event (null for emulated events, e.g. 'resize')\n\t * @prop {Number} x - The mouse x position, relative to the canvas (null for incompatible events)\n\t * @prop {Number} y - The mouse y position, relative to the canvas (null for incompatible events)\n\t */\n\n\tChart.helpers.extend(Chart.platform, implementation(Chart));\n};\n\n},{\"41\":41}],43:[function(require,module,exports){\n'use strict';\n\nmodule.exports = function(Chart) {\n\n\tvar helpers = Chart.helpers;\n\t// Default config for a category scale\n\tvar defaultConfig = {\n\t\tposition: 'bottom'\n\t};\n\n\tvar DatasetScale = Chart.Scale.extend({\n\t\t/**\n\t\t* Internal function to get the correct labels. If data.xLabels or data.yLabels are defined, use those\n\t\t* else fall back to data.labels\n\t\t* @private\n\t\t*/\n\t\tgetLabels: function() {\n\t\t\tvar data = this.chart.data;\n\t\t\treturn (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels;\n\t\t},\n\t\t// Implement this so that\n\t\tdetermineDataLimits: function() {\n\t\t\tvar me = this;\n\t\t\tvar labels = me.getLabels();\n\t\t\tme.minIndex = 0;\n\t\t\tme.maxIndex = labels.length - 1;\n\t\t\tvar findIndex;\n\n\t\t\tif (me.options.ticks.min !== undefined) {\n\t\t\t\t// user specified min value\n\t\t\t\tfindIndex = helpers.indexOf(labels, me.options.ticks.min);\n\t\t\t\tme.minIndex = findIndex !== -1 ? findIndex : me.minIndex;\n\t\t\t}\n\n\t\t\tif (me.options.ticks.max !== undefined) {\n\t\t\t\t// user specified max value\n\t\t\t\tfindIndex = helpers.indexOf(labels, me.options.ticks.max);\n\t\t\t\tme.maxIndex = findIndex !== -1 ? findIndex : me.maxIndex;\n\t\t\t}\n\n\t\t\tme.min = labels[me.minIndex];\n\t\t\tme.max = labels[me.maxIndex];\n\t\t},\n\n\t\tbuildTicks: function() {\n\t\t\tvar me = this;\n\t\t\tvar labels = me.getLabels();\n\t\t\t// If we are viewing some subset of labels, slice the original array\n\t\t\tme.ticks = (me.minIndex === 0 && me.maxIndex === labels.length - 1) ? labels : labels.slice(me.minIndex, me.maxIndex + 1);\n\t\t},\n\n\t\tgetLabelForIndex: function(index, datasetIndex) {\n\t\t\tvar me = this;\n\t\t\tvar data = me.chart.data;\n\t\t\tvar isHorizontal = me.isHorizontal();\n\n\t\t\tif (data.yLabels && !isHorizontal) {\n\t\t\t\treturn me.getRightValue(data.datasets[datasetIndex].data[index]);\n\t\t\t}\n\t\t\treturn me.ticks[index - me.minIndex];\n\t\t},\n\n\t\t// Used to get data value locations.  Value can either be an index or a numerical value\n\t\tgetPixelForValue: function(value, index, datasetIndex, includeOffset) {\n\t\t\tvar me = this;\n\t\t\t// 1 is added because we need the length but we have the indexes\n\t\t\tvar offsetAmt = Math.max((me.maxIndex + 1 - me.minIndex - ((me.options.gridLines.offsetGridLines) ? 0 : 1)), 1);\n\n\t\t\tif (value !== undefined && isNaN(index)) {\n\t\t\t\tvar labels = me.getLabels();\n\t\t\t\tvar idx = labels.indexOf(value);\n\t\t\t\tindex = idx !== -1 ? idx : index;\n\t\t\t}\n\n\t\t\tif (me.isHorizontal()) {\n\t\t\t\tvar valueWidth = me.width / offsetAmt;\n\t\t\t\tvar widthOffset = (valueWidth * (index - me.minIndex));\n\n\t\t\t\tif (me.options.gridLines.offsetGridLines && includeOffset || me.maxIndex === me.minIndex && includeOffset) {\n\t\t\t\t\twidthOffset += (valueWidth / 2);\n\t\t\t\t}\n\n\t\t\t\treturn me.left + Math.round(widthOffset);\n\t\t\t}\n\t\t\tvar valueHeight = me.height / offsetAmt;\n\t\t\tvar heightOffset = (valueHeight * (index - me.minIndex));\n\n\t\t\tif (me.options.gridLines.offsetGridLines && includeOffset) {\n\t\t\t\theightOffset += (valueHeight / 2);\n\t\t\t}\n\n\t\t\treturn me.top + Math.round(heightOffset);\n\t\t},\n\t\tgetPixelForTick: function(index, includeOffset) {\n\t\t\treturn this.getPixelForValue(this.ticks[index], index + this.minIndex, null, includeOffset);\n\t\t},\n\t\tgetValueForPixel: function(pixel) {\n\t\t\tvar me = this;\n\t\t\tvar value;\n\t\t\tvar offsetAmt = Math.max((me.ticks.length - ((me.options.gridLines.offsetGridLines) ? 0 : 1)), 1);\n\t\t\tvar horz = me.isHorizontal();\n\t\t\tvar valueDimension = (horz ? me.width : me.height) / offsetAmt;\n\n\t\t\tpixel -= horz ? me.left : me.top;\n\n\t\t\tif (me.options.gridLines.offsetGridLines) {\n\t\t\t\tpixel -= (valueDimension / 2);\n\t\t\t}\n\n\t\t\tif (pixel <= 0) {\n\t\t\t\tvalue = 0;\n\t\t\t} else {\n\t\t\t\tvalue = Math.round(pixel / valueDimension);\n\t\t\t}\n\n\t\t\treturn value;\n\t\t},\n\t\tgetBasePixel: function() {\n\t\t\treturn this.bottom;\n\t\t}\n\t});\n\n\tChart.scaleService.registerScaleType('category', DatasetScale, defaultConfig);\n\n};\n\n},{}],44:[function(require,module,exports){\n'use strict';\n\nmodule.exports = function(Chart) {\n\n\tvar helpers = Chart.helpers;\n\n\tvar defaultConfig = {\n\t\tposition: 'left',\n\t\tticks: {\n\t\t\tcallback: Chart.Ticks.formatters.linear\n\t\t}\n\t};\n\n\tvar LinearScale = Chart.LinearScaleBase.extend({\n\t\tdetermineDataLimits: function() {\n\t\t\tvar me = this;\n\t\t\tvar opts = me.options;\n\t\t\tvar chart = me.chart;\n\t\t\tvar data = chart.data;\n\t\t\tvar datasets = data.datasets;\n\t\t\tvar isHorizontal = me.isHorizontal();\n\n\t\t\tfunction IDMatches(meta) {\n\t\t\t\treturn isHorizontal ? meta.xAxisID === me.id : meta.yAxisID === me.id;\n\t\t\t}\n\n\t\t\t// First Calculate the range\n\t\t\tme.min = null;\n\t\t\tme.max = null;\n\n\t\t\tvar hasStacks = opts.stacked;\n\t\t\tif (hasStacks === undefined) {\n\t\t\t\thelpers.each(datasets, function(dataset, datasetIndex) {\n\t\t\t\t\tif (hasStacks) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar meta = chart.getDatasetMeta(datasetIndex);\n\t\t\t\t\tif (chart.isDatasetVisible(datasetIndex) && IDMatches(meta) &&\n\t\t\t\t\t\tmeta.stack !== undefined) {\n\t\t\t\t\t\thasStacks = true;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (opts.stacked || hasStacks) {\n\t\t\t\tvar valuesPerStack = {};\n\n\t\t\t\thelpers.each(datasets, function(dataset, datasetIndex) {\n\t\t\t\t\tvar meta = chart.getDatasetMeta(datasetIndex);\n\t\t\t\t\tvar key = [\n\t\t\t\t\t\tmeta.type,\n\t\t\t\t\t\t// we have a separate stack for stack=undefined datasets when the opts.stacked is undefined\n\t\t\t\t\t\t((opts.stacked === undefined && meta.stack === undefined) ? datasetIndex : ''),\n\t\t\t\t\t\tmeta.stack\n\t\t\t\t\t].join('.');\n\n\t\t\t\t\tif (valuesPerStack[key] === undefined) {\n\t\t\t\t\t\tvaluesPerStack[key] = {\n\t\t\t\t\t\t\tpositiveValues: [],\n\t\t\t\t\t\t\tnegativeValues: []\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t\t// Store these per type\n\t\t\t\t\tvar positiveValues = valuesPerStack[key].positiveValues;\n\t\t\t\t\tvar negativeValues = valuesPerStack[key].negativeValues;\n\n\t\t\t\t\tif (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {\n\t\t\t\t\t\thelpers.each(dataset.data, function(rawValue, index) {\n\t\t\t\t\t\t\tvar value = +me.getRightValue(rawValue);\n\t\t\t\t\t\t\tif (isNaN(value) || meta.data[index].hidden) {\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tpositiveValues[index] = positiveValues[index] || 0;\n\t\t\t\t\t\t\tnegativeValues[index] = negativeValues[index] || 0;\n\n\t\t\t\t\t\t\tif (opts.relativePoints) {\n\t\t\t\t\t\t\t\tpositiveValues[index] = 100;\n\t\t\t\t\t\t\t} else if (value < 0) {\n\t\t\t\t\t\t\t\tnegativeValues[index] += value;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tpositiveValues[index] += value;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\thelpers.each(valuesPerStack, function(valuesForType) {\n\t\t\t\t\tvar values = valuesForType.positiveValues.concat(valuesForType.negativeValues);\n\t\t\t\t\tvar minVal = helpers.min(values);\n\t\t\t\t\tvar maxVal = helpers.max(values);\n\t\t\t\t\tme.min = me.min === null ? minVal : Math.min(me.min, minVal);\n\t\t\t\t\tme.max = me.max === null ? maxVal : Math.max(me.max, maxVal);\n\t\t\t\t});\n\n\t\t\t} else {\n\t\t\t\thelpers.each(datasets, function(dataset, datasetIndex) {\n\t\t\t\t\tvar meta = chart.getDatasetMeta(datasetIndex);\n\t\t\t\t\tif (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {\n\t\t\t\t\t\thelpers.each(dataset.data, function(rawValue, index) {\n\t\t\t\t\t\t\tvar value = +me.getRightValue(rawValue);\n\t\t\t\t\t\t\tif (isNaN(value) || meta.data[index].hidden) {\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (me.min === null) {\n\t\t\t\t\t\t\t\tme.min = value;\n\t\t\t\t\t\t\t} else if (value < me.min) {\n\t\t\t\t\t\t\t\tme.min = value;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (me.max === null) {\n\t\t\t\t\t\t\t\tme.max = value;\n\t\t\t\t\t\t\t} else if (value > me.max) {\n\t\t\t\t\t\t\t\tme.max = value;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Common base implementation to handle ticks.min, ticks.max, ticks.beginAtZero\n\t\t\tthis.handleTickRangeOptions();\n\t\t},\n\t\tgetTickLimit: function() {\n\t\t\tvar maxTicks;\n\t\t\tvar me = this;\n\t\t\tvar tickOpts = me.options.ticks;\n\n\t\t\tif (me.isHorizontal()) {\n\t\t\t\tmaxTicks = Math.min(tickOpts.maxTicksLimit ? tickOpts.maxTicksLimit : 11, Math.ceil(me.width / 50));\n\t\t\t} else {\n\t\t\t\t// The factor of 2 used to scale the font size has been experimentally determined.\n\t\t\t\tvar tickFontSize = helpers.getValueOrDefault(tickOpts.fontSize, Chart.defaults.global.defaultFontSize);\n\t\t\t\tmaxTicks = Math.min(tickOpts.maxTicksLimit ? tickOpts.maxTicksLimit : 11, Math.ceil(me.height / (2 * tickFontSize)));\n\t\t\t}\n\n\t\t\treturn maxTicks;\n\t\t},\n\t\t// Called after the ticks are built. We need\n\t\thandleDirectionalChanges: function() {\n\t\t\tif (!this.isHorizontal()) {\n\t\t\t\t// We are in a vertical orientation. The top value is the highest. So reverse the array\n\t\t\t\tthis.ticks.reverse();\n\t\t\t}\n\t\t},\n\t\tgetLabelForIndex: function(index, datasetIndex) {\n\t\t\treturn +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);\n\t\t},\n\t\t// Utils\n\t\tgetPixelForValue: function(value) {\n\t\t\t// This must be called after fit has been run so that\n\t\t\t// this.left, this.top, this.right, and this.bottom have been defined\n\t\t\tvar me = this;\n\t\t\tvar start = me.start;\n\n\t\t\tvar rightValue = +me.getRightValue(value);\n\t\t\tvar pixel;\n\t\t\tvar range = me.end - start;\n\n\t\t\tif (me.isHorizontal()) {\n\t\t\t\tpixel = me.left + (me.width / range * (rightValue - start));\n\t\t\t\treturn Math.round(pixel);\n\t\t\t}\n\n\t\t\tpixel = me.bottom - (me.height / range * (rightValue - start));\n\t\t\treturn Math.round(pixel);\n\t\t},\n\t\tgetValueForPixel: function(pixel) {\n\t\t\tvar me = this;\n\t\t\tvar isHorizontal = me.isHorizontal();\n\t\t\tvar innerDimension = isHorizontal ? me.width : me.height;\n\t\t\tvar offset = (isHorizontal ? pixel - me.left : me.bottom - pixel) / innerDimension;\n\t\t\treturn me.start + ((me.end - me.start) * offset);\n\t\t},\n\t\tgetPixelForTick: function(index) {\n\t\t\treturn this.getPixelForValue(this.ticksAsNumbers[index]);\n\t\t}\n\t});\n\tChart.scaleService.registerScaleType('linear', LinearScale, defaultConfig);\n\n};\n\n},{}],45:[function(require,module,exports){\n'use strict';\n\nmodule.exports = function(Chart) {\n\n\tvar helpers = Chart.helpers,\n\t\tnoop = helpers.noop;\n\n\tChart.LinearScaleBase = Chart.Scale.extend({\n\t\thandleTickRangeOptions: function() {\n\t\t\tvar me = this;\n\t\t\tvar opts = me.options;\n\t\t\tvar tickOpts = opts.ticks;\n\n\t\t\t// If we are forcing it to begin at 0, but 0 will already be rendered on the chart,\n\t\t\t// do nothing since that would make the chart weird. If the user really wants a weird chart\n\t\t\t// axis, they can manually override it\n\t\t\tif (tickOpts.beginAtZero) {\n\t\t\t\tvar minSign = helpers.sign(me.min);\n\t\t\t\tvar maxSign = helpers.sign(me.max);\n\n\t\t\t\tif (minSign < 0 && maxSign < 0) {\n\t\t\t\t\t// move the top up to 0\n\t\t\t\t\tme.max = 0;\n\t\t\t\t} else if (minSign > 0 && maxSign > 0) {\n\t\t\t\t\t// move the bottom down to 0\n\t\t\t\t\tme.min = 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (tickOpts.min !== undefined) {\n\t\t\t\tme.min = tickOpts.min;\n\t\t\t} else if (tickOpts.suggestedMin !== undefined) {\n\t\t\t\tme.min = Math.min(me.min, tickOpts.suggestedMin);\n\t\t\t}\n\n\t\t\tif (tickOpts.max !== undefined) {\n\t\t\t\tme.max = tickOpts.max;\n\t\t\t} else if (tickOpts.suggestedMax !== undefined) {\n\t\t\t\tme.max = Math.max(me.max, tickOpts.suggestedMax);\n\t\t\t}\n\n\t\t\tif (me.min === me.max) {\n\t\t\t\tme.max++;\n\n\t\t\t\tif (!tickOpts.beginAtZero) {\n\t\t\t\t\tme.min--;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tgetTickLimit: noop,\n\t\thandleDirectionalChanges: noop,\n\n\t\tbuildTicks: function() {\n\t\t\tvar me = this;\n\t\t\tvar opts = me.options;\n\t\t\tvar tickOpts = opts.ticks;\n\n\t\t\t// Figure out what the max number of ticks we can support it is based on the size of\n\t\t\t// the axis area. For now, we say that the minimum tick spacing in pixels must be 50\n\t\t\t// We also limit the maximum number of ticks to 11 which gives a nice 10 squares on\n\t\t\t// the graph. Make sure we always have at least 2 ticks\n\t\t\tvar maxTicks = me.getTickLimit();\n\t\t\tmaxTicks = Math.max(2, maxTicks);\n\n\t\t\tvar numericGeneratorOptions = {\n\t\t\t\tmaxTicks: maxTicks,\n\t\t\t\tmin: tickOpts.min,\n\t\t\t\tmax: tickOpts.max,\n\t\t\t\tstepSize: helpers.getValueOrDefault(tickOpts.fixedStepSize, tickOpts.stepSize)\n\t\t\t};\n\t\t\tvar ticks = me.ticks = Chart.Ticks.generators.linear(numericGeneratorOptions, me);\n\n\t\t\tme.handleDirectionalChanges();\n\n\t\t\t// At this point, we need to update our max and min given the tick values since we have expanded the\n\t\t\t// range of the scale\n\t\t\tme.max = helpers.max(ticks);\n\t\t\tme.min = helpers.min(ticks);\n\n\t\t\tif (tickOpts.reverse) {\n\t\t\t\tticks.reverse();\n\n\t\t\t\tme.start = me.max;\n\t\t\t\tme.end = me.min;\n\t\t\t} else {\n\t\t\t\tme.start = me.min;\n\t\t\t\tme.end = me.max;\n\t\t\t}\n\t\t},\n\t\tconvertTicksToLabels: function() {\n\t\t\tvar me = this;\n\t\t\tme.ticksAsNumbers = me.ticks.slice();\n\t\t\tme.zeroLineIndex = me.ticks.indexOf(0);\n\n\t\t\tChart.Scale.prototype.convertTicksToLabels.call(me);\n\t\t}\n\t});\n};\n\n},{}],46:[function(require,module,exports){\n'use strict';\n\nmodule.exports = function(Chart) {\n\n\tvar helpers = Chart.helpers;\n\n\tvar defaultConfig = {\n\t\tposition: 'left',\n\n\t\t// label settings\n\t\tticks: {\n\t\t\tcallback: Chart.Ticks.formatters.logarithmic\n\t\t}\n\t};\n\n\tvar LogarithmicScale = Chart.Scale.extend({\n\t\tdetermineDataLimits: function() {\n\t\t\tvar me = this;\n\t\t\tvar opts = me.options;\n\t\t\tvar tickOpts = opts.ticks;\n\t\t\tvar chart = me.chart;\n\t\t\tvar data = chart.data;\n\t\t\tvar datasets = data.datasets;\n\t\t\tvar getValueOrDefault = helpers.getValueOrDefault;\n\t\t\tvar isHorizontal = me.isHorizontal();\n\t\t\tfunction IDMatches(meta) {\n\t\t\t\treturn isHorizontal ? meta.xAxisID === me.id : meta.yAxisID === me.id;\n\t\t\t}\n\n\t\t\t// Calculate Range\n\t\t\tme.min = null;\n\t\t\tme.max = null;\n\t\t\tme.minNotZero = null;\n\n\t\t\tvar hasStacks = opts.stacked;\n\t\t\tif (hasStacks === undefined) {\n\t\t\t\thelpers.each(datasets, function(dataset, datasetIndex) {\n\t\t\t\t\tif (hasStacks) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar meta = chart.getDatasetMeta(datasetIndex);\n\t\t\t\t\tif (chart.isDatasetVisible(datasetIndex) && IDMatches(meta) &&\n\t\t\t\t\t\tmeta.stack !== undefined) {\n\t\t\t\t\t\thasStacks = true;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (opts.stacked || hasStacks) {\n\t\t\t\tvar valuesPerStack = {};\n\n\t\t\t\thelpers.each(datasets, function(dataset, datasetIndex) {\n\t\t\t\t\tvar meta = chart.getDatasetMeta(datasetIndex);\n\t\t\t\t\tvar key = [\n\t\t\t\t\t\tmeta.type,\n\t\t\t\t\t\t// we have a separate stack for stack=undefined datasets when the opts.stacked is undefined\n\t\t\t\t\t\t((opts.stacked === undefined && meta.stack === undefined) ? datasetIndex : ''),\n\t\t\t\t\t\tmeta.stack\n\t\t\t\t\t].join('.');\n\n\t\t\t\t\tif (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {\n\t\t\t\t\t\tif (valuesPerStack[key] === undefined) {\n\t\t\t\t\t\t\tvaluesPerStack[key] = [];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\thelpers.each(dataset.data, function(rawValue, index) {\n\t\t\t\t\t\t\tvar values = valuesPerStack[key];\n\t\t\t\t\t\t\tvar value = +me.getRightValue(rawValue);\n\t\t\t\t\t\t\tif (isNaN(value) || meta.data[index].hidden) {\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tvalues[index] = values[index] || 0;\n\n\t\t\t\t\t\t\tif (opts.relativePoints) {\n\t\t\t\t\t\t\t\tvalues[index] = 100;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// Don't need to split positive and negative since the log scale can't handle a 0 crossing\n\t\t\t\t\t\t\t\tvalues[index] += value;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\thelpers.each(valuesPerStack, function(valuesForType) {\n\t\t\t\t\tvar minVal = helpers.min(valuesForType);\n\t\t\t\t\tvar maxVal = helpers.max(valuesForType);\n\t\t\t\t\tme.min = me.min === null ? minVal : Math.min(me.min, minVal);\n\t\t\t\t\tme.max = me.max === null ? maxVal : Math.max(me.max, maxVal);\n\t\t\t\t});\n\n\t\t\t} else {\n\t\t\t\thelpers.each(datasets, function(dataset, datasetIndex) {\n\t\t\t\t\tvar meta = chart.getDatasetMeta(datasetIndex);\n\t\t\t\t\tif (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {\n\t\t\t\t\t\thelpers.each(dataset.data, function(rawValue, index) {\n\t\t\t\t\t\t\tvar value = +me.getRightValue(rawValue);\n\t\t\t\t\t\t\tif (isNaN(value) || meta.data[index].hidden) {\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (me.min === null) {\n\t\t\t\t\t\t\t\tme.min = value;\n\t\t\t\t\t\t\t} else if (value < me.min) {\n\t\t\t\t\t\t\t\tme.min = value;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (me.max === null) {\n\t\t\t\t\t\t\t\tme.max = value;\n\t\t\t\t\t\t\t} else if (value > me.max) {\n\t\t\t\t\t\t\t\tme.max = value;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (value !== 0 && (me.minNotZero === null || value < me.minNotZero)) {\n\t\t\t\t\t\t\t\tme.minNotZero = value;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tme.min = getValueOrDefault(tickOpts.min, me.min);\n\t\t\tme.max = getValueOrDefault(tickOpts.max, me.max);\n\n\t\t\tif (me.min === me.max) {\n\t\t\t\tif (me.min !== 0 && me.min !== null) {\n\t\t\t\t\tme.min = Math.pow(10, Math.floor(helpers.log10(me.min)) - 1);\n\t\t\t\t\tme.max = Math.pow(10, Math.floor(helpers.log10(me.max)) + 1);\n\t\t\t\t} else {\n\t\t\t\t\tme.min = 1;\n\t\t\t\t\tme.max = 10;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tbuildTicks: function() {\n\t\t\tvar me = this;\n\t\t\tvar opts = me.options;\n\t\t\tvar tickOpts = opts.ticks;\n\n\t\t\tvar generationOptions = {\n\t\t\t\tmin: tickOpts.min,\n\t\t\t\tmax: tickOpts.max\n\t\t\t};\n\t\t\tvar ticks = me.ticks = Chart.Ticks.generators.logarithmic(generationOptions, me);\n\n\t\t\tif (!me.isHorizontal()) {\n\t\t\t\t// We are in a vertical orientation. The top value is the highest. So reverse the array\n\t\t\t\tticks.reverse();\n\t\t\t}\n\n\t\t\t// At this point, we need to update our max and min given the tick values since we have expanded the\n\t\t\t// range of the scale\n\t\t\tme.max = helpers.max(ticks);\n\t\t\tme.min = helpers.min(ticks);\n\n\t\t\tif (tickOpts.reverse) {\n\t\t\t\tticks.reverse();\n\n\t\t\t\tme.start = me.max;\n\t\t\t\tme.end = me.min;\n\t\t\t} else {\n\t\t\t\tme.start = me.min;\n\t\t\t\tme.end = me.max;\n\t\t\t}\n\t\t},\n\t\tconvertTicksToLabels: function() {\n\t\t\tthis.tickValues = this.ticks.slice();\n\n\t\t\tChart.Scale.prototype.convertTicksToLabels.call(this);\n\t\t},\n\t\t// Get the correct tooltip label\n\t\tgetLabelForIndex: function(index, datasetIndex) {\n\t\t\treturn +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);\n\t\t},\n\t\tgetPixelForTick: function(index) {\n\t\t\treturn this.getPixelForValue(this.tickValues[index]);\n\t\t},\n\t\tgetPixelForValue: function(value) {\n\t\t\tvar me = this;\n\t\t\tvar innerDimension;\n\t\t\tvar pixel;\n\n\t\t\tvar start = me.start;\n\t\t\tvar newVal = +me.getRightValue(value);\n\t\t\tvar range;\n\t\t\tvar opts = me.options;\n\t\t\tvar tickOpts = opts.ticks;\n\n\t\t\tif (me.isHorizontal()) {\n\t\t\t\trange = helpers.log10(me.end) - helpers.log10(start); // todo: if start === 0\n\t\t\t\tif (newVal === 0) {\n\t\t\t\t\tpixel = me.left;\n\t\t\t\t} else {\n\t\t\t\t\tinnerDimension = me.width;\n\t\t\t\t\tpixel = me.left + (innerDimension / range * (helpers.log10(newVal) - helpers.log10(start)));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Bottom - top since pixels increase downward on a screen\n\t\t\t\tinnerDimension = me.height;\n\t\t\t\tif (start === 0 && !tickOpts.reverse) {\n\t\t\t\t\trange = helpers.log10(me.end) - helpers.log10(me.minNotZero);\n\t\t\t\t\tif (newVal === start) {\n\t\t\t\t\t\tpixel = me.bottom;\n\t\t\t\t\t} else if (newVal === me.minNotZero) {\n\t\t\t\t\t\tpixel = me.bottom - innerDimension * 0.02;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpixel = me.bottom - innerDimension * 0.02 - (innerDimension * 0.98/ range * (helpers.log10(newVal)-helpers.log10(me.minNotZero)));\n\t\t\t\t\t}\n\t\t\t\t} else if (me.end === 0 && tickOpts.reverse) {\n\t\t\t\t\trange = helpers.log10(me.start) - helpers.log10(me.minNotZero);\n\t\t\t\t\tif (newVal === me.end) {\n\t\t\t\t\t\tpixel = me.top;\n\t\t\t\t\t} else if (newVal === me.minNotZero) {\n\t\t\t\t\t\tpixel = me.top + innerDimension * 0.02;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpixel = me.top + innerDimension * 0.02 + (innerDimension * 0.98/ range * (helpers.log10(newVal)-helpers.log10(me.minNotZero)));\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\trange = helpers.log10(me.end) - helpers.log10(start);\n\t\t\t\t\tinnerDimension = me.height;\n\t\t\t\t\tpixel = me.bottom - (innerDimension / range * (helpers.log10(newVal) - helpers.log10(start)));\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn pixel;\n\t\t},\n\t\tgetValueForPixel: function(pixel) {\n\t\t\tvar me = this;\n\t\t\tvar range = helpers.log10(me.end) - helpers.log10(me.start);\n\t\t\tvar value, innerDimension;\n\n\t\t\tif (me.isHorizontal()) {\n\t\t\t\tinnerDimension = me.width;\n\t\t\t\tvalue = me.start * Math.pow(10, (pixel - me.left) * range / innerDimension);\n\t\t\t} else {  // todo: if start === 0\n\t\t\t\tinnerDimension = me.height;\n\t\t\t\tvalue = Math.pow(10, (me.bottom - pixel) * range / innerDimension) / me.start;\n\t\t\t}\n\t\t\treturn value;\n\t\t}\n\t});\n\tChart.scaleService.registerScaleType('logarithmic', LogarithmicScale, defaultConfig);\n\n};\n\n},{}],47:[function(require,module,exports){\n'use strict';\n\nmodule.exports = function(Chart) {\n\n\tvar helpers = Chart.helpers;\n\tvar globalDefaults = Chart.defaults.global;\n\n\tvar defaultConfig = {\n\t\tdisplay: true,\n\n\t\t// Boolean - Whether to animate scaling the chart from the centre\n\t\tanimate: true,\n\t\tlineArc: false,\n\t\tposition: 'chartArea',\n\n\t\tangleLines: {\n\t\t\tdisplay: true,\n\t\t\tcolor: 'rgba(0, 0, 0, 0.1)',\n\t\t\tlineWidth: 1\n\t\t},\n\n\t\t// label settings\n\t\tticks: {\n\t\t\t// Boolean - Show a backdrop to the scale label\n\t\t\tshowLabelBackdrop: true,\n\n\t\t\t// String - The colour of the label backdrop\n\t\t\tbackdropColor: 'rgba(255,255,255,0.75)',\n\n\t\t\t// Number - The backdrop padding above & below the label in pixels\n\t\t\tbackdropPaddingY: 2,\n\n\t\t\t// Number - The backdrop padding to the side of the label in pixels\n\t\t\tbackdropPaddingX: 2,\n\n\t\t\tcallback: Chart.Ticks.formatters.linear\n\t\t},\n\n\t\tpointLabels: {\n\t\t\t// Number - Point label font size in pixels\n\t\t\tfontSize: 10,\n\n\t\t\t// Function - Used to convert point labels\n\t\t\tcallback: function(label) {\n\t\t\t\treturn label;\n\t\t\t}\n\t\t}\n\t};\n\n\tfunction getValueCount(scale) {\n\t\treturn !scale.options.lineArc ? scale.chart.data.labels.length : 0;\n\t}\n\n\tfunction getPointLabelFontOptions(scale) {\n\t\tvar pointLabelOptions = scale.options.pointLabels;\n\t\tvar fontSize = helpers.getValueOrDefault(pointLabelOptions.fontSize, globalDefaults.defaultFontSize);\n\t\tvar fontStyle = helpers.getValueOrDefault(pointLabelOptions.fontStyle, globalDefaults.defaultFontStyle);\n\t\tvar fontFamily = helpers.getValueOrDefault(pointLabelOptions.fontFamily, globalDefaults.defaultFontFamily);\n\t\tvar font = helpers.fontString(fontSize, fontStyle, fontFamily);\n\n\t\treturn {\n\t\t\tsize: fontSize,\n\t\t\tstyle: fontStyle,\n\t\t\tfamily: fontFamily,\n\t\t\tfont: font\n\t\t};\n\t}\n\n\tfunction measureLabelSize(ctx, fontSize, label) {\n\t\tif (helpers.isArray(label)) {\n\t\t\treturn {\n\t\t\t\tw: helpers.longestText(ctx, ctx.font, label),\n\t\t\t\th: (label.length * fontSize) + ((label.length - 1) * 1.5 * fontSize)\n\t\t\t};\n\t\t}\n\n\t\treturn {\n\t\t\tw: ctx.measureText(label).width,\n\t\t\th: fontSize\n\t\t};\n\t}\n\n\tfunction determineLimits(angle, pos, size, min, max) {\n\t\tif (angle === min || angle === max) {\n\t\t\treturn {\n\t\t\t\tstart: pos - (size / 2),\n\t\t\t\tend: pos + (size / 2)\n\t\t\t};\n\t\t} else if (angle < min || angle > max) {\n\t\t\treturn {\n\t\t\t\tstart: pos - size - 5,\n\t\t\t\tend: pos\n\t\t\t};\n\t\t}\n\n\t\treturn {\n\t\t\tstart: pos,\n\t\t\tend: pos + size + 5\n\t\t};\n\t}\n\n\t/**\n\t * Helper function to fit a radial linear scale with point labels\n\t */\n\tfunction fitWithPointLabels(scale) {\n\t\t/*\n\t\t * Right, this is really confusing and there is a lot of maths going on here\n\t\t * The gist of the problem is here: https://gist.github.com/nnnick/696cc9c55f4b0beb8fe9\n\t\t *\n\t\t * Reaction: https://dl.dropboxusercontent.com/u/34601363/toomuchscience.gif\n\t\t *\n\t\t * Solution:\n\t\t *\n\t\t * We assume the radius of the polygon is half the size of the canvas at first\n\t\t * at each index we check if the text overlaps.\n\t\t *\n\t\t * Where it does, we store that angle and that index.\n\t\t *\n\t\t * After finding the largest index and angle we calculate how much we need to remove\n\t\t * from the shape radius to move the point inwards by that x.\n\t\t *\n\t\t * We average the left and right distances to get the maximum shape radius that can fit in the box\n\t\t * along with labels.\n\t\t *\n\t\t * Once we have that, we can find the centre point for the chart, by taking the x text protrusion\n\t\t * on each side, removing that from the size, halving it and adding the left x protrusion width.\n\t\t *\n\t\t * This will mean we have a shape fitted to the canvas, as large as it can be with the labels\n\t\t * and position it in the most space efficient manner\n\t\t *\n\t\t * https://dl.dropboxusercontent.com/u/34601363/yeahscience.gif\n\t\t */\n\n\t\tvar plFont = getPointLabelFontOptions(scale);\n\n\t\t// Get maximum radius of the polygon. Either half the height (minus the text width) or half the width.\n\t\t// Use this to calculate the offset + change. - Make sure L/R protrusion is at least 0 to stop issues with centre points\n\t\tvar largestPossibleRadius = Math.min(scale.height / 2, scale.width / 2);\n\t\tvar furthestLimits = {\n\t\t\tl: scale.width,\n\t\t\tr: 0,\n\t\t\tt: scale.height,\n\t\t\tb: 0\n\t\t};\n\t\tvar furthestAngles = {};\n\t\tvar i;\n\t\tvar textSize;\n\t\tvar pointPosition;\n\n\t\tscale.ctx.font = plFont.font;\n\t\tscale._pointLabelSizes = [];\n\n\t\tvar valueCount = getValueCount(scale);\n\t\tfor (i = 0; i < valueCount; i++) {\n\t\t\tpointPosition = scale.getPointPosition(i, largestPossibleRadius);\n\t\t\ttextSize = measureLabelSize(scale.ctx, plFont.size, scale.pointLabels[i] || '');\n\t\t\tscale._pointLabelSizes[i] = textSize;\n\n\t\t\t// Add quarter circle to make degree 0 mean top of circle\n\t\t\tvar angleRadians = scale.getIndexAngle(i);\n\t\t\tvar angle = helpers.toDegrees(angleRadians) % 360;\n\t\t\tvar hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);\n\t\t\tvar vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);\n\n\t\t\tif (hLimits.start < furthestLimits.l) {\n\t\t\t\tfurthestLimits.l = hLimits.start;\n\t\t\t\tfurthestAngles.l = angleRadians;\n\t\t\t}\n\n\t\t\tif (hLimits.end > furthestLimits.r) {\n\t\t\t\tfurthestLimits.r = hLimits.end;\n\t\t\t\tfurthestAngles.r = angleRadians;\n\t\t\t}\n\n\t\t\tif (vLimits.start < furthestLimits.t) {\n\t\t\t\tfurthestLimits.t = vLimits.start;\n\t\t\t\tfurthestAngles.t = angleRadians;\n\t\t\t}\n\n\t\t\tif (vLimits.end > furthestLimits.b) {\n\t\t\t\tfurthestLimits.b = vLimits.end;\n\t\t\t\tfurthestAngles.b = angleRadians;\n\t\t\t}\n\t\t}\n\n\t\tscale.setReductions(largestPossibleRadius, furthestLimits, furthestAngles);\n\t}\n\n\t/**\n\t * Helper function to fit a radial linear scale with no point labels\n\t */\n\tfunction fit(scale) {\n\t\tvar largestPossibleRadius = Math.min(scale.height / 2, scale.width / 2);\n\t\tscale.drawingArea = Math.round(largestPossibleRadius);\n\t\tscale.setCenterPoint(0, 0, 0, 0);\n\t}\n\n\tfunction getTextAlignForAngle(angle) {\n\t\tif (angle === 0 || angle === 180) {\n\t\t\treturn 'center';\n\t\t} else if (angle < 180) {\n\t\t\treturn 'left';\n\t\t}\n\n\t\treturn 'right';\n\t}\n\n\tfunction fillText(ctx, text, position, fontSize) {\n\t\tif (helpers.isArray(text)) {\n\t\t\tvar y = position.y;\n\t\t\tvar spacing = 1.5 * fontSize;\n\n\t\t\tfor (var i = 0; i < text.length; ++i) {\n\t\t\t\tctx.fillText(text[i], position.x, y);\n\t\t\t\ty+= spacing;\n\t\t\t}\n\t\t} else {\n\t\t\tctx.fillText(text, position.x, position.y);\n\t\t}\n\t}\n\n\tfunction adjustPointPositionForLabelHeight(angle, textSize, position) {\n\t\tif (angle === 90 || angle === 270) {\n\t\t\tposition.y -= (textSize.h / 2);\n\t\t} else if (angle > 270 || angle < 90) {\n\t\t\tposition.y -= textSize.h;\n\t\t}\n\t}\n\n\tfunction drawPointLabels(scale) {\n\t\tvar ctx = scale.ctx;\n\t\tvar getValueOrDefault = helpers.getValueOrDefault;\n\t\tvar opts = scale.options;\n\t\tvar angleLineOpts = opts.angleLines;\n\t\tvar pointLabelOpts = opts.pointLabels;\n\n\t\tctx.lineWidth = angleLineOpts.lineWidth;\n\t\tctx.strokeStyle = angleLineOpts.color;\n\n\t\tvar outerDistance = scale.getDistanceFromCenterForValue(opts.reverse ? scale.min : scale.max);\n\n\t\t// Point Label Font\n\t\tvar plFont = getPointLabelFontOptions(scale);\n\n\t\tctx.textBaseline = 'top';\n\n\t\tfor (var i = getValueCount(scale) - 1; i >= 0; i--) {\n\t\t\tif (angleLineOpts.display) {\n\t\t\t\tvar outerPosition = scale.getPointPosition(i, outerDistance);\n\t\t\t\tctx.beginPath();\n\t\t\t\tctx.moveTo(scale.xCenter, scale.yCenter);\n\t\t\t\tctx.lineTo(outerPosition.x, outerPosition.y);\n\t\t\t\tctx.stroke();\n\t\t\t\tctx.closePath();\n\t\t\t}\n\t\t\t// Extra 3px out for some label spacing\n\t\t\tvar pointLabelPosition = scale.getPointPosition(i, outerDistance + 5);\n\n\t\t\t// Keep this in loop since we may support array properties here\n\t\t\tvar pointLabelFontColor = getValueOrDefault(pointLabelOpts.fontColor, globalDefaults.defaultFontColor);\n\t\t\tctx.font = plFont.font;\n\t\t\tctx.fillStyle = pointLabelFontColor;\n\n\t\t\tvar angleRadians = scale.getIndexAngle(i);\n\t\t\tvar angle = helpers.toDegrees(angleRadians);\n\t\t\tctx.textAlign = getTextAlignForAngle(angle);\n\t\t\tadjustPointPositionForLabelHeight(angle, scale._pointLabelSizes[i], pointLabelPosition);\n\t\t\tfillText(ctx, scale.pointLabels[i] || '', pointLabelPosition, plFont.size);\n\t\t}\n\t}\n\n\tfunction drawRadiusLine(scale, gridLineOpts, radius, index) {\n\t\tvar ctx = scale.ctx;\n\t\tctx.strokeStyle = helpers.getValueAtIndexOrDefault(gridLineOpts.color, index - 1);\n\t\tctx.lineWidth = helpers.getValueAtIndexOrDefault(gridLineOpts.lineWidth, index - 1);\n\n\t\tif (scale.options.lineArc) {\n\t\t\t// Draw circular arcs between the points\n\t\t\tctx.beginPath();\n\t\t\tctx.arc(scale.xCenter, scale.yCenter, radius, 0, Math.PI * 2);\n\t\t\tctx.closePath();\n\t\t\tctx.stroke();\n\t\t} else {\n\t\t\t// Draw straight lines connecting each index\n\t\t\tvar valueCount = getValueCount(scale);\n\n\t\t\tif (valueCount === 0) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tctx.beginPath();\n\t\t\tvar pointPosition = scale.getPointPosition(0, radius);\n\t\t\tctx.moveTo(pointPosition.x, pointPosition.y);\n\n\t\t\tfor (var i = 1; i < valueCount; i++) {\n\t\t\t\tpointPosition = scale.getPointPosition(i, radius);\n\t\t\t\tctx.lineTo(pointPosition.x, pointPosition.y);\n\t\t\t}\n\n\t\t\tctx.closePath();\n\t\t\tctx.stroke();\n\t\t}\n\t}\n\n\tfunction numberOrZero(param) {\n\t\treturn helpers.isNumber(param) ? param : 0;\n\t}\n\n\tvar LinearRadialScale = Chart.LinearScaleBase.extend({\n\t\tsetDimensions: function() {\n\t\t\tvar me = this;\n\t\t\tvar opts = me.options;\n\t\t\tvar tickOpts = opts.ticks;\n\t\t\t// Set the unconstrained dimension before label rotation\n\t\t\tme.width = me.maxWidth;\n\t\t\tme.height = me.maxHeight;\n\t\t\tme.xCenter = Math.round(me.width / 2);\n\t\t\tme.yCenter = Math.round(me.height / 2);\n\n\t\t\tvar minSize = helpers.min([me.height, me.width]);\n\t\t\tvar tickFontSize = helpers.getValueOrDefault(tickOpts.fontSize, globalDefaults.defaultFontSize);\n\t\t\tme.drawingArea = opts.display ? (minSize / 2) - (tickFontSize / 2 + tickOpts.backdropPaddingY) : (minSize / 2);\n\t\t},\n\t\tdetermineDataLimits: function() {\n\t\t\tvar me = this;\n\t\t\tvar chart = me.chart;\n\t\t\tvar min = Number.POSITIVE_INFINITY;\n\t\t\tvar max = Number.NEGATIVE_INFINITY;\n\n\t\t\thelpers.each(chart.data.datasets, function(dataset, datasetIndex) {\n\t\t\t\tif (chart.isDatasetVisible(datasetIndex)) {\n\t\t\t\t\tvar meta = chart.getDatasetMeta(datasetIndex);\n\n\t\t\t\t\thelpers.each(dataset.data, function(rawValue, index) {\n\t\t\t\t\t\tvar value = +me.getRightValue(rawValue);\n\t\t\t\t\t\tif (isNaN(value) || meta.data[index].hidden) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tmin = Math.min(value, min);\n\t\t\t\t\t\tmax = Math.max(value, max);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tme.min = (min === Number.POSITIVE_INFINITY ? 0 : min);\n\t\t\tme.max = (max === Number.NEGATIVE_INFINITY ? 0 : max);\n\n\t\t\t// Common base implementation to handle ticks.min, ticks.max, ticks.beginAtZero\n\t\t\tme.handleTickRangeOptions();\n\t\t},\n\t\tgetTickLimit: function() {\n\t\t\tvar tickOpts = this.options.ticks;\n\t\t\tvar tickFontSize = helpers.getValueOrDefault(tickOpts.fontSize, globalDefaults.defaultFontSize);\n\t\t\treturn Math.min(tickOpts.maxTicksLimit ? tickOpts.maxTicksLimit : 11, Math.ceil(this.drawingArea / (1.5 * tickFontSize)));\n\t\t},\n\t\tconvertTicksToLabels: function() {\n\t\t\tvar me = this;\n\t\t\tChart.LinearScaleBase.prototype.convertTicksToLabels.call(me);\n\n\t\t\t// Point labels\n\t\t\tme.pointLabels = me.chart.data.labels.map(me.options.pointLabels.callback, me);\n\t\t},\n\t\tgetLabelForIndex: function(index, datasetIndex) {\n\t\t\treturn +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);\n\t\t},\n\t\tfit: function() {\n\t\t\tif (this.options.lineArc) {\n\t\t\t\tfit(this);\n\t\t\t} else {\n\t\t\t\tfitWithPointLabels(this);\n\t\t\t}\n\t\t},\n\t\t/**\n\t\t * Set radius reductions and determine new radius and center point\n\t\t * @private\n\t\t */\n\t\tsetReductions: function(largestPossibleRadius, furthestLimits, furthestAngles) {\n\t\t\tvar me = this;\n\t\t\tvar radiusReductionLeft = furthestLimits.l / Math.sin(furthestAngles.l);\n\t\t\tvar radiusReductionRight = Math.max(furthestLimits.r - me.width, 0) / Math.sin(furthestAngles.r);\n\t\t\tvar radiusReductionTop = -furthestLimits.t / Math.cos(furthestAngles.t);\n\t\t\tvar radiusReductionBottom = -Math.max(furthestLimits.b - me.height, 0) / Math.cos(furthestAngles.b);\n\n\t\t\tradiusReductionLeft = numberOrZero(radiusReductionLeft);\n\t\t\tradiusReductionRight = numberOrZero(radiusReductionRight);\n\t\t\tradiusReductionTop = numberOrZero(radiusReductionTop);\n\t\t\tradiusReductionBottom = numberOrZero(radiusReductionBottom);\n\n\t\t\tme.drawingArea = Math.min(\n\t\t\t\tMath.round(largestPossibleRadius - (radiusReductionLeft + radiusReductionRight) / 2),\n\t\t\t\tMath.round(largestPossibleRadius - (radiusReductionTop + radiusReductionBottom) / 2));\n\t\t\tme.setCenterPoint(radiusReductionLeft, radiusReductionRight, radiusReductionTop, radiusReductionBottom);\n\t\t},\n\t\tsetCenterPoint: function(leftMovement, rightMovement, topMovement, bottomMovement) {\n\t\t\tvar me = this;\n\t\t\tvar maxRight = me.width - rightMovement - me.drawingArea,\n\t\t\t\tmaxLeft = leftMovement + me.drawingArea,\n\t\t\t\tmaxTop = topMovement + me.drawingArea,\n\t\t\t\tmaxBottom = me.height - bottomMovement - me.drawingArea;\n\n\t\t\tme.xCenter = Math.round(((maxLeft + maxRight) / 2) + me.left);\n\t\t\tme.yCenter = Math.round(((maxTop + maxBottom) / 2) + me.top);\n\t\t},\n\n\t\tgetIndexAngle: function(index) {\n\t\t\tvar angleMultiplier = (Math.PI * 2) / getValueCount(this);\n\t\t\tvar startAngle = this.chart.options && this.chart.options.startAngle ?\n\t\t\t\tthis.chart.options.startAngle :\n\t\t\t\t0;\n\n\t\t\tvar startAngleRadians = startAngle * Math.PI * 2 / 360;\n\n\t\t\t// Start from the top instead of right, so remove a quarter of the circle\n\t\t\treturn index * angleMultiplier + startAngleRadians;\n\t\t},\n\t\tgetDistanceFromCenterForValue: function(value) {\n\t\t\tvar me = this;\n\n\t\t\tif (value === null) {\n\t\t\t\treturn 0; // null always in center\n\t\t\t}\n\n\t\t\t// Take into account half font size + the yPadding of the top value\n\t\t\tvar scalingFactor = me.drawingArea / (me.max - me.min);\n\t\t\tif (me.options.reverse) {\n\t\t\t\treturn (me.max - value) * scalingFactor;\n\t\t\t}\n\t\t\treturn (value - me.min) * scalingFactor;\n\t\t},\n\t\tgetPointPosition: function(index, distanceFromCenter) {\n\t\t\tvar me = this;\n\t\t\tvar thisAngle = me.getIndexAngle(index) - (Math.PI / 2);\n\t\t\treturn {\n\t\t\t\tx: Math.round(Math.cos(thisAngle) * distanceFromCenter) + me.xCenter,\n\t\t\t\ty: Math.round(Math.sin(thisAngle) * distanceFromCenter) + me.yCenter\n\t\t\t};\n\t\t},\n\t\tgetPointPositionForValue: function(index, value) {\n\t\t\treturn this.getPointPosition(index, this.getDistanceFromCenterForValue(value));\n\t\t},\n\n\t\tgetBasePosition: function() {\n\t\t\tvar me = this;\n\t\t\tvar min = me.min;\n\t\t\tvar max = me.max;\n\n\t\t\treturn me.getPointPositionForValue(0,\n\t\t\t\tme.beginAtZero? 0:\n\t\t\t\tmin < 0 && max < 0? max :\n\t\t\t\tmin > 0 && max > 0? min :\n\t\t\t\t0);\n\t\t},\n\n\t\tdraw: function() {\n\t\t\tvar me = this;\n\t\t\tvar opts = me.options;\n\t\t\tvar gridLineOpts = opts.gridLines;\n\t\t\tvar tickOpts = opts.ticks;\n\t\t\tvar getValueOrDefault = helpers.getValueOrDefault;\n\n\t\t\tif (opts.display) {\n\t\t\t\tvar ctx = me.ctx;\n\n\t\t\t\t// Tick Font\n\t\t\t\tvar tickFontSize = getValueOrDefault(tickOpts.fontSize, globalDefaults.defaultFontSize);\n\t\t\t\tvar tickFontStyle = getValueOrDefault(tickOpts.fontStyle, globalDefaults.defaultFontStyle);\n\t\t\t\tvar tickFontFamily = getValueOrDefault(tickOpts.fontFamily, globalDefaults.defaultFontFamily);\n\t\t\t\tvar tickLabelFont = helpers.fontString(tickFontSize, tickFontStyle, tickFontFamily);\n\n\t\t\t\thelpers.each(me.ticks, function(label, index) {\n\t\t\t\t\t// Don't draw a centre value (if it is minimum)\n\t\t\t\t\tif (index > 0 || opts.reverse) {\n\t\t\t\t\t\tvar yCenterOffset = me.getDistanceFromCenterForValue(me.ticksAsNumbers[index]);\n\t\t\t\t\t\tvar yHeight = me.yCenter - yCenterOffset;\n\n\t\t\t\t\t\t// Draw circular lines around the scale\n\t\t\t\t\t\tif (gridLineOpts.display && index !== 0) {\n\t\t\t\t\t\t\tdrawRadiusLine(me, gridLineOpts, yCenterOffset, index);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (tickOpts.display) {\n\t\t\t\t\t\t\tvar tickFontColor = getValueOrDefault(tickOpts.fontColor, globalDefaults.defaultFontColor);\n\t\t\t\t\t\t\tctx.font = tickLabelFont;\n\n\t\t\t\t\t\t\tif (tickOpts.showLabelBackdrop) {\n\t\t\t\t\t\t\t\tvar labelWidth = ctx.measureText(label).width;\n\t\t\t\t\t\t\t\tctx.fillStyle = tickOpts.backdropColor;\n\t\t\t\t\t\t\t\tctx.fillRect(\n\t\t\t\t\t\t\t\t\tme.xCenter - labelWidth / 2 - tickOpts.backdropPaddingX,\n\t\t\t\t\t\t\t\t\tyHeight - tickFontSize / 2 - tickOpts.backdropPaddingY,\n\t\t\t\t\t\t\t\t\tlabelWidth + tickOpts.backdropPaddingX * 2,\n\t\t\t\t\t\t\t\t\ttickFontSize + tickOpts.backdropPaddingY * 2\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tctx.textAlign = 'center';\n\t\t\t\t\t\t\tctx.textBaseline = 'middle';\n\t\t\t\t\t\t\tctx.fillStyle = tickFontColor;\n\t\t\t\t\t\t\tctx.fillText(label, me.xCenter, yHeight);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tif (!opts.lineArc) {\n\t\t\t\t\tdrawPointLabels(me);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n\tChart.scaleService.registerScaleType('radialLinear', LinearRadialScale, defaultConfig);\n\n};\n\n},{}],48:[function(require,module,exports){\n/* global window: false */\n'use strict';\n\nvar moment = require(1);\nmoment = typeof(moment) === 'function' ? moment : window.moment;\n\nmodule.exports = function(Chart) {\n\n\tvar helpers = Chart.helpers;\n\tvar time = {\n\t\tunits: [{\n\t\t\tname: 'millisecond',\n\t\t\tsteps: [1, 2, 5, 10, 20, 50, 100, 250, 500]\n\t\t}, {\n\t\t\tname: 'second',\n\t\t\tsteps: [1, 2, 5, 10, 30]\n\t\t}, {\n\t\t\tname: 'minute',\n\t\t\tsteps: [1, 2, 5, 10, 30]\n\t\t}, {\n\t\t\tname: 'hour',\n\t\t\tsteps: [1, 2, 3, 6, 12]\n\t\t}, {\n\t\t\tname: 'day',\n\t\t\tsteps: [1, 2, 5]\n\t\t}, {\n\t\t\tname: 'week',\n\t\t\tmaxStep: 4\n\t\t}, {\n\t\t\tname: 'month',\n\t\t\tmaxStep: 3\n\t\t}, {\n\t\t\tname: 'quarter',\n\t\t\tmaxStep: 4\n\t\t}, {\n\t\t\tname: 'year',\n\t\t\tmaxStep: false\n\t\t}]\n\t};\n\n\tvar defaultConfig = {\n\t\tposition: 'bottom',\n\n\t\ttime: {\n\t\t\tparser: false, // false == a pattern string from http://momentjs.com/docs/#/parsing/string-format/ or a custom callback that converts its argument to a moment\n\t\t\tformat: false, // DEPRECATED false == date objects, moment object, callback or a pattern string from http://momentjs.com/docs/#/parsing/string-format/\n\t\t\tunit: false, // false == automatic or override with week, month, year, etc.\n\t\t\tround: false, // none, or override with week, month, year, etc.\n\t\t\tdisplayFormat: false, // DEPRECATED\n\t\t\tisoWeekday: false, // override week start day - see http://momentjs.com/docs/#/get-set/iso-weekday/\n\t\t\tminUnit: 'millisecond',\n\n\t\t\t// defaults to unit's corresponding unitFormat below or override using pattern string from http://momentjs.com/docs/#/displaying/format/\n\t\t\tdisplayFormats: {\n\t\t\t\tmillisecond: 'h:mm:ss.SSS a', // 11:20:01.123 AM,\n\t\t\t\tsecond: 'h:mm:ss a', // 11:20:01 AM\n\t\t\t\tminute: 'h:mm:ss a', // 11:20:01 AM\n\t\t\t\thour: 'MMM D, hA', // Sept 4, 5PM\n\t\t\t\tday: 'll', // Sep 4 2015\n\t\t\t\tweek: 'll', // Week 46, or maybe \"[W]WW - YYYY\" ?\n\t\t\t\tmonth: 'MMM YYYY', // Sept 2015\n\t\t\t\tquarter: '[Q]Q - YYYY', // Q3\n\t\t\t\tyear: 'YYYY' // 2015\n\t\t\t}\n\t\t},\n\t\tticks: {\n\t\t\tautoSkip: false\n\t\t}\n\t};\n\n\tvar TimeScale = Chart.Scale.extend({\n\t\tinitialize: function() {\n\t\t\tif (!moment) {\n\t\t\t\tthrow new Error('Chart.js - Moment.js could not be found! You must include it before Chart.js to use the time scale. Download at https://momentjs.com');\n\t\t\t}\n\n\t\t\tChart.Scale.prototype.initialize.call(this);\n\t\t},\n\t\tgetLabelMoment: function(datasetIndex, index) {\n\t\t\tif (datasetIndex === null || index === null) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tif (typeof this.labelMoments[datasetIndex] !== 'undefined') {\n\t\t\t\treturn this.labelMoments[datasetIndex][index];\n\t\t\t}\n\n\t\t\treturn null;\n\t\t},\n\t\tgetLabelDiff: function(datasetIndex, index) {\n\t\t\tvar me = this;\n\t\t\tif (datasetIndex === null || index === null) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tif (me.labelDiffs === undefined) {\n\t\t\t\tme.buildLabelDiffs();\n\t\t\t}\n\n\t\t\tif (typeof me.labelDiffs[datasetIndex] !== 'undefined') {\n\t\t\t\treturn me.labelDiffs[datasetIndex][index];\n\t\t\t}\n\n\t\t\treturn null;\n\t\t},\n\t\tgetMomentStartOf: function(tick) {\n\t\t\tvar me = this;\n\t\t\tif (me.options.time.unit === 'week' && me.options.time.isoWeekday !== false) {\n\t\t\t\treturn tick.clone().startOf('isoWeek').isoWeekday(me.options.time.isoWeekday);\n\t\t\t}\n\t\t\treturn tick.clone().startOf(me.tickUnit);\n\t\t},\n\t\tdetermineDataLimits: function() {\n\t\t\tvar me = this;\n\t\t\tme.labelMoments = [];\n\n\t\t\t// Only parse these once. If the dataset does not have data as x,y pairs, we will use\n\t\t\t// these\n\t\t\tvar scaleLabelMoments = [];\n\t\t\tif (me.chart.data.labels && me.chart.data.labels.length > 0) {\n\t\t\t\thelpers.each(me.chart.data.labels, function(label) {\n\t\t\t\t\tvar labelMoment = me.parseTime(label);\n\n\t\t\t\t\tif (labelMoment.isValid()) {\n\t\t\t\t\t\tif (me.options.time.round) {\n\t\t\t\t\t\t\tlabelMoment.startOf(me.options.time.round);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tscaleLabelMoments.push(labelMoment);\n\t\t\t\t\t}\n\t\t\t\t}, me);\n\n\t\t\t\tme.firstTick = moment.min.call(me, scaleLabelMoments);\n\t\t\t\tme.lastTick = moment.max.call(me, scaleLabelMoments);\n\t\t\t} else {\n\t\t\t\tme.firstTick = null;\n\t\t\t\tme.lastTick = null;\n\t\t\t}\n\n\t\t\thelpers.each(me.chart.data.datasets, function(dataset, datasetIndex) {\n\t\t\t\tvar momentsForDataset = [];\n\t\t\t\tvar datasetVisible = me.chart.isDatasetVisible(datasetIndex);\n\n\t\t\t\tif (typeof dataset.data[0] === 'object' && dataset.data[0] !== null) {\n\t\t\t\t\thelpers.each(dataset.data, function(value) {\n\t\t\t\t\t\tvar labelMoment = me.parseTime(me.getRightValue(value));\n\n\t\t\t\t\t\tif (labelMoment.isValid()) {\n\t\t\t\t\t\t\tif (me.options.time.round) {\n\t\t\t\t\t\t\t\tlabelMoment.startOf(me.options.time.round);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tmomentsForDataset.push(labelMoment);\n\n\t\t\t\t\t\t\tif (datasetVisible) {\n\t\t\t\t\t\t\t\t// May have gone outside the scale ranges, make sure we keep the first and last ticks updated\n\t\t\t\t\t\t\t\tme.firstTick = me.firstTick !== null ? moment.min(me.firstTick, labelMoment) : labelMoment;\n\t\t\t\t\t\t\t\tme.lastTick = me.lastTick !== null ? moment.max(me.lastTick, labelMoment) : labelMoment;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}, me);\n\t\t\t\t} else {\n\t\t\t\t\t// We have no labels. Use the ones from the scale\n\t\t\t\t\tmomentsForDataset = scaleLabelMoments;\n\t\t\t\t}\n\n\t\t\t\tme.labelMoments.push(momentsForDataset);\n\t\t\t}, me);\n\n\t\t\t// Set these after we've done all the data\n\t\t\tif (me.options.time.min) {\n\t\t\t\tme.firstTick = me.parseTime(me.options.time.min);\n\t\t\t}\n\n\t\t\tif (me.options.time.max) {\n\t\t\t\tme.lastTick = me.parseTime(me.options.time.max);\n\t\t\t}\n\n\t\t\t// We will modify these, so clone for later\n\t\t\tme.firstTick = (me.firstTick || moment()).clone();\n\t\t\tme.lastTick = (me.lastTick || moment()).clone();\n\t\t},\n\t\tbuildLabelDiffs: function() {\n\t\t\tvar me = this;\n\t\t\tme.labelDiffs = [];\n\t\t\tvar scaleLabelDiffs = [];\n\t\t\t// Parse common labels once\n\t\t\tif (me.chart.data.labels && me.chart.data.labels.length > 0) {\n\t\t\t\thelpers.each(me.chart.data.labels, function(label) {\n\t\t\t\t\tvar labelMoment = me.parseTime(label);\n\n\t\t\t\t\tif (labelMoment.isValid()) {\n\t\t\t\t\t\tif (me.options.time.round) {\n\t\t\t\t\t\t\tlabelMoment.startOf(me.options.time.round);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tscaleLabelDiffs.push(labelMoment.diff(me.firstTick, me.tickUnit, true));\n\t\t\t\t\t}\n\t\t\t\t}, me);\n\t\t\t}\n\n\t\t\thelpers.each(me.chart.data.datasets, function(dataset) {\n\t\t\t\tvar diffsForDataset = [];\n\n\t\t\t\tif (typeof dataset.data[0] === 'object' && dataset.data[0] !== null) {\n\t\t\t\t\thelpers.each(dataset.data, function(value) {\n\t\t\t\t\t\tvar labelMoment = me.parseTime(me.getRightValue(value));\n\n\t\t\t\t\t\tif (labelMoment.isValid()) {\n\t\t\t\t\t\t\tif (me.options.time.round) {\n\t\t\t\t\t\t\t\tlabelMoment.startOf(me.options.time.round);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdiffsForDataset.push(labelMoment.diff(me.firstTick, me.tickUnit, true));\n\t\t\t\t\t\t}\n\t\t\t\t\t}, me);\n\t\t\t\t} else {\n\t\t\t\t\t// We have no labels. Use common ones\n\t\t\t\t\tdiffsForDataset = scaleLabelDiffs;\n\t\t\t\t}\n\n\t\t\t\tme.labelDiffs.push(diffsForDataset);\n\t\t\t}, me);\n\t\t},\n\t\tbuildTicks: function() {\n\t\t\tvar me = this;\n\n\t\t\tme.ctx.save();\n\t\t\tvar tickFontSize = helpers.getValueOrDefault(me.options.ticks.fontSize, Chart.defaults.global.defaultFontSize);\n\t\t\tvar tickFontStyle = helpers.getValueOrDefault(me.options.ticks.fontStyle, Chart.defaults.global.defaultFontStyle);\n\t\t\tvar tickFontFamily = helpers.getValueOrDefault(me.options.ticks.fontFamily, Chart.defaults.global.defaultFontFamily);\n\t\t\tvar tickLabelFont = helpers.fontString(tickFontSize, tickFontStyle, tickFontFamily);\n\t\t\tme.ctx.font = tickLabelFont;\n\n\t\t\tme.ticks = [];\n\t\t\tme.unitScale = 1; // How much we scale the unit by, ie 2 means 2x unit per step\n\t\t\tme.scaleSizeInUnits = 0; // How large the scale is in the base unit (seconds, minutes, etc)\n\n\t\t\t// Set unit override if applicable\n\t\t\tif (me.options.time.unit) {\n\t\t\t\tme.tickUnit = me.options.time.unit || 'day';\n\t\t\t\tme.displayFormat = me.options.time.displayFormats[me.tickUnit];\n\t\t\t\tme.scaleSizeInUnits = me.lastTick.diff(me.firstTick, me.tickUnit, true);\n\t\t\t\tme.unitScale = helpers.getValueOrDefault(me.options.time.unitStepSize, 1);\n\t\t\t} else {\n\t\t\t\t// Determine the smallest needed unit of the time\n\t\t\t\tvar innerWidth = me.isHorizontal() ? me.width : me.height;\n\n\t\t\t\t// Crude approximation of what the label length might be\n\t\t\t\tvar tempFirstLabel = me.tickFormatFunction(me.firstTick, 0, []);\n\t\t\t\tvar tickLabelWidth = me.ctx.measureText(tempFirstLabel).width;\n\t\t\t\tvar cosRotation = Math.cos(helpers.toRadians(me.options.ticks.maxRotation));\n\t\t\t\tvar sinRotation = Math.sin(helpers.toRadians(me.options.ticks.maxRotation));\n\t\t\t\ttickLabelWidth = (tickLabelWidth * cosRotation) + (tickFontSize * sinRotation);\n\t\t\t\tvar labelCapacity = innerWidth / (tickLabelWidth);\n\n\t\t\t\t// Start as small as possible\n\t\t\t\tme.tickUnit = me.options.time.minUnit;\n\t\t\t\tme.scaleSizeInUnits = me.lastTick.diff(me.firstTick, me.tickUnit, true);\n\t\t\t\tme.displayFormat = me.options.time.displayFormats[me.tickUnit];\n\n\t\t\t\tvar unitDefinitionIndex = 0;\n\t\t\t\tvar unitDefinition = time.units[unitDefinitionIndex];\n\n\t\t\t\t// While we aren't ideal and we don't have units left\n\t\t\t\twhile (unitDefinitionIndex < time.units.length) {\n\t\t\t\t\t// Can we scale this unit. If `false` we can scale infinitely\n\t\t\t\t\tme.unitScale = 1;\n\n\t\t\t\t\tif (helpers.isArray(unitDefinition.steps) && Math.ceil(me.scaleSizeInUnits / labelCapacity) < helpers.max(unitDefinition.steps)) {\n\t\t\t\t\t\t// Use one of the predefined steps\n\t\t\t\t\t\tfor (var idx = 0; idx < unitDefinition.steps.length; ++idx) {\n\t\t\t\t\t\t\tif (unitDefinition.steps[idx] >= Math.ceil(me.scaleSizeInUnits / labelCapacity)) {\n\t\t\t\t\t\t\t\tme.unitScale = helpers.getValueOrDefault(me.options.time.unitStepSize, unitDefinition.steps[idx]);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if ((unitDefinition.maxStep === false) || (Math.ceil(me.scaleSizeInUnits / labelCapacity) < unitDefinition.maxStep)) {\n\t\t\t\t\t\t// We have a max step. Scale this unit\n\t\t\t\t\t\tme.unitScale = helpers.getValueOrDefault(me.options.time.unitStepSize, Math.ceil(me.scaleSizeInUnits / labelCapacity));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Move to the next unit up\n\t\t\t\t\t\t++unitDefinitionIndex;\n\t\t\t\t\t\tunitDefinition = time.units[unitDefinitionIndex];\n\n\t\t\t\t\t\tme.tickUnit = unitDefinition.name;\n\t\t\t\t\t\tvar leadingUnitBuffer = me.firstTick.diff(me.getMomentStartOf(me.firstTick), me.tickUnit, true);\n\t\t\t\t\t\tvar trailingUnitBuffer = me.getMomentStartOf(me.lastTick.clone().add(1, me.tickUnit)).diff(me.lastTick, me.tickUnit, true);\n\t\t\t\t\t\tme.scaleSizeInUnits = me.lastTick.diff(me.firstTick, me.tickUnit, true) + leadingUnitBuffer + trailingUnitBuffer;\n\t\t\t\t\t\tme.displayFormat = me.options.time.displayFormats[unitDefinition.name];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar roundedStart;\n\n\t\t\t// Only round the first tick if we have no hard minimum\n\t\t\tif (!me.options.time.min) {\n\t\t\t\tme.firstTick = me.getMomentStartOf(me.firstTick);\n\t\t\t\troundedStart = me.firstTick;\n\t\t\t} else {\n\t\t\t\troundedStart = me.getMomentStartOf(me.firstTick);\n\t\t\t}\n\n\t\t\t// Only round the last tick if we have no hard maximum\n\t\t\tif (!me.options.time.max) {\n\t\t\t\tvar roundedEnd = me.getMomentStartOf(me.lastTick);\n\t\t\t\tvar delta = roundedEnd.diff(me.lastTick, me.tickUnit, true);\n\t\t\t\tif (delta < 0) {\n\t\t\t\t\t// Do not use end of because we need me to be in the next time unit\n\t\t\t\t\tme.lastTick = me.getMomentStartOf(me.lastTick.add(1, me.tickUnit));\n\t\t\t\t} else if (delta >= 0) {\n\t\t\t\t\tme.lastTick = roundedEnd;\n\t\t\t\t}\n\n\t\t\t\tme.scaleSizeInUnits = me.lastTick.diff(me.firstTick, me.tickUnit, true);\n\t\t\t}\n\n\t\t\t// Tick displayFormat override\n\t\t\tif (me.options.time.displayFormat) {\n\t\t\t\tme.displayFormat = me.options.time.displayFormat;\n\t\t\t}\n\n\t\t\t// first tick. will have been rounded correctly if options.time.min is not specified\n\t\t\tme.ticks.push(me.firstTick.clone());\n\n\t\t\t// For every unit in between the first and last moment, create a moment and add it to the ticks tick\n\t\t\tfor (var i = me.unitScale; i <= me.scaleSizeInUnits; i += me.unitScale) {\n\t\t\t\tvar newTick = roundedStart.clone().add(i, me.tickUnit);\n\n\t\t\t\t// Are we greater than the max time\n\t\t\t\tif (me.options.time.max && newTick.diff(me.lastTick, me.tickUnit, true) >= 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tme.ticks.push(newTick);\n\t\t\t}\n\n\t\t\t// Always show the right tick\n\t\t\tvar diff = me.ticks[me.ticks.length - 1].diff(me.lastTick, me.tickUnit);\n\t\t\tif (diff !== 0 || me.scaleSizeInUnits === 0) {\n\t\t\t\t// this is a weird case. If the <max> option is the same as the end option, we can't just diff the times because the tick was created from the roundedStart\n\t\t\t\t// but the last tick was not rounded.\n\t\t\t\tif (me.options.time.max) {\n\t\t\t\t\tme.ticks.push(me.lastTick.clone());\n\t\t\t\t\tme.scaleSizeInUnits = me.lastTick.diff(me.ticks[0], me.tickUnit, true);\n\t\t\t\t} else {\n\t\t\t\t\tme.ticks.push(me.lastTick.clone());\n\t\t\t\t\tme.scaleSizeInUnits = me.lastTick.diff(me.firstTick, me.tickUnit, true);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tme.ctx.restore();\n\n\t\t\t// Invalidate label diffs cache\n\t\t\tme.labelDiffs = undefined;\n\t\t},\n\t\t// Get tooltip label\n\t\tgetLabelForIndex: function(index, datasetIndex) {\n\t\t\tvar me = this;\n\t\t\tvar label = me.chart.data.labels && index < me.chart.data.labels.length ? me.chart.data.labels[index] : '';\n\t\t\tvar value = me.chart.data.datasets[datasetIndex].data[index];\n\n\t\t\tif (value !== null && typeof value === 'object') {\n\t\t\t\tlabel = me.getRightValue(value);\n\t\t\t}\n\n\t\t\t// Format nicely\n\t\t\tif (me.options.time.tooltipFormat) {\n\t\t\t\tlabel = me.parseTime(label).format(me.options.time.tooltipFormat);\n\t\t\t}\n\n\t\t\treturn label;\n\t\t},\n\t\t// Function to format an individual tick mark\n\t\ttickFormatFunction: function(tick, index, ticks) {\n\t\t\tvar formattedTick = tick.format(this.displayFormat);\n\t\t\tvar tickOpts = this.options.ticks;\n\t\t\tvar callback = helpers.getValueOrDefault(tickOpts.callback, tickOpts.userCallback);\n\n\t\t\tif (callback) {\n\t\t\t\treturn callback(formattedTick, index, ticks);\n\t\t\t}\n\t\t\treturn formattedTick;\n\t\t},\n\t\tconvertTicksToLabels: function() {\n\t\t\tvar me = this;\n\t\t\tme.tickMoments = me.ticks;\n\t\t\tme.ticks = me.ticks.map(me.tickFormatFunction, me);\n\t\t},\n\t\tgetPixelForValue: function(value, index, datasetIndex) {\n\t\t\tvar me = this;\n\t\t\tvar offset = null;\n\t\t\tif (index !== undefined && datasetIndex !== undefined) {\n\t\t\t\toffset = me.getLabelDiff(datasetIndex, index);\n\t\t\t}\n\n\t\t\tif (offset === null) {\n\t\t\t\tif (!value || !value.isValid) {\n\t\t\t\t\t// not already a moment object\n\t\t\t\t\tvalue = me.parseTime(me.getRightValue(value));\n\t\t\t\t}\n\t\t\t\tif (value && value.isValid && value.isValid()) {\n\t\t\t\t\toffset = value.diff(me.firstTick, me.tickUnit, true);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (offset !== null) {\n\t\t\t\tvar decimal = offset !== 0 ? offset / me.scaleSizeInUnits : offset;\n\n\t\t\t\tif (me.isHorizontal()) {\n\t\t\t\t\tvar valueOffset = (me.width * decimal);\n\t\t\t\t\treturn me.left + Math.round(valueOffset);\n\t\t\t\t}\n\n\t\t\t\tvar heightOffset = (me.height * decimal);\n\t\t\t\treturn me.top + Math.round(heightOffset);\n\t\t\t}\n\t\t},\n\t\tgetPixelForTick: function(index) {\n\t\t\treturn this.getPixelForValue(this.tickMoments[index], null, null);\n\t\t},\n\t\tgetValueForPixel: function(pixel) {\n\t\t\tvar me = this;\n\t\t\tvar innerDimension = me.isHorizontal() ? me.width : me.height;\n\t\t\tvar offset = (pixel - (me.isHorizontal() ? me.left : me.top)) / innerDimension;\n\t\t\toffset *= me.scaleSizeInUnits;\n\t\t\treturn me.firstTick.clone().add(moment.duration(offset, me.tickUnit).asSeconds(), 'seconds');\n\t\t},\n\t\tparseTime: function(label) {\n\t\t\tvar me = this;\n\t\t\tif (typeof me.options.time.parser === 'string') {\n\t\t\t\treturn moment(label, me.options.time.parser);\n\t\t\t}\n\t\t\tif (typeof me.options.time.parser === 'function') {\n\t\t\t\treturn me.options.time.parser(label);\n\t\t\t}\n\t\t\t// Date objects\n\t\t\tif (typeof label.getMonth === 'function' || typeof label === 'number') {\n\t\t\t\treturn moment(label);\n\t\t\t}\n\t\t\t// Moment support\n\t\t\tif (label.isValid && label.isValid()) {\n\t\t\t\treturn label;\n\t\t\t}\n\t\t\t// Custom parsing (return an instance of moment)\n\t\t\tif (typeof me.options.time.format !== 'string' && me.options.time.format.call) {\n\t\t\t\tconsole.warn('options.time.format is deprecated and replaced by options.time.parser. See http://nnnick.github.io/Chart.js/docs-v2/#scales-time-scale');\n\t\t\t\treturn me.options.time.format(label);\n\t\t\t}\n\t\t\t// Moment format parsing\n\t\t\treturn moment(label, me.options.time.format);\n\t\t}\n\t});\n\tChart.scaleService.registerScaleType('time', TimeScale, defaultConfig);\n\n};\n\n},{\"1\":1}]},{},[7])(7)\n});","( function( $ ) {\n\n\t$( document ).ready( function() {\n\t\t\n\t\t// Clicking the Legend to remove things from view is weird\n\t\tChart.defaults.pie.legend.onClick = function( ) {};\n\n\t\t$( '.chart-container' ).each( function( index, container ) {\n\n\t\t\tvar $chart = $( container ).find( 'canvas' ),\n\t\t\t\tchartData = $chart.data( 'chart_data' );\n\n\t\t\tif ( chartData.length > 0 ) {\n\n\t\t\t\tvar labels = [],\n\t\t\t\t\tvalues = [],\n\t\t\t\t\tcolors = [];\n\n\t\t\t\tfor ( var index in chartData ) {\n\n\t\t\t\t\tlabels.push( chartData[ index ].label );\n\t\t\t\t\tvalues.push( chartData[ index ].percentage );\n\t\t\t\t\tcolors.push( chartData[ index ].color );\n\n\t\t\t\t}\n\n\t\t\t\tvar chart = new Chart( $chart, {\n\t\t\t\t\ttype: 'pie',\n\t\t\t\t\tdata: {\n\t\t\t\t\t\tlabels: labels,\n\t\t\t\t\t\tdatasets: [\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tdata: values,\n\t\t\t\t\t\t\t\tbackgroundColor: colors,\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t]\n\t\t\t\t\t},\n\t\t\t\t\toptions: {\n\t\t\t\t\t\ttooltips: {\n\t\t\t\t\t\t\tcallbacks: {\n\t\t\t\t\t\t\t\tlabel: function( tooltipItem, data ) {\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tvar allData = data.datasets[tooltipItem.datasetIndex].data,\n\t\t\t\t\t\t\t\t\t\ttooltipLabel = data.labels[tooltipItem.index],\n\t\t\t\t\t\t\t\t\t\ttooltipData = allData[tooltipItem.index];\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\treturn ' ' + tooltipLabel + ': ' + tooltipData + '%';\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t} );\n\n\t} );\n\n} )( jQuery );","( function( $ ) {\n    \n    $( document ).ready( function() {\n\n        $( document ).foundation();  \n\n    } );\n    \n} )( jQuery );"]}